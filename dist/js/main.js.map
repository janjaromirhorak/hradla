{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/json-stringify-pretty-compact/index.js","node_modules/libstl/Datastructures/DoublyLinkedList.js","node_modules/libstl/Datastructures/Heap.js","node_modules/libstl/Datastructures/MaxHeap.js","node_modules/libstl/Datastructures/MinHeap.js","node_modules/libstl/Datastructures/PriorityQueue.js","node_modules/libstl/Datastructures/Queue.js","node_modules/libstl/Datastructures/Stack.js","node_modules/libstl/node-module.js","src/es6/canvas.js","src/es6/contextMenu.js","src/es6/editorElements.js","src/es6/findPath.js","src/es6/floatingMenu.js","src/es6/helperFunctions.js","src/es6/id.js","src/es6/logic.js","src/es6/main.js","src/es6/mapWithDefaultValue.js","src/es6/messages.js","src/es6/networkLibrary.js","src/es6/simulation.js","src/es6/svgObjects.js","src/es6/tutorial.js","src/es6/viewbox.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;;;;;;;;;;AAEA;;IAAY,M;;AACZ;;IAAY,c;;AACZ;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;AACA;;;;AACA;;;;AACA;;;;AAEA;;;;;;;;;;AAAwC;;AAExC,IACI,UAAU,EADd;AAAA,IAEI,SAAS,EAFb;;A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","file":"main.js","sourcesContent":["(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()","function stringify (obj, options) {\n  options = options || {}\n  var indent = JSON.stringify([1], null, get(options, 'indent', 2)).slice(2, -3)\n  var addMargin = get(options, 'margins', false)\n  var maxLength = (indent === '' ? Infinity : get(options, 'maxLength', 80))\n\n  return (function _stringify (obj, currentIndent, reserved) {\n    if (obj && typeof obj.toJSON === 'function') {\n      obj = obj.toJSON()\n    }\n\n    var string = JSON.stringify(obj)\n\n    if (string === undefined) {\n      return string\n    }\n\n    var length = maxLength - currentIndent.length - reserved\n\n    if (string.length <= length) {\n      var prettified = prettify(string, addMargin)\n      if (prettified.length <= length) {\n        return prettified\n      }\n    }\n\n    if (typeof obj === 'object' && obj !== null) {\n      var nextIndent = currentIndent + indent\n      var items = []\n      var delimiters\n      var comma = function (array, index) {\n        return (index === array.length - 1 ? 0 : 1)\n      }\n\n      if (Array.isArray(obj)) {\n        for (var index = 0; index < obj.length; index++) {\n          items.push(\n            _stringify(obj[index], nextIndent, comma(obj, index)) || 'null'\n          )\n        }\n        delimiters = '[]'\n      } else {\n        Object.keys(obj).forEach(function (key, index, array) {\n          var keyPart = JSON.stringify(key) + ': '\n          var value = _stringify(obj[key], nextIndent,\n                                 keyPart.length + comma(array, index))\n          if (value !== undefined) {\n            items.push(keyPart + value)\n          }\n        })\n        delimiters = '{}'\n      }\n\n      if (items.length > 0) {\n        return [\n          delimiters[0],\n          indent + items.join(',\\n' + nextIndent),\n          delimiters[1]\n        ].join('\\n' + currentIndent)\n      }\n    }\n\n    return string\n  }(obj, '', 0))\n}\n\n// Note: This regex matches even invalid JSON strings, but since were\n// working on the output of `JSON.stringify` we know that only valid strings\n// are present (unless the user supplied a weird `options.indent` but in\n// that case we dont care since the output would be invalid anyway).\nvar stringOrChar = /(\"(?:[^\\\\\"]|\\\\.)*\")|[:,\\][}{]/g\n\nfunction prettify (string, addMargin) {\n  var m = addMargin ? ' ' : ''\n  var tokens = {\n    '{': '{' + m,\n    '[': '[' + m,\n    '}': m + '}',\n    ']': m + ']',\n    ',': ', ',\n    ':': ': '\n  }\n  return string.replace(stringOrChar, function (match, string) {\n    return string ? match : tokens[match]\n  })\n}\n\nfunction get (options, name, defaultValue) {\n  return (name in options ? options[name] : defaultValue)\n}\n\nmodule.exports = stringify\n","/**\n * The DoublyLinkedList class provides the main functionality of a doubly linked list.\n *\n * @class DoublyLinkedList\n */\nvar DoublyLinkedList = (function () {\n    function DoublyLinkedList() {\n        /**\n         * Count of elements in list\n         *\n         * @property _length\n         * @type number\n         * @private\n         */\n        this._length = 0;\n        /**\n         * Iteration pointer\n         *\n         * @property _key\n         * @type number\n         * @private\n         */\n        this._key = 0;\n        /**\n         * Reference to head(first) element in list\n         *\n         * @property _head\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._head = null;\n        /**\n         * Reference to tail(last) element in list\n         *\n         * @property _tail\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._tail = null;\n        /**\n         * Reference to iterated element in list\n         *\n         * @property _current\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._current = null;\n    }\n    /**\n     * Insert a new value at the specified index\n     *\n     * @method add\n     * @param index The index where the new value is to be inserted.\n     * @param value The new value for the index.\n     * @return void\n     */\n    DoublyLinkedList.prototype.add = function (index, value) {\n        if (index < 0 || index >= this._length) {\n            throw new Error(\"Out of bounds\");\n        }\n        var i = 0;\n        var current = this._head;\n        while (i < index) {\n            current = current.next;\n            i++;\n        }\n        current.value = value;\n    };\n    /**\n     * Pops a node from the end of the doubly linked list\n     *\n     * @method pop\n     * @return any  The value of the popped node.\n     */\n    DoublyLinkedList.prototype.pop = function () {\n        if (this._length === 0) {\n            throw new Error(\"Can't pop from an empty data structure\");\n        }\n        var value = this._tail.value;\n        this._tail = this._tail.prev;\n        if (this._tail) {\n            delete this._tail.next;\n            this._tail.next = null;\n        }\n        this._length--;\n        if (this._length === 0) {\n            delete this._head;\n            this._head = null;\n        }\n        return value;\n    };\n    /**\n     * Shifts a node from the beginning of the doubly linked list\n     *\n     * @method shift\n     * @return any  The value of the shifted node.\n     */\n    DoublyLinkedList.prototype.shift = function () {\n        if (this._length === 0) {\n            throw new Error(\"Can't shift from an empty data structure\");\n        }\n        var value = this._head.value;\n        this._head = this._head.next;\n        if (this._head) {\n            delete this._head.prev;\n            this._head.prev = null;\n        }\n        this._length--;\n        return value;\n    };\n    /**\n     * Pushes an element at the end of the doubly linked list\n     *\n     * @method push\n     * @param value The value to push.\n     * @return void\n     */\n    DoublyLinkedList.prototype.push = function (value) {\n        // allocate new node\n        var node = {\n            value: value,\n            prev: this._tail,\n            next: null\n        };\n        if (this._length === 0) {\n            this._head = this._tail = node;\n        }\n        else {\n            this._tail.next = node;\n            this._tail = this._tail.next;\n        }\n        this._length++;\n    };\n    /**\n     * Prepends the doubly linked list with an element\n     *\n     * @method unshift\n     * @param value The value to unshift.\n     * @return void\n     */\n    DoublyLinkedList.prototype.unshift = function (value) {\n        // allocate new node\n        var node = {\n            value: value,\n            prev: null,\n            next: this._head\n        };\n        if (this._length === 0) {\n            this._head = this._tail = node;\n        }\n        else {\n            this._head.prev = node;\n            this._head = this._head.prev;\n        }\n        this._length++;\n    };\n    /**\n     * Peeks at the node from the end of the doubly linked list\n     *\n     * @method top\n     * @return any  The value of the last node.\n     */\n    DoublyLinkedList.prototype.top = function () {\n        if (this._tail)\n            return this._tail.value;\n    };\n    /**\n     * Peeks at the node from the beginning of the doubly linked list\n     *\n     * @method bottom\n     * @return any  The value of the first node.\n     */\n    DoublyLinkedList.prototype.bottom = function () {\n        if (this._head)\n            return this._head.value;\n    };\n    /**\n     * Counts the number of elements in the doubly linked list\n     *\n     * @method count\n     * @return number the number of elements in the doubly linked list.\n     */\n    DoublyLinkedList.prototype.count = function () {\n        return this._length;\n    };\n    /**\n     * Checks whether the doubly linked list is empty\n     *\n     * @method isEmpty\n     * @return boolean whether the doubly linked list is empty.\n     */\n    DoublyLinkedList.prototype.isEmpty = function () {\n        return (this._length === 0);\n    };\n    /**\n     * Rewind iterator back to the start\n     *\n     * @method rewind\n     * @return void\n     */\n    DoublyLinkedList.prototype.rewind = function () {\n        this._key = 0;\n        this._current = this._head;\n    };\n    /**\n     * Return current list entry\n     *\n     * @method current\n     * @return any  The current node value.\n     */\n    DoublyLinkedList.prototype.current = function () {\n        if (this._current) {\n            return this._current.value;\n        }\n        return null;\n    };\n    /**\n     * Return current node index\n     *\n     * @method key\n     * @return any  The current node index.\n     */\n    DoublyLinkedList.prototype.key = function () {\n        return this._key;\n    };\n    /**\n     * Move to next entry\n     *\n     * @method next\n     * @return void\n     */\n    DoublyLinkedList.prototype.next = function () {\n        this._current = this._current.next;\n        this._key++;\n    };\n    /**\n     * Move to previous entry\n     *\n     * @method prev\n     * @return void\n     */\n    DoublyLinkedList.prototype.prev = function () {\n        this._current = this._current.prev;\n        this._key--;\n    };\n    /**\n     * Check whether the doubly linked list contains more nodes\n     *\n     * @method valid\n     * @return boolean true if the doubly linked list contains any more nodes, false otherwise.\n     */\n    DoublyLinkedList.prototype.valid = function () {\n        return (this._key >= 0 && this._key < this._length);\n    };\n    /**\n     * Export the list to array\n     *\n     * @method toArray\n     * @return Array   The exported array\n     */\n    DoublyLinkedList.prototype.toArray = function () {\n        var list = [];\n        var current = this._head;\n        while (current) {\n            list.push(current.value);\n            current = current.next;\n        }\n        return list;\n    };\n    /**\n     * Serializes the list to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    DoublyLinkedList.prototype.toString = function () {\n        return \"{\" + this.toArray().join(\"->\") + \"}\";\n    };\n    return DoublyLinkedList;\n})();\nmodule.exports = DoublyLinkedList;\n//# sourceMappingURL=DoublyLinkedList.js.map","/**\n * The Heap class provides the main functionality of a Heap.\n *\n * @class Heap\n */\nvar Heap = (function () {\n    function Heap() {\n        /**\n         * Binary tree storage array\n         *\n         * @property _tree\n         * @type Array\n         * @private\n         */\n        this._tree = [];\n        /**\n         * Heap type\n         *\n         * @property _type\n         * @type number\n         * @private\n         */\n        this._type = Heap.MAX;\n        /**\n         * Iteration pointer\n         *\n         * @property _key\n         * @type number\n         * @private\n         */\n        this._key = 0;\n    }\n    /**\n     * Get index of left child element in binary tree stored in array\n     *\n     * @method _child\n     * @param n\n     * @return number\n     * @private\n     */\n    Heap.prototype._child = function (n) {\n        return 2 * n + 1;\n    };\n    /**\n     * Get index of parent element in binary tree stored in array\n     *\n     * @method _parent\n     * @param n\n     * @return number\n     * @private\n     */\n    Heap.prototype._parent = function (n) {\n        //console.log('n=', n, Math.floor(n / 2));\n        return Math.floor(n / 2);\n    };\n    /**\n     * Swap 2 elements in binary tree\n     *\n     * @method _swap\n     * @param first\n     * @param second\n     * @private\n     */\n    Heap.prototype._swap = function (first, second) {\n        var swap = this._tree[first];\n        this._tree[first] = this._tree[second];\n        this._tree[second] = swap;\n    };\n    /**\n     * Sift elements in binary tree\n     *\n     * @method _siftUp\n     * @param i\n     * @private\n     */\n    Heap.prototype._siftUp = function (i) {\n        while (i > 0) {\n            var parent = this._parent(i);\n            if (this.compare(this._tree[i], this._tree[parent]) * this._type > 0) {\n                this._swap(i, parent);\n                i = parent;\n            }\n            else {\n                break;\n            }\n        }\n    };\n    /**\n     * Sift down elements in binary tree\n     *\n     * @method _siftDown\n     * @param i\n     * @private\n     */\n    Heap.prototype._siftDown = function (i) {\n        while (i < this._tree.length) {\n            var left = this._child(i);\n            var right = left + 1;\n            if ((left < this._tree.length) && (right < this._tree.length) &&\n                (this.compare(this._tree[i], this._tree[left]) * this._type < 0 ||\n                    this.compare(this._tree[i], this._tree[right]) * this._type < 0)) {\n                // there is 2 children and one of them must be swapped\n                // get correct element to sift down\n                var sift = left;\n                if (this.compare(this._tree[left], this._tree[right]) * this._type < 0) {\n                    sift = right;\n                }\n                this._swap(i, sift);\n                i = sift;\n            }\n            else if (left < this._tree.length &&\n                this.compare(this._tree[i], this._tree[left]) * this._type < 0) {\n                // only one child exists\n                this._swap(i, left);\n                i = left;\n            }\n            else {\n                break;\n            }\n        }\n    };\n    /**\n     * Extracts a node from top of the heap and sift up\n     *\n     * @method extract\n     * @return any The value of the extracted node.\n     */\n    Heap.prototype.extract = function () {\n        if (this._tree.length === 0) {\n            throw new Error(\"Can't extract from an empty data structure\");\n        }\n        var extracted = this._tree[0];\n        if (this._tree.length === 1) {\n            this._tree = [];\n        }\n        else {\n            this._tree[0] = this._tree.pop();\n            this._siftDown(0);\n        }\n        return extracted;\n    };\n    /**\n     * Inserts an element in the heap by sifting it up\n     *\n     * @method insert\n     * @param value The value to insert.\n     * @return void\n     */\n    Heap.prototype.insert = function (value) {\n        this._tree.push(value);\n        this._siftUp(this._tree.length - 1);\n    };\n    /**\n     * Peeks at the node from the top of the heap\n     *\n     * @method top\n     * @return any The value of the node on the top.\n     */\n    Heap.prototype.top = function () {\n        if (this._tree.length === 0) {\n            throw new Error(\"Can't peek at an empty heap\");\n        }\n        return this._tree[0];\n    };\n    /**\n     * Counts the number of elements in the heap\n     *\n     * @method count\n     * @return number the number of elements in the heap.\n     */\n    Heap.prototype.count = function () {\n        return this._tree.length;\n    };\n    /**\n     * Checks whether the heap is empty\n     *\n     * @method isEmpty\n     * @return boolean whether the heap is empty.\n     */\n    Heap.prototype.isEmpty = function () {\n        return (this._tree.length === 0);\n    };\n    /**\n     * Rewind iterator back to the start (no-op)\n     *\n     * @method rewind\n     * @return void\n     */\n    Heap.prototype.rewind = function () {\n        this._key = 0;\n    };\n    /**\n     * Return current node pointed by the iterator\n     *\n     * @method current\n     * @return any The current node value.\n     */\n    Heap.prototype.current = function () {\n        return this._tree[this._key];\n    };\n    /**\n     * Return current node index\n     *\n     * @method key\n     * @return any The current node index.\n     */\n    Heap.prototype.key = function () {\n        return this._key;\n    };\n    /**\n     * Move to the next node\n     *\n     * @method next\n     * @return void\n     */\n    Heap.prototype.next = function () {\n        this._key++;\n    };\n    /**\n     * Move to previous entry\n     *\n     * @method prev\n     * @return void\n     */\n    Heap.prototype.prev = function () {\n        this._key--;\n    };\n    /**\n     * Check whether the heap contains more nodes\n     *\n     * @method valid\n     * @return boolean true if the heap contains any more nodes, false otherwise.\n     */\n    Heap.prototype.valid = function () {\n        return (this._key >= 0 && this._key < this._tree.length);\n    };\n    /**\n     * Compare elements in order to place them correctly in the heap while sifting up.\n     *\n     * @method compare\n     * @param first The value of the first node being compared.\n     * @param second The value of the second node being compared.\n     * @return number Result of the comparison, positive integer if first is greater than second, 0 if they are equal, negative integer otherwise.\n     * Having multiple elements with the same value in a Heap is not recommended. They will end up in an arbitrary relative position.\n     */\n    Heap.prototype.compare = function (first, second) {\n        if (first > second) {\n            return 1;\n        }\n        else if (first == second) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    };\n    /**\n     * Visually display heap tree\n     *\n     * @method _displayNode\n     * @param node\n     * @param prefix\n     * @param last\n     * @return String\n     * @private\n     */\n    Heap.prototype._displayNode = function (node, prefix, last) {\n        if (prefix === void 0) { prefix = ''; }\n        if (last === void 0) { last = true; }\n        var line = prefix;\n        // get child indexes\n        var left = this._child(node);\n        var right = left + 1;\n        if (last) {\n            line += (prefix ? '' : '  ');\n        }\n        else {\n            line += '';\n        }\n        line += this._tree[node];\n        prefix += (last ? '  ' : ' ');\n        if (left < this._tree.length) {\n            line += '\\n' + this._displayNode(left, prefix, (this._tree[right] == undefined ? true : false));\n        }\n        if (right < this._tree.length) {\n            line += '\\n' + this._displayNode(right, prefix, true);\n        }\n        return line;\n    };\n    /**\n     * Serializes the heap to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    Heap.prototype.toString = function () {\n        // start with root and recursively goes to each node\n        return this._displayNode(0);\n    };\n    /**\n     * Serializes the heap to array\n     *\n     * @method toArray\n     * @return Array   The serialized array.\n     */\n    Heap.prototype.toArray = function () {\n        return this._tree;\n    };\n    /**\n     * Max heap flag\n     *\n     * @property MAX\n     * @type number\n     * @static\n     */\n    Heap.MAX = 1;\n    /**\n     * Min heap flag\n     *\n     * @property MIN\n     * @type number\n     * @static\n     */\n    Heap.MIN = -1;\n    return Heap;\n})();\nmodule.exports = Heap;\n//# sourceMappingURL=Heap.js.map","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar Heap = require('./Heap');\n/**\n * The MaxHeap class provides the main functionality of a heap, keeping the maximum on the top.\n *\n * @class MaxHeap\n * @extends Heap\n */\nvar MaxHeap = (function (_super) {\n    __extends(MaxHeap, _super);\n    function MaxHeap() {\n        _super.apply(this, arguments);\n        this._type = Heap.MAX;\n    }\n    return MaxHeap;\n})(Heap);\nmodule.exports = MaxHeap;\n//# sourceMappingURL=MaxHeap.js.map","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar Heap = require('./Heap');\n/**\n * The MinHeap class provides the main functionality of a heap, keeping the minimum on the top.\n *\n * @class MinHeap\n * @extends Heap\n */\nvar MinHeap = (function (_super) {\n    __extends(MinHeap, _super);\n    function MinHeap() {\n        _super.apply(this, arguments);\n        this._type = Heap.MIN;\n    }\n    return MinHeap;\n})(Heap);\nmodule.exports = MinHeap;\n//# sourceMappingURL=MinHeap.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Heap = require('./Heap');\n/**\n * The PriorityQueue class provides the main functionality of an prioritized queue, implemented using a max heap.\n *\n * @class PriorityQueue\n * @extends Heap\n */\nvar PriorityQueue = (function (_super) {\n    __extends(PriorityQueue, _super);\n    function PriorityQueue() {\n        _super.apply(this, arguments);\n        this._type = Heap.MAX;\n    }\n    /**\n     * Adds an element to the queue\n     *\n     * @method enqueue\n     * @param value The value to enqueue.\n     * @param priority The priority of value.\n     * @return void\n     */\n    PriorityQueue.prototype.enqueue = function (value, priority) {\n        return this.insert(new PriorityQueueNode(value, priority));\n    };\n    /**\n     * Dequeues a node from the queue\n     *\n     * @method dequeue\n     * @return any  The value of the dequeued node.\n     */\n    PriorityQueue.prototype.dequeue = function () {\n        return this.extract().value;\n    };\n    /**\n     * Peeks at the node from the top of the heap\n     *\n     * @method top\n     * @return any The value of the node on the top.\n     */\n    PriorityQueue.prototype.top = function () {\n        return _super.prototype.top.call(this).value;\n    };\n    /**\n     * Compare elements in order to place them correctly in the heap while sifting up.\n     *\n     * @method compare\n     * @param first The value of the first node being compared.\n     * @param second The value of the second node being compared.\n     * @return number Result of the comparison, positive integer if first is greater than second, 0 if they are equal, negative integer otherwise.\n     * Having multiple elements with the same value in a Heap is not recommended. They will end up in an arbitrary relative position.\n     */\n    PriorityQueue.prototype.compare = function (first, second) {\n        if (first.priority > second.priority) {\n            return 1;\n        }\n        else if (first.priority == second.priority) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    };\n    return PriorityQueue;\n})(Heap);\n/**\n * PriorityQueue Node\n *\n * @class PriorityQueueNode\n */\nvar PriorityQueueNode = (function () {\n    /**\n     * Constructor\n     *\n     * @method constructor\n     * @param value\n     * @param priority\n     */\n    function PriorityQueueNode(value, priority) {\n        this.value = value;\n        this.priority = priority;\n    }\n    /**\n     * Serializes the node to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    PriorityQueueNode.prototype.toString = function () {\n        return this.value + \" [\" + this.priority + \"]\";\n    };\n    return PriorityQueueNode;\n})();\nmodule.exports = PriorityQueue;\n//# sourceMappingURL=PriorityQueue.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DoublyLinkedList = require('./DoublyLinkedList');\n/**\n * The Queue class provides the main functionality of a queue implemented using a doubly linked list.\n *\n * @class Queue\n * @extends DoublyLinkedList\n */\nvar Queue = (function (_super) {\n    __extends(Queue, _super);\n    function Queue() {\n        _super.apply(this, arguments);\n    }\n    /**\n     * Adds an element to the queue\n     *\n     * @method enqueue\n     * @param value The value to enqueue.\n     * @return void\n     */\n    Queue.prototype.enqueue = function (value) {\n        return this.push(value);\n    };\n    /**\n     * Dequeues a node from the queue\n     *\n     * @method dequeue\n     * @return any  The value of the dequeued node.\n     */\n    Queue.prototype.dequeue = function () {\n        return this.shift();\n    };\n    return Queue;\n})(DoublyLinkedList);\nmodule.exports = Queue;\n//# sourceMappingURL=Queue.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DoublyLinkedList = require('./DoublyLinkedList');\n/**\n * The Stack class provides the main functionality of a stack implemented using a doubly linked list.\n *\n * @class Stack\n * @extends DoublyLinkedList\n */\nvar Stack = (function (_super) {\n    __extends(Stack, _super);\n    function Stack() {\n        _super.apply(this, arguments);\n    }\n    return Stack;\n})(DoublyLinkedList);\nmodule.exports = Stack;\n//# sourceMappingURL=Stack.js.map","/**\n * STL\n * @type {{DoublyLinkedList: exports, Stack: exports, Queue: exports, Heap: exports, MaxHeap: exports, MinHeap: exports, PriorityQueue: exports}}\n */\nmodule.exports = {\n\tDoublyLinkedList: require('./Datastructures/DoublyLinkedList'),\n\tStack: require('./Datastructures/Stack'),\n\tQueue: require('./Datastructures/Queue'),\n\tHeap: require('./Datastructures/Heap'),\n\tMaxHeap: require('./Datastructures/MaxHeap'),\n\tMinHeap: require('./Datastructures/MinHeap'),\n\tPriorityQueue: require('./Datastructures/PriorityQueue')\n};","\"use strict\";\n\nimport * as svgObj from './svgObjects'\nimport * as editorElements from './editorElements'\nimport Logic from './logic'\nimport ContextMenu from './contextMenu'\nimport FloatingMenu from './floatingMenu'\nimport Simulation from './simulation'\nimport { addMouseScrollEventListener, manhattanDistance } from './helperFunctions'\nimport Tutorial from './tutorial';\nimport ViewBox from './viewbox'\nimport Messages from './messages'\n\nimport { PriorityQueue } from 'libstl'; // note: imported from a node module\n\nconst\n    ctrlKey = 17,\n    cmdKey = 91;\n\n/** @module Canvas */\n/**\n * Main class of the application. It represents an instance of the whole editor and holds\n * references to all its elements.\n */\nexport default class Canvas {\n    /**\n     * Initialize the Svg class\n     * @param {string} canvas   query selector of the SVG element, that will contain all SVG content of the application\n     * @param {number} gridSize initial size of the grid in SVG pixels\n     */\n    constructor(canvas, gridSize) {\n        /**\n         * jQuery element for the SVG document\n         */\n        this.$svg = $(canvas);\n\n        /**\n         * space between grid lines in SVG pixels\n         * @type {number}\n         */\n        this.gridSize = gridSize;\n\n        /**\n         * Array of all boxes (instances of objects derived from editorElements.Box) used on Canvas\n         * @type {Array}\n         */\n        this.boxes = []; // stores all boxes\n\n        /**\n         * Array of all wires (instances of editorElements.Wire) used on Canvas\n         * @type {Array}\n         */\n        this.wires = []; // stores all wires\n\n        // TODO document this\n        this.messages = new Messages();\n\n        this.simulationEnabled = true\n        this.simulation = new Simulation(this); // dummy, will be overwritten on startNewSimulation\n\n        /**\n         * distance from the left top corner to the first element in the imported network\n         * and distance from the left top corner to the imported black box _in grid pixels_\n         * @type {number}\n         */\n        this.leftTopPadding = 4;\n\n        // create the defs element, used for patterns\n        this.$defs = $(\"<defs>\");\n        this.$svg.prepend(this.$defs);\n\n        // BACKGROUND PATTERN\n        let pattern = new svgObj.Pattern(\"grid\", this.gridSize, this.gridSize);\n\n        let patternPoints = new svgObj.PolylinePoints()\n            .append(new svgObj.PolylinePoint(0, 0))\n            .append(new svgObj.PolylinePoint(this.gridSize, 0))\n            .append(new svgObj.PolylinePoint(this.gridSize, this.gridSize));\n\n        pattern.addChild(new svgObj.PolyLine(patternPoints, 2, \"#a3a4d2\"));\n        this.addPattern(pattern.get());\n\n        this.background = new svgObj.Rectangle(0, 0, this.width, this.height, \"url(#grid)\", \"none\");\n        this.appendJQueryObject(this.background.get());\n        this.refresh();\n\n        // set the viewbox for future zooming and moving of the canvas\n        this.$svg.attr('preserveAspectRatio', 'xMinYMin slice')\n        this.viewbox = new ViewBox(0, 0, this.width, this.height)\n        this.applyViewbox()\n\n        // CONSTRUCT CONTEXT MENU\n        this.contextMenu = new ContextMenu(this);\n\n        // CONSTRUCT FLOATING MENU\n        this.floatingMenu = new FloatingMenu(this);\n\n        let target;\n\n        // ALL EVENT CALLBACKS\n        this.$svg.on('mousedown', event => {\n            target = this.getRealTarget(event.target);\n\n            if(target!==undefined) {\n                // propagate mousedown to the real target\n                target.onMouseDown(event);\n            } else {\n                // mousedown happened directly on the svg\n                this.onMouseDown(event)\n            }\n\n            this.hideContextMenu();\n            event.preventDefault();\n        }).on('mousemove', event => {\n            if(target!==undefined) {\n                target.onMouseMove(event);\n            } else {\n                // mousemove happened directly on the svg\n                this.onMouseMove(event)\n            }\n\n            event.preventDefault();\n        }).on('mouseup', event => {\n            if(target!==undefined) {\n                target.onMouseUp(event);\n            } else {\n                // mouseup happened directly on the svg\n                this.onMouseUp(event)\n            }\n\n            target = undefined;\n\n            event.preventDefault();\n        }).on(\"contextmenu\", event => {\n            this.displayContextMenu(event.pageX, event.pageY, this.getRealJQueryTarget(event.target));\n            event.preventDefault();\n        })\n\n        $(document).on('keydown', event => {\n            this.onKeyDown(event);\n        }).on(\"keyup\", event => {\n            this.onKeyUp(event);\n        });\n\n        // update the viewbox on window resize\n        $(window).on('resize', () => {\n            this.viewbox.newDimensions(this.width, this.height);\n            this.applyViewbox();\n        });\n\n        addMouseScrollEventListener(canvas, event => {\n            // zoom only if the ctrl key is pressed\n            if(event.ctrlKey) {\n                switch (event.delta) {\n                    case 1:\n                        this.zoom += 0.1\n                        break\n                    case -1:\n                        this.zoom -= 0.1\n                        break\n                }\n            }\n\n            event.preventDefault()\n        })\n\n        /**\n         * property containing an instance of [Tutorial](./module-Tutorial.html), if there is any\n         * @type {Tutorial}\n         */\n        this.tutorial;\n\n        // check if the user visits for the first time, if so, start the tutorial\n        try {\n            if(!localStorage.userHasVisited) {\n                this.startTutorial();\n            }\n        } catch (e) {\n            console.warn(e);\n        }\n    }\n\n    /**\n     * Get the width of the main SVG element\n     * @return {number} width of the SVG element in pixels\n     */\n    get width() {\n        return this.$svg.width()\n    }\n\n    /**\n     * Get the height of the main SVG element\n     * @return {number} height of the SVG element in pixels\n     */\n    get height() {\n        return this.$svg.height()\n    }\n\n    /**\n     * Process all keydown events that are connected to Canvas\n     * @param  {jquery.KeyboardEvent} event KeyboardEvent generated by a listener\n     */\n    onKeyDown(event) {\n        if(event.keyCode === ctrlKey || event.keyCode === cmdKey) {\n            this.$svg.addClass('grabbable');\n        }\n    }\n\n    /**\n     * Process all keyup events that are connected to Canvas\n     * @param  {jquery.KeyboardEvent} event KeyboardEvent generated by a listener\n     */\n    onKeyUp(event) {\n        if(event.keyCode === ctrlKey || event.keyCode === cmdKey) {\n            this.$svg.removeClass('grabbable');\n        }\n    }\n\n    /**\n     * Process all mousedown events that are happening directly on the Canvas\n     * @param  {jquery.MouseEvent} event MouseEvent generated by a listener\n     */\n    onMouseDown(event) {\n        // middle mouse or left mouse + ctrl moves the canvas\n        if(event.which === 2 || (event.which === 1 && event.ctrlKey)) {\n            this.$svg.addClass('grabbed');\n            this.moveCanvas = {\n                left: event.pageX,\n                top: event.pageY\n            }\n        }\n    }\n\n    /**\n     * Process all mousemove events that are happening directly on the Canvas\n     * @param  {jquery.MouseEvent} event MouseEvent generated by a listener\n     */\n    onMouseMove(event) {\n        if(this.moveCanvas) {\n            let left = event.pageX - this.moveCanvas.left\n            let top = event.pageY - this.moveCanvas.top\n\n            this.viewbox.leftShift += left\n            this.viewbox.topShift += top\n            this.applyViewbox()\n\n            this.moveCanvas = {\n                left: event.pageX,\n                top: event.pageY\n            }\n        }\n    }\n\n    /**\n     * Process all mouseup events that are happening directly on the Canvas\n     */\n    onMouseUp() {\n        if(this.moveCanvas) {\n            this.$svg.removeClass('grabbed');\n            this.moveCanvas = undefined\n\n            // if tutorial exists, call tutorial callback\n            if(this.tutorial) {\n                this.tutorial.onCanvasMoved();\n            }\n        }\n    }\n\n    /**\n     * Set the viewBox attribute of the SVG element and size and position attributes\n     * of the rectangle with the background grid to match the values in this.viewbox\n     */\n    applyViewbox() {\n        // adjust background\n        this.background.addAttr({\n            x: this.viewbox.left,\n            y: this.viewbox.top,\n            width: this.viewbox.width,\n            height: this.viewbox.height\n        })\n\n        // set the viewBox attribute\n        this.$svg.attr('viewBox', this.viewbox.str)\n    }\n\n    /**\n     * Get the current zoom multiplier of the canvas\n     * @return {number}\n     */\n    get zoom() {\n        return this.viewbox.zoom\n    }\n\n    /**\n     * Set the zoom multiplier of the canvas.\n     * I sets the viewbox zoom and then applies the new value by calling this.applyViewbox()\n     * @param  {number} value set the zoom to this value\n     */\n    set zoom(value) {\n        this.viewbox.zoom = value\n        this.applyViewbox()\n\n        // if tutorial exists, call tutorial callback\n        if(this.tutorial) {\n            this.tutorial.onCanvasZoomed();\n        }\n    }\n\n    /**\n     * start the tutorial\n     */\n    startTutorial() {\n        // instantiate the tutorial\n        this.tutorial = new Tutorial(this, () => {\n            // set userHasVisited to true when user closes (or finishes) the tutorial\n            localStorage.userHasVisited = true;\n\n            // unset the this.tutorial property\n            this.tutorial = undefined;\n        });\n\n        // start the tutorial\n        this.tutorial.start();\n    }\n\n    /**\n     * Generate an object containing export data for the Canvas and all elements.\n     * Data from this function should cover all important information needed to import the\n     * network in a different session.\n     * @return {object} object containing infomration about the network\n     */\n    get exportData() {\n        this.exportWireIdMap = new Map();\n        this.exportWireId = 0;\n\n        let data = {\n            boxes: []\n        };\n\n        for (const box of this.boxes) {\n            data.boxes.push(box.exportData)\n        }\n\n        return data;\n    }\n\n    /**\n     * Recreate a logic network from the data provided\n     * @param  {object} data object containing information about the imported network\n     * @param  {number} [x]  horizontal position of the left top corner of the network in grid pixels\n     * @param  {number} [y]  vertical position of the left top corner of the network in grid pixels\n     */\n    importData(data, x, y) {\n        return new Promise(resolve => {\n            let warnings = [];\n\n            // if the x or y is undefined, set it to leftTopPadding instead\n            // (cannot use x || leftTopPadding because of 0)\n            x = x!==undefined ? x : this.leftTopPadding\n            y = y!==undefined ? y : this.leftTopPadding\n\n            this.simulationEnabled = false\n\n            // list of wires to be added\n            let newWires = new Map();\n\n            // find the leftmost and topmost coordinate of any box, save them to leftTopCorner\n            let leftTopCorner = {x: 0, y: 0};\n\n            for (const boxData of data.boxes) {\n                if(boxData.transform && boxData.transform.items) {\n                    for(const transformInfo of boxData.transform.items) {\n                        if(transformInfo.name === \"translate\") {\n                            if(leftTopCorner) {\n                                leftTopCorner = {\n                                    x: Math.min(leftTopCorner.x, transformInfo.args[0]),\n                                    y: Math.min(leftTopCorner.y, transformInfo.args[1])\n                                }\n                            } else {\n                                leftTopCorner = {\n                                    x: transformInfo.args[0],\n                                    y: transformInfo.args[1]\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            for(let boxData of data.boxes) {\n                // add box\n                let box;\n                switch (boxData.category) {\n                    case \"gate\":\n                        // add new gate (without reloading the SVG, we will reload it once after the import)\n                        box = this.newGate(boxData.name, 0, 0, false);\n                        break;\n                    case \"other\":\n                        switch (boxData.name) {\n                            case \"input\":\n                                // add new input (without reloading the SVG, we will reload it once after the import)\n                                box = this.newInput(0, 0, boxData.isOn, false);\n                                break;\n                            case \"output\":\n                                // add new output (without reloading the SVG, we will reload it once after the import)\n                                box = this.newOutput(0, 0, false);\n                                break;\n                            case undefined:\n                                warnings.push(`This network contains a box without a name.`);\n                                break;\n                            default:\n                                warnings.push(`This network contains unknown box names. (${boxData.name})`);\n                        }\n                        break;\n                    case \"blackbox\":\n                        box = this.newBlackbox(boxData.inputs, boxData.outputs, boxData.table, boxData.name, 0, 0, false)\n                        break;\n                    case undefined:\n                        warnings.push(`This network a box without a category.`);\n                        break;\n                    default:\n                        warnings.push(`This network contains unknown box categories. (${boxData.category})`);\n                }\n\n                if (box) {\n                    // proccess box transforms (translation and rotation)\n                    let transform = new editorElements.Transform();\n\n                    if(boxData.transform && boxData.transform.items) {\n                        for(const transformItem of boxData.transform.items) {\n                            switch (transformItem.name) {\n                                case \"translate\":\n                                    transform.setTranslate(\n                                        transformItem.args[0]\n                                            - leftTopCorner.x // make it the relative distance from the leftmost element\n                                            + x // apply the position\n                                            ,\n\n                                        transformItem.args[1]\n                                            - leftTopCorner.y // make it the relative distance from the topmost element\n                                            + y // apply the position\n                                    );\n                                    break;\n                                case \"rotate\":\n                                    // expected 3 arguments\n                                    transform.setRotate(...transformItem.args);\n                                    break;\n                                case undefined:\n                                    warnings.push(`This network contains unnamed transform properties.`);\n                                    break;\n                                default:\n                                    warnings.push(`This network contains unknown transform properties. (${transformItem.name})`);\n                            }\n                        }\n                    }\n\n                    transform.toSVGPixels(this);\n                    box.setTransform(transform);\n\n                    // add all wires to the list of wires to be added\n                    if(boxData.connections) {\n                        for(const connection of boxData.connections) {\n                            // get the artificial wire id\n                            let wireId = connection.wireId;\n\n                            // pass the values got from json into a variable that will be added into the map\n                            let value = {\n                                index: connection.index,\n                                boxId: box.id\n                            };\n\n                            // add the value to the map\n                            if(newWires.has(wireId)) {\n                                // if there already is a wire with this id in the map,\n                                // add the value to the end of the array of values\n                                let mapValue = newWires.get(wireId);\n                                mapValue.push(value);\n                                newWires.set(wireId, mapValue);\n                            } else {\n                                // if there is no wire with this id in the map\n                                // add the wire and set the value to be the first element in the array\n                                newWires.set(wireId, [value]);\n                            }\n                        }\n                    }\n                }\n            }\n\n            // refresh the SVG document (needed for wiring)\n            this.refresh();\n\n            // with all boxes added, we can now connect them with wires\n\n            // priority queue for the new wires, priority being (1 / manhattanDistance) between the conenctors, higher is better\n            let wireQueue = new PriorityQueue();\n\n            // get all ids for lal the\n            for (const wireInfo of newWires.values()) {\n                let connectorIds = [];\n\n                // create an array [connector1Id, connector2Id]\n                for (const {boxId, index} of wireInfo) {\n                    connectorIds.push(\n                        this.getBoxById(boxId).connectors[index].id\n                    )\n                }\n\n                // create and array [{x, y}, {x, y}] containing positions for connectors 1 and 2\n                const connectorsPositions = connectorIds.map(\n                    connectorId => this.getConnectorPosition(\n                        this.getConnectorById(connectorId),\n                        true)\n                    )\n\n                if(connectorsPositions.length === 2) {\n                    let wire = this.newWire(...connectorIds, false, false);\n\n                    // get the manhattan distance between these two connectors\n                    const distance = manhattanDistance(...connectorsPositions);\n\n                    // add connectorids to the priority queue\n                    wireQueue.enqueue(wire, 1 / distance);\n                } else {\n                    warnings.push(`Found a wire that does not have two endings. (It had ${connectorsPositions.length} instead.)`)\n                }\n            }\n\n            if (window.Worker) {\n                let wirePoints = [];\n                let wireReferences = [];\n\n                // convert the queue to an array (this is needed by the web worker)\n                while(!wireQueue.isEmpty()) {\n                    const wire = wireQueue.dequeue();\n\n                    let wireStart = this.getConnectorPosition(wire.startConnector, true);\n                    let wireEnd = this.getConnectorPosition(wire.endConnector, true);\n\n                    wirePoints.push([\n                        {\n                            x: wireStart.x / this.gridSize,\n                            y: wireStart.y / this.gridSize\n                        },\n                        {\n                            x: wireEnd.x / this.gridSize,\n                            y: wireEnd.y / this.gridSize\n                        }\n                    ])\n\n                    wireReferences.push(wire);\n                }\n\n                // [routeWorkerFileName] replaced in the build process (defined in gulpfile) depending on devel / prod build\n                let myWorker = new Worker(\"js/[routeWorkerFileName]\");\n\n                let loadingMessage = this.messages.newLoadingMessage(\"looking for the best wiring\");\n\n                myWorker.onmessage = (event) => {\n                    const {paths} = event.data\n                    // iterate wireReferences and paths synchronously\n                    wireReferences.forEach((wire, key) => {\n                        wire.setWirePath(wire.pathToPolyline(paths[key]))\n                        wire.updateWireState();\n                    })\n\n                    loadingMessage.hide();\n                }\n\n                const message = {\n                    wires: wirePoints,\n                    nonRoutableNodes: this.getNonRoutableNodes(),\n                    inconvenientNodes: this.getInconvenientNodes()\n                }\n\n                myWorker.postMessage(message)\n\n            } else {\n                // web worker is not supported: use an interval to make the import a bit slower\n                // by dividing it into chunks, so the browser window is not entirely frozen when the wiring is happening\n\n                const wiresToBeRoutedAtOnce = 10;\n                const delayBetweenIterations = 200;\n\n                // add wires in the order from short to long\n                let wirePlacingInterval = window.setInterval(() => {\n                    if(!wireQueue.isEmpty()) {\n                        for(let i = 0; i < wiresToBeRoutedAtOnce; ++i) {\n                            if(wireQueue.isEmpty()) {\n                                break;\n                            }\n\n                            const wire = wireQueue.dequeue();\n                            wire.routeWire(true, false);\n                            wire.updateWireState();\n                        }\n                    } else {\n                        console.log(\"finished\");\n                        clearInterval(wirePlacingInterval);\n                    }\n                }, delayBetweenIterations)\n            }\n\n            // refresh the SVG document\n            this.refresh();\n\n            this.simulationEnabled = true;\n            for (let box of this.boxes) {\n                if (box instanceof editorElements.InputBox) {\n                    // switch the input box state to the opposite and back:\n                    // for some reason calling box.refreshState()\n                    // results in weird unfinished simulation\n                    // this causes update of the output connector and thus a start of a new simulation\n\n                    // TODO find better solution instead of this workaround, if there is any\n                    box.on = !box.on\n                    box.on = !box.on\n                }\n            }\n\n            resolve(warnings)\n        })\n    }\n\n    /**\n     * When user clicks on a connector, remember it until they click on some other connector.\n     * Than call newWire with the last two connectors ids as arguments.\n     * @param  {string} connectorId id of the connector that the user clicked on\n     */\n    wireCreationHelper(connectorId) {\n        if(!this.firstConnectorId) {\n            this.firstConnectorId = connectorId;\n        } else {\n            this.newWire(this.firstConnectorId, connectorId);\n            this.firstConnectorId = undefined;\n        }\n    }\n\n    /**\n     * Run a logic simulation from the startingConnector.\n     * This refreshes the states of all elements in the network whose inputs are\n     * directly (or by transition) connected to startingConnector's output\n     * @param  {OutputConnector} startingConnector run simulation from this output connector\n     * @param  {Logic.state} state new state of the startingConnector\n     */\n    startNewSimulation(startingConnector, state) {\n        if(this.simulationEnabled) {\n            this.simulation = new Simulation(this)\n            this.simulation.notifyChange(startingConnector.id, state)\n            this.simulation.run()\n        }\n    }\n\n    /**\n     * Create a new gate on the specified position\n     * @param  {string}  name           type of the gate (and, or ...)\n     * @param  {number}  x              horizontal position of the gate in SVG pixels\n     * @param  {number}  y              vertical position of the gate in SVG pixels\n     * @param  {boolean} [refresh=true] if true, this.refresh() will be called after adding the gate\n     * @return {editorElements.Gate}    instance of Gate that has been newly added\n     */\n    newGate(name, x, y, refresh = true) {\n        return this.newBox(x, y, new editorElements.Gate(this, name, x, y), refresh);\n    }\n\n    /**\n     * Create an input box on the specified position\n     * @param  {number}  x              horizontal position of the gate in SVG pixels\n     * @param  {number}  y              vertical position of the gate in SVG pixels\n     * @param  {boolean} [isOn=false]   state of the input box (default is false (off))\n     * @param  {boolean} [refresh=true] if true, this.refresh() will be called after adding the input box\n     * @return {editorElements.InputBox}    instance of the InputBox that has been newly added\n     */\n    newInput(x, y, isOn = false, refresh = true) {\n        return this.newBox(x, y, new editorElements.InputBox(this, isOn), refresh);\n    }\n\n    /**\n     * Create an output box on the specified position\n     * @param  {number}  x              horizontal position of the gate in SVG pixels\n     * @param  {number}  y              vertical position of the gate in SVG pixels\n     * @param  {boolean} [refresh=true] if true, this.refresh() will be called after adding the output box\n     * @return {editorElements.InputBox}    instance of the OutputBox that has been newly added\n     */\n    newOutput(x, y, refresh = true) {\n        return this.newBox(x, y, new editorElements.OutputBox(this), refresh);\n    }\n\n    /**\n     * Add a new Box to the Canvas\n     * @param  {number}  x              horizontal position of the box in SVG pixels\n     * @param  {number}  y              vertical position of the box in SVG pixels\n     * @param  {editorElements.Box}  object         instance of an object derived from the editorElements.Box class\n     * @param  {Boolean} [refresh=true] if true, this.refresh() will be called after adding the box\n     * @return {editorElements.Box}                 return the instance of the newly added object\n     */\n    newBox(x, y, object, refresh = true) {\n        let index = this.boxes.length;\n\n        this.boxes[index] = object;\n\n        // translate the gate if x and y has been specified\n        if(x && y) {\n            let tr = new editorElements.Transform();\n            tr.setTranslate(x, y);\n\n            this.boxes[index].svgObj.addAttr({\"transform\": tr.get()});\n        }\n\n        this.appendElement(this.boxes[index], refresh);\n\n        // if tutorial exists, call tutorial callback\n        if(this.tutorial) {\n            this.tutorial.onElementAdded(this.boxes[index].name);\n        }\n\n        return this.boxes[index];\n    }\n\n    /**\n     * Remove a box from Canvas based on the provided ID\n     * @param {string} boxId id of the box that should be removed\n     */\n    removeBox(boxId) {\n        let $gate = $(\"#\"+boxId);\n\n        // find the gate in svg's list of gates\n        let gateIndex = -1;\n        for(let i = 0 ; i < this.boxes.length ; i++) {\n            if(this.boxes[i].svgObj.id===boxId) {\n                gateIndex = i;\n                break;\n            }\n        }\n\n        if(gateIndex > -1) {\n            // remove all wires connected to this gate\n            for(let i = 0; i < this.boxes[gateIndex].connectors.length; i++) {\n                this.removeWiresByConnectorId(this.boxes[gateIndex].connectors[i].svgObj.id);\n            }\n\n            // remove the gate\n            this.boxes.splice(gateIndex, 1);\n            $gate.remove();\n\n            // if tutorial exists, call tutorial callback\n            if(this.tutorial) {\n                this.tutorial.onElementRemoved();\n            }\n        } else {\n            console.error(\"Trying to remove an nonexisting box. Box id:\", boxId);\n        }\n    }\n\n    /**\n     * Remove all boxes from the canvas\n     */\n    cleanCanvas() {\n        // cannot simply iterate through the array because removeBox works with it\n\n        // create an array of ids\n        const ids = this.boxes.map(box => box.id);\n\n        // remove all boxes by their ids\n        for (const id of ids) {\n            this.removeBox(id);\n        }\n    }\n\n    /**\n     * Create a new wire connecting the provided connectors\n     * @param  {string}  fromId         id of the connector that the wire is attached to\n     * @param  {string}  toId           id of the connector that the wire is attached to\n     * @param  {Boolean} [refresh=true] if refresh is set to true, the SVG document will be reloaded after adding the wire\n     * @return {editorElements.Wire}    instance of editorElements.Wire that has been added to the Canvas\n     */\n    newWire(fromId, toId, refresh = true, route = true) {\n        // wire must connect two distinct connectors\n        if (fromId===toId)\n            return false\n\n        let connectors = [this.getConnectorById(fromId), this.getConnectorById(toId)]\n\n        // input connectors can be connected to one wire max\n        connectors.forEach(conn => {\n            if(conn.isInputConnector)\n                this.removeWiresByConnectorId(conn.id)\n        })\n        let index = this.wires.length;\n        this.wires[index] = new editorElements.Wire(this, fromId, toId, refresh, route);\n\n        connectors.forEach(conn => {\n            conn.addWireId(this.wires[index].svgObj.id);\n        })\n\n        this.appendElement(this.wires[index], refresh);\n        this.moveToBackById(this.wires[index].svgObj.id);\n\n        if(refresh)\n            this.wires[index].updateWireState()\n\n        return this.wires[index];\n    }\n\n    /**\n     * get the coordinates of the specified connector\n     * @param  {Connector}  connector      instance of {@link Connector}\n     * @param  {Boolean} [snapToGrid=true] if true, the connector position will be snapped to the grid\n     * @return {Object}                    point - object containing numeric attributes `x` and `y`\n     */\n    getConnectorPosition(connector, snapToGrid = true) {\n        // connector.svgObj.id has to be called, else the getCoordinates does not work on the first call in Firefox 55\n        const dummy = connector.svgObj.id; // eslint-disable-line no-unused-vars\n\n        let $connector = connector.svgObj.$el;\n\n        let position = $connector.position();\n\n        position.left = this.viewbox.transformX(position.left)\n        position.top = this.viewbox.transformY(position.top)\n\n        let width = $connector.attr(\"width\");\n        let height = $connector.attr(\"height\");\n\n        let x = position.left + width / 2;\n        let y = position.top + height / 2;\n        if(snapToGrid) {\n            x = this.snapToGrid(x);\n            y = this.snapToGrid(y);\n        }\n\n        return {\n            x: x,\n            y: y\n        };\n    }\n\n    /**\n     * creates a new blackbox\n     * @param  {number} x       horizontal position of the blackbox in SVG pixels\n     * @param  {number} y       vertical position of the gate in SVG pixels\n     * @param  {number} inputs  number of input pins of this blackbox\n     * @param  {number} outputs number of output pins of this blackbox\n     * @param  {Array} table   Array of arrays, each inner array contains list of [Logic.state](./module-Logic.html#.state)s,\n     *                          that describe the combination of input pin and output pin states in the order from the top to bottom for both input and output connectors.\n     *                          If we had an AND array as a blackbox, one of the states could be `[Logic.state.on, Logic.state.off, Logic.state.off]`\n     *                          which means that if the first input connector is in the `on` state and the second connector is in the `off` state,\n     *                          the state of the output connector will be `off`.\n     *                          The array can be described as `[state for input conn 1, state for input conn 2, ..., state for output conn 1, state for output conn 2 ...]`.\n     * @param  {string}  name   a name that will be displayed on the blackbox\n     * @param  {boolean} [refresh=true] if true, this.refresh() will be called after adding the gate\n     *\n     * @return {editorElements.Blackbox} instance of {@link Blackbox} that has been added to the [Canvas](./module-Canvas.html)\n     */\n    newBlackbox(inputs, outputs, table, name, x, y, refresh=true) {\n        const index = this.boxes.length;\n\n        this.boxes[index] = new editorElements.Blackbox(\n            this,\n            inputs,\n            outputs,\n            (...inputStates) => {\n                for (const line of table) {\n                    const lineInputStates = line.slice(0, inputs);\n\n                    // if every input state matches the corresponding input state in this line of the truth table\n                    if(inputStates.every((value, index) => value === lineInputStates[index])) {\n                        // return the rest of the line as output\n                        return line.slice(inputs);\n                    }\n                }\n                // if nothing matches, set all outputs to undefined\n                return Array.from(new Array(outputs), () => Logic.state.unknown)\n            },\n            name\n        );\n\n        if(x && y) {\n            let tr = new editorElements.Transform();\n            tr.setTranslate(x, y);\n\n            this.boxes[index].svgObj.addAttr({\"transform\": tr.get()});\n        }\n\n        this.appendElement(this.boxes[index], refresh);\n\n        return this.boxes[index];\n    }\n\n    /**\n     * Find the correct instance of editorElements.Wire in the Canvas' wires by the provided id\n     * @param  {string} wireId id of the wire\n     * @return {editorElements.Wire} instance of the wire\n     */\n    getWireById(wireId) {\n        for (const wire of this.wires) {\n            if(wire.svgObj.id === wireId) {\n                return wire\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Find all wires that are connected to the specified connector\n     * @param  {string} connectorId id of the connector\n     * @return {Set} set of ID's of the wires connected to this connector\n     */\n    getWiresByConnectorId(connectorId) {\n        let connector = this.getConnectorById(connectorId);\n        return connector.wireIds;\n    }\n\n    /**\n     * Remove wire that has the provided ID\n     * @param  {string} wireId ID of the wire that should be removed\n     */\n    removeWireById(wireId) {\n        for(let i = 0 ; i < this.wires.length ; ++i) {\n            if (this.wires[i].svgObj.id === wireId) {\n\n                let connector1 = this.wires[i].startConnector;\n                let connector2 = this.wires[i].endConnector;\n\n                connector1.removeWireIdAndUpdate(wireId);\n                connector2.removeWireIdAndUpdate(wireId);\n\n                this.wires[i].svgObj.$el.remove();\n                this.wires.splice(i, 1);\n\n                break;\n            }\n        }\n    }\n\n    /**\n     * Remove all wires that are connected to the connector provided by its ID\n     * @param  {string} connectorId ID of the connector\n     */\n    removeWiresByConnectorId(connectorId) {\n        let connector = this.getConnectorById(connectorId);\n\n        connector.wireIds.forEach(wireId => {\n            let wire = this.getWireById(wireId);\n\n            // get the other connector that is the wire connected to\n            let otherConnector = this.getConnectorById(wire.fromId, wire);\n            if(otherConnector.svgObj.id===connectorId) {\n                otherConnector = this.getConnectorById(wire.toId, wire);\n            }\n\n            // delete the wire record from the other connector\n            otherConnector.wireIds.delete(wireId);\n\n            // remove the wire representation using jQuery\n            $(\"#\" + wireId).remove();\n\n            // if otherConnector is an input connector, set its state to unknown\n            if(otherConnector.isInputConnector) {\n                this.startNewSimulation(otherConnector, Logic.state.unknown)\n            }\n        });\n\n        // clear the list of wire Ids\n        connector.wireIds.clear();\n        // if connector is an input connector, set its state to unknown\n        if(connector.isInputConnector) {\n            connector.setState(Logic.state.unknown);\n        }\n    }\n\n    /**\n     * Find the correct instance of editorElements.Box in the Canvas' boxes by the provided id\n     * @param  {string} boxId id of the box\n     * @return {editorElements.Box} instance of the box\n     */\n    getBoxById(boxId) {\n        for(let i = 0 ; i < this.boxes.length ; i++) {\n            if(this.boxes[i].svgObj.id===boxId) {\n                return this.boxes[i];\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Find the correct instance of editorElements.Box in the Canvas' boxes by ID of a connector that belongs to this box\n     * @param  {string} boxId id of the connector\n     * @return {editorElements.Box} instance of the box\n     */\n    getBoxByConnectorId(connectorId) {\n        for(let i = 0 ; i < this.boxes.length ; i++) {\n            if (this.boxes[i].getConnectorById(connectorId) !== undefined) {\n                return this.boxes[i];\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Get instance of a connector based on it's ID (and also on an instance of editorElements.Wire if provided)\n     *\n     * The wire variable is used as heuristic: When we know the wire, we have to check only\n     * two gates instead of all of them\n     * @param  {string} connectorId id of the connector\n     * @param  {editorElements.Wire} [wire]      instance of the Wire that is connected to this connector\n     * @return {editorElements.Connector}        instance of the connector\n     */\n    getConnectorById(connectorId, wire=undefined) {\n\n        if(wire!==undefined) {\n            // we know the wire -- we can check only gates at the ends of this wire\n            let connector = wire.startBox.getConnectorById(connectorId)\n            if (!connector) {\n                connector = wire.endBox.getConnectorById(connectorId)\n            }\n            return connector\n\n        } else {\n            // we do not know the wire -- we have to check all gates\n            for (const box of this.boxes) {\n                const connector = box.getConnectorById(connectorId)\n                if(connector) {\n                    return connector\n                }\n            }\n        }\n\n        return false\n    }\n\n    /**\n     * Get the logical jQuery target based on the factual jQuery target.\n     *\n     * If the object, that user interacted with, is not a connector and is in a group,\n     * return the group jQuery object instead of the original jQuery object.\n     * @param  {target} target jQuery target of the object user interacted with\n     * @return {target}        jQuery target of the object user wanted to interact with\n     */\n    getRealJQueryTarget(target) {\n        let $target = $(target);\n        if(!$target.hasClass(\"connector\") && $target.parents('g').length > 0) {\n            $target = $target.parent();\n            while ($target.prop(\"tagName\") !== \"G\" && $target.prop(\"tagName\") !== \"g\") {\n                $target = $target.parent();\n            }\n        }\n        return $target;\n    }\n\n    // returns the editorElement that user interacted with, the \"target\" argument is a jQuery element\n    /**\n     * Get instance of some object from editorElement based on the jQuery target\n     * @param  {target} target jQuery target that user interacted with\n     * @return {editorElements.NetworkElement} instance of an object derived from editorElements.NetworkElement that the user interacted with\n     */\n    getRealTarget(target) {\n        if (target===undefined) {\n            return undefined;\n        }\n\n        // eventy se museji zpracovat tady, protoze v SVG se eventy nepropaguji\n        let $target = $(target);\n\n        if($target.hasClass(\"connector\")) {\n            // this is a connector, don't traverse groups\n            return this.getConnectorById($target.attr('id'));\n        } else if($target.parents('g').length > 0) {\n            // this element is in a group and it is not a connector\n\n            // traversing up the DOM tree until we find the closest group\n            let $parentGroup = $target.parent();\n            while ($parentGroup.prop(\"tagName\") !== \"G\" && $parentGroup.prop(\"tagName\") !== \"g\") {\n                $parentGroup = $parentGroup.parent();\n            }\n\n            // try to match the jQuery element to the logical element using DOM classes\n\n            if($parentGroup.hasClass(\"box\")) {\n                // return the corresponding box\n                return this.getBoxById($parentGroup.attr('id'));\n            } else if($parentGroup.hasClass(\"wire\")) {\n                // return the corresponding wire\n                return this.getWireById($parentGroup.attr('id'));\n            } else {\n                // found a group that contains the target, but this group does not match any known element types\n                return undefined;\n            }\n        } else {\n            // element does not match any known element types\n            return undefined;\n        }\n    }\n\n    /**\n     * Add an element to the Canvas\n     * @param  {editorElements.NetworkElement}  element Element that will be added on the Canvas\n     * @param  {Boolean} [refresh=true] if true, the SVG document will be reloaded after adding this element\n     */\n    appendElement(element, refresh = true) {\n        this.appendJQueryObject(element.get(), refresh);\n    }\n\n    /**\n     * Append a jQuery element to the SVG document (helper for this.appendElement)\n     * @param  {object}  object         jQuery element that will be added to the SVG document\n     * @param  {Boolean} [refresh=true] if true, the SVG document will be reloaded after adding this element\n     */\n    appendJQueryObject(object, refresh = true) {\n        this.$svg.append(object);\n        if(refresh)\n            this.refresh();\n    }\n\n    /**\n     * Add a new pattern to the definitions element in the SVG document\n     * @param {svgObj.Pattern} pattern pattern that will be added to the <devs> element in the SVG document\n     */\n    addPattern(pattern) {\n        this.$defs.append(pattern);\n        this.refresh();\n    }\n\n    /**\n     * Reload the SVG document (needed to display a newly appended jQuery object)\n     */\n    refresh() {\n        this.$svg.html(this.$svg.html());\n        console.log(\"SVG document has been reloaded.\")\n    }\n\n    /**\n     * Display the context menu on the specified position\n     * @param  {number} x       horizontal position in CSS pixels\n     * @param  {number} y       vertical position in CSS pixels\n     * @param  {jQuery.element} $target the item user clicked on (used to display \"remove this element\"-type items in the menu)\n     */\n    displayContextMenu(x, y, $target) {\n        this.contextMenu.display(x, y, $target);\n\n        // if tutorial exists, call tutorial callback\n        if(this.tutorial) {\n            this.tutorial.onContextMenuOpened();\n        }\n    }\n\n    /**\n     * hide the context menu\n     */\n    hideContextMenu() {\n        this.contextMenu.hide();\n    }\n\n    /**\n     * snap a value to a grid\n     * @param  {number} value value in SVG pixels\n     * @return {number}       the value rounded to the closest number divisible by the grid size\n     */\n    snapToGrid(value) {\n        return Math.round(value / this.gridSize) * this.gridSize;\n    }\n\n    /**\n     * convert grid pixels to SVG pixels\n     * @param  {number} value distance in grid pixels\n     * @return {number}       distance in SVG pixels\n     */\n    gridToSVG(value) {\n        return value * this.gridSize;\n    }\n\n    /**\n     * convert SVG pixels to grid pixels\n     * @param {number} value distance in SVG pixels\n     * @return {number}      distance in grud pixels\n     */\n    SVGToGrid(value) {\n        return value / this.gridSize;\n    }\n\n    /**\n     * static function for snapping a value to a grid\n     * @param  {number} value value in SVG pixels\n     * @param  {number} gridSize size of the grid in SVG pixels\n     * @return {number}       the value rounded to the closest number divisible by the grid size\n     */\n    static snapToGrid(value, gridSize) {\n        return Math.round(value / gridSize) * gridSize;\n    }\n\n    /**\n     * move an element to the front in the canvas\n     * @param  {string} objId id of the element\n     */\n    moveToFrontById(objId) {\n        this.$svg.append($(\"#\" + objId));\n    }\n\n    /**\n     * move an element to the back in the canvas\n     * @param  {string} objId id of the element\n     */\n    moveToBackById(objId) {\n        $(\"#\" + this.background.id)\n            .after($(\"#\" + objId));\n    }\n\n    /**\n     * get set of nodes, that cannot be used for wiring at any circumstances\n     * @return {Set} set of nodes (objects containing x and y coordinates) that are not suitable for wiring\n     */\n    getNonRoutableNodes() {\n        let blockedNodes = new Set();\n        // for each box\n        for(const box of this.boxes) {\n            const translate = box.getGridPixelTransform().getTranslate();\n\n            // for each item in blockedNodes (set of blocked nodes with coordinates relative\n            // to the left upper corner of rect; unit used is \"one gridSize\") convert the coordinates\n            // to absolute (multiple with gridSize and add position of rect) and add the result to the set\n            for(const node of box.blockedNodes) {\n                blockedNodes.add({\n                    x: translate.x + node.x,\n                    y: translate.y + node.y\n                });\n            }\n        }\n\n        // FOR DEBUG ONLY: display the non routable nodes\n        /*\n\n        if(this.nodeDisplay) {\n            for (const rectangleId of this.nodeDisplay) {\n                $(`#${rectangleId}`).remove();\n            }\n        }\n\n        this.nodeDisplay = [];\n\n        for (const node of blockedNodes) {\n            const x = this.gridToSVG(node.x);\n            const y = this.gridToSVG(node.y);\n\n            const w = 4;\n            const p = w / 2;\n\n            const nodeRectangle = new svgObj.Rectangle(x - p, y - p, w, w, \"red\", \"none\")\n            this.nodeDisplay.push(nodeRectangle.id);\n            this.appendElement(nodeRectangle, false);\n        }\n\n        this.refresh();\n\n        */\n        // END FOR DEBUG ONLY\n\n        // return the set\n        return blockedNodes;\n    }\n\n    /**\n     * get set of nodes, that are inconvenient for wiring, but can be used, just are not preferred\n     * @return {Set} set of nodes (objects containing x and y coordinates) that are not preferred for wiring\n     */\n    getInconvenientNodes(ignoreWireId) {\n        let inconvenientNodes = new Set();\n        // for each wire\n\n        for(const wire of this.wires) {\n            if(ignoreWireId===undefined || ignoreWireId!==wire.id) {\n                if(wire.inconvenientNodes) {\n                    for (const node of wire.inconvenientNodes) {\n                        inconvenientNodes.add(node);\n                    }\n                }\n            }\n        }\n\n        // FOR DEBUG ONLY: display the inconvenient nodes\n        /*\n\n        if(this.inconvenientNodeDisplay) {\n            for (const rectangleId of this.inconvenientNodeDisplay) {\n                $(`#${rectangleId}`).remove();\n            }\n        }\n\n        this.inconvenientNodeDisplay = [];\n\n        for (const node of inconvenientNodes) {\n            const x = this.gridToSVG(node.x);\n            const y = this.gridToSVG(node.y);\n\n            const w = 4;\n            const p = w / 2;\n\n            const nodeRectangle = new svgObj.Rectangle(x - p, y - p, w, w, \"orange\", \"none\")\n            this.inconvenientNodeDisplay.push(nodeRectangle.id);\n            this.appendElement(nodeRectangle, false);\n        }\n\n        this.refresh();\n\n        */\n        // END FOR DEBUG ONLY\n\n        // return the set\n        return inconvenientNodes;\n    }\n}\n","\"use strict\";\n\nimport {\n    getLibrary,\n    getNetworkFromLibrary\n} from './networkLibrary';\n\nimport {Gate} from './editorElements'\n\n/**\n * Item in the [ContextMenu](./module-ContextMenu.html). ContextMenuItems can be nested using the appendItem function.\n */\nclass ContextMenuItem {\n    /**\n     * @param {string} text          text on the button\n     * @param {ContextMenu} contextMenu instance of the [ContextMenu](./module-ContextMenu.html) this item belongs to\n     * @param {Function} clickFunction callback function that will be called when user clicks this item\n     */\n    constructor(text, contextMenu, clickFunction) {\n        /**\n         * text on the button\n         * @type {string}\n         */\n        this.text = text;\n\n        /**\n         * instance of the [ContextMenu](./module-ContextMenu.html) this item belongs to\n         * @type {ContextMenu}\n         */\n        this.contextMenu = contextMenu;\n\n        /**\n         * jQuery element representing DOM content of this menu item\n         * @type {jQuery.element}\n         */\n        this.$el = $(\"<li>\").text(text);\n\n        // set up click callback if clickFunction is defined\n        if(clickFunction!==undefined) {\n            $(this.$el).click(\n                (event) => {\n                    clickFunction();\n                    contextMenu.hide();\n\n                    event.stopPropagation();\n                }\n            );\n        }\n\n        /**\n         * jQuery element containing the submenu (or undefined, if item has no subitems)\n         * @type {jQuery.element}\n         */\n        this.$submenu = undefined\n\n        /**\n         * submenu item counter\n         * @type {Number}\n         */\n        this.itemCount = 0\n\n        // set hover callback\n        $(this.$el).hover((event) => {\n            // mouse on\n\n            if(this.length > 0) {\n                this.$submenu.css({\n                    display: \"block\",\n                    top: this.$el.offset().top,\n                    left: this.$el.parent().offset().left + this.$el.parent().width(),\n                })\n\n                this.contextMenu.$el.after(this.$submenu);\n\n                event.stopPropagation()\n            }\n        }, () => {\n            // mouse out\n            if(this.$submenu) {\n                this.$submenu.css({\n                    display: \"none\"\n                })\n            }\n\n            // do not stop event propagation, here it is wanted\n            // (because submenu overrides display: none when user moves from this menu item to the submenu)\n        })\n    }\n\n    /**\n     * instance of [Canvas](./module-Canvas.html) this menu belongs to\n     * @type {Canvas}\n     */\n    get parentSVG() {\n        return this.contextMenu.parentSVG;\n    }\n\n    /**\n     * number of items in the submenu\n     * @return {Number}\n     */\n    get length() {\n        return this.itemCount;\n    }\n\n    /**\n     * add a CSS class to this item\n     * @param {string} cls [description]\n     */\n    addClass(cls) {\n        this.$el.addClass(cls);\n        return this;\n    }\n\n    /**\n     * append a nested {@link ContextMenuItem} to this item\n     * @param  {ContextMenuItem} item item that will be appended\n     */\n    appendItem(item) {\n        if(!this.$submenu) {\n            this.$submenu = $(\"<ul>\").addClass(\"subList\");\n            this.$submenu.hover(() => {\n                this.$submenu.css(\"display\", \"block\");\n            }, () => {\n                this.$submenu.css(\"display\", \"none\");\n            })\n        }\n        this.$submenu.append(item.$el);\n\n        this.itemCount++;\n\n        return item;\n    }\n\n    /**\n     * get jQuery element of this menu item\n     * @return {jQuery.element} jQuery element containing all DOM content for this menu item\n     */\n    get jQuery() {\n        return this.$el;\n    }\n\n    get jQuerySubmenu() {\n        return this.$submenu;\n    }\n}\n\n/**\n * Menu item that has a custom click callback function that adds a {@link Gate} of the specified type to the [Canvas](./module-Canvas.html)\n * @extends ContextMenuItem\n */\nclass GateMenuItem extends ContextMenuItem {\n    /**\n     * @param {string} type        type of the gate {@link Gate} (and, or, ...)\n     * @param {ContextMenu} contextMenu instance of the [ContextMenu](./module-ContextMenu.html) that this item belongs to\n     */\n    constructor(type, contextMenu) {\n        super(\n            `${type.toUpperCase()} gate`,\n            contextMenu,\n            () => {\n                this.parentSVG.newGate(\n                    type,\n                    this.parentSVG.snapToGrid(this.parentSVG.viewbox.transformX(contextMenu.position.x)),\n                    this.parentSVG.snapToGrid(this.parentSVG.viewbox.transformY(contextMenu.position.y))\n                );\n            }\n        );\n    }\n}\n\n/**\n * Menu item that has a custom click callback function that adds a specified {@link Blackbox} to the [Canvas](./module-Canvas.html)\n * @extends ContextMenuItem\n */\nclass BlackboxMenuItem extends ContextMenuItem {\n    constructor(name, file, contextMenu) {\n        super(\n            name,\n            contextMenu,\n            () => {\n                getNetworkFromLibrary(file).then(({blackbox, name}) => {\n                    const {inputs, outputs, table} = blackbox;\n\n                    // use the name specified in the blackbox item, if it does not exist, use the name for the network\n                    let usedName = blackbox.name || name;\n\n                    this.parentSVG.newBlackbox(\n                        inputs,\n                        outputs,\n                        table,\n                        usedName,\n                        this.parentSVG.snapToGrid(this.parentSVG.viewbox.transformX(contextMenu.position.x)),\n                        this.parentSVG.snapToGrid(this.parentSVG.viewbox.transformY(contextMenu.position.y))\n                    );\n                }).catch(error => {\n                    console.error(error);\n                })\n            }\n        )\n    }\n}\n\nclass NetworkMenuItem extends ContextMenuItem {\n    constructor(name, file, contextMenu) {\n        super(\n            name,\n            contextMenu,\n            () => {\n                getNetworkFromLibrary(file).then(data => {\n                    this.parentSVG.importData(\n                        data,\n                        Math.round(this.parentSVG.viewbox.transformX(contextMenu.position.x) / this.parentSVG.gridSize),\n                        Math.round(this.parentSVG.viewbox.transformY(contextMenu.position.y) / this.parentSVG.gridSize)\n                    ).then(warnings => {\n                        for (const warning of warnings) {\n                            this.parentSVG.messages.newWarningMessage(warning)\n                        }\n                    })\n                }).catch(error => {\n                    this.parentSVG.messages.newErrorMessage(error);\n                })\n            }\n        )\n    }\n}\n\n/** @module ContextMenu */\n/**\n * ContextMenu represents the menu that is displayed to the user when they right click on a canvas.\n * This menu allows user to add elements to the Canvas and in the case that user rightclicked\n * on a specific element, this menu allows them to remove this element.\n */\nexport default class ContextMenu {\n    /**\n     * @param {Canvas} parentSVG instance of [Canvas](./module-Canvas.html) this menu belongs to\n     */\n    constructor(parentSVG) {\n        /**\n         * instance of [Canvas](./module-Canvas.html) this menu belongs to\n         * @type {Canvas}\n         */\n        this.parentSVG = parentSVG;\n\n        /**\n         * Position of the context menu. It is used to add the new elements to the correct position on the Canvas.\n         * @type {Object}\n         */\n        this.position = {\n            x: 0, y: 0\n        };\n\n        /**\n         * jQuery element containing the context menu\n         * @type {jQuery.element}\n         */\n        this.$el = $(\"<ul>\");\n        this.$el.attr('id', 'contextMenu');\n\n        let special = new ContextMenuItem(\"Special elements\", this);\n\n        // add input box\n        special.appendItem(\n            new ContextMenuItem(\"Input box\", this,\n                () => {\n                    let position = {\n                        left: this.parentSVG.snapToGrid(parentSVG.viewbox.transformX(this.position.x)),\n                        top: this.parentSVG.snapToGrid(parentSVG.viewbox.transformY(this.position.y))\n                    };\n\n                    parentSVG.newInput(position.left, position.top);\n                }\n            )\n        );\n\n        // add output box\n        special.appendItem(new ContextMenuItem(\"Output box\", this, () => {\n            let position = {\n                left: this.parentSVG.snapToGrid(parentSVG.viewbox.transformX(this.position.x)),\n                top: this.parentSVG.snapToGrid(parentSVG.viewbox.transformY(this.position.y))\n            };\n\n            parentSVG.newOutput(position.left, position.top);\n        }));\n\n        this.appendItem(special);\n\n        // list of gates that can be added\n        const gates = Gate.validGates;\n        let gateList = new ContextMenuItem(\"New gate\", this, parentSVG);\n        for (const name of gates) {\n            gateList.appendItem(\n                new GateMenuItem(name, this)\n            );\n        }\n        this.appendItem(gateList);\n\n        // more options will be added in the getLibrary() callback below\n        let networkList = new ContextMenuItem(\"Add a network\", this);\n        networkList.appendItem(new ContextMenuItem(\"Paste a network\", this, () => {\n            this.displayImportDialog()\n        }));\n        this.appendItem(networkList); // always append\n\n        let blackboxList = new ContextMenuItem(\"Add a blackbox\", this); // appends only if contains items (see the callback)\n\n        // network import (blackbox, network)\n        getLibrary().then(networks => {\n\n            for (const {name, file, hasTable, hasNetwork} of networks) {\n                // add a network as a blackbox\n                if(hasTable) {\n                    blackboxList.appendItem(\n                        new BlackboxMenuItem(name, file, this)\n                    );\n                }\n\n                // load a network as a network of components connected with wires\n                if(hasNetwork) {\n                    networkList.appendItem(\n                        new NetworkMenuItem(name, file, this)\n                    );\n                }\n            }\n\n            if(blackboxList.length > 0) {\n                this.appendItem(blackboxList);\n            }\n        }).catch(error => {\n            console.error(error);\n        })\n\n        // add conditional items for box and wire removal\n        this.appendConditionalItem('box', 'Remove this item', id => {this.parentSVG.removeBox(id)});\n        this.appendConditionalItem('wire', 'Remove this wire', id => {this.parentSVG.removeWireById(id)});\n\n        // add the context menu to the DOM\n        parentSVG.$svg.before(this.$el);\n\n        /**\n         * Number of items in this menu (used in the .lenght getter). Conditional items do not count.\n         * @type {Number}\n         */\n        this.itemCount = 0;\n    }\n\n    get length() {\n        return this.itemCount;\n    }\n\n    /**\n     * append a context menu item to the context menu\n     * @param  {ContextMenuItem} item instance of {@link ContextMenuItem} that will be added to this menu\n     */\n    appendItem(item) {\n        this.$el.append(item.jQuery);\n\n        this.itemCount++;\n\n        return item;\n    }\n\n    /**\n     * appends an connditional item (that is shown only if the target has the class itemClass)\n     * @param  {string} itemClass     show the item only if the target has this class\n     * @param  {string} text          text of this menu item\n     * @param  {Function} clickFunction function with one argument (ID of the target) that will be called on click\n     */\n    appendConditionalItem(itemClass, text, clickFunction) {\n        if(!this.conditionalItems) {\n            this.conditionalItems = [];\n        }\n\n        this.conditionalItems[this.conditionalItems.length] = {\n            itemClass: itemClass,\n            text: text,\n            clickFunction: clickFunction\n        }\n    }\n\n    /**\n     * display the dialog for importing a network from a clipboard\n     */\n    displayImportDialog() {\n        let $popup = $(\"<div>\")\n            .addClass(\"importExport\")\n            .addClass(\"import\");\n\n        let textareaId = \"importJSON\";\n        let $textblock = $(\"<textarea>\").attr('id', textareaId);\n\n        let lityInstance;\n\n        $popup.append(\n            $textblock\n        ).append(\n            $(\"<a>\").attr({\n                \"href\": \"#\",\n                \"class\": \"upload\"\n            })\n            .append(\n                $(\"<img>\").attr('src', \"img/gui/import.svg\")\n            )\n            .append(\" import from JSON\")\n            .on('click', () => {\n                let data;\n\n                try {\n                    data = JSON.parse($('#' + textareaId).val());\n                } catch(e) {\n                    this.parentSVG.messages.newErrorMessage(\"The imported file is not a valid JSON file.\");\n                    lityInstance.close();\n                }\n\n                if(data) {\n                    // proccess the imported data\n                    this.parentSVG.importData(\n                        data,\n                        Math.round(this.parentSVG.viewbox.transformX(this.position.x) / this.parentSVG.gridSize),\n                        Math.round(this.parentSVG.viewbox.transformY(this.position.y) / this.parentSVG.gridSize)\n                    ).then(warnings => {\n                        for (const warning of warnings) {\n                            this.parentSVG.messages.newWarningMessage(warning)\n                        }\n                    }).finally(() => {\n                        lityInstance.close();\n                    })\n                }\n            })\n        );\n\n        lityInstance = lity($popup);\n\n        // focus on the textblock\n        $textblock.focus();\n    }\n\n    /**\n     * decide whether or not to display specific conditional items\n     * @param  {jQuery.element} $target jQuery target of a MouseEvent (element that user clicked on)\n     */\n    resolveConditionalItems($target) {\n        for(let item of this.conditionalItems) {\n            if($target.hasClass(item.itemClass)) {\n                this.appendItem(\n                    new ContextMenuItem(\n                        item.text, this,\n                        () => {\n                            item.clickFunction($target.attr('id'));\n                        }\n                    )\n                ).addClass('conditional');\n            }\n        }\n    }\n\n    /**\n     * hide all conditional items\n     */\n    hideAllConditionalItems() {\n        this.$el.children('.conditional').remove();\n    }\n\n    /**\n     * displays the context menu with the right set of conditional items\n     * @param  {number} x       horizontal position of the context menu in CSS pixels\n     * @param  {number} y       vertical position of the context menu in CSS pixels\n     * @param  {jQuery.element} $target jQuery target of a MouseEvent (element that user clicked on)\n     */\n    display(x, y, $target) {\n        this.position = {\n            x: x,\n            y: y\n        };\n\n        this.resolveConditionalItems($target);\n\n        this.$el.css({\n            display: 'block',\n            top: y,\n            left: x\n        })\n        // set the width expicitly, or else the menu will widen when displaying a submenu\n        // 2 is to prevent a weird text wrap bug\n        .css('width', 'auto')\n        .css('width', this.$el.innerWidth() + 2);\n    }\n\n    /**\n     * hide the context menu\n     */\n    hide() {\n        this.$el.css({display: 'none'});\n        $(\".subList\").css({display: 'none'});\n        this.hideAllConditionalItems();\n    }\n}\n","import * as svgObj from './svgObjects'\nimport Logic from './logic'\nimport findPath from './findPath'\n\n\n/**\n * mapping of logical states to css classes\n * @type {Object}\n */\nconst stateClasses = {\n    on: \"stateOn\",\n    off: \"stateOff\",\n    unknown: \"stateUnknown\",\n    oscillating: \"stateOscillating\"\n};\n\n/**\n * Helper class used by {@link Transform}.\n *\n * Represents one single property of the transform argument, for example `translate(360 150)`\n * that may be a part of longer transform argument like `transform=\"translate(360 150) rotate(90 30 20)\"`\n */\nclass Property {\n    /**\n     * Initialize the Property object\n     * @param {string} [string] string in the property format `propertyname(list of space separated values)`\n     */\n    constructor(string) {\n        if(string!==undefined) {\n            this.name = string.replace(/^[ ]*([^(]+).*/, \"$1\");\n            this.args = string.replace(/^[^(]+\\((.*)\\)/, \"$1\").split(' ');\n        }\n    }\n\n    /**\n     * set or replace the name of this property\n     * @param {string} name new name for this property\n     */\n    setName(name) {\n        this.name = name;\n    }\n\n    /**\n     * set arguments of this property\n     * @param {array} args array of arguments\n     */\n    setArguments(args) {\n        this.args = args;\n    }\n\n    /**\n     * get string representation of the property\n     * @return {string} property in the property format `name(arg1 arg2)`\n     */\n    get() {\n        return this.name + \"(\" + this.args.join(\" \") + \")\";\n    }\n}\n\n/**\n * API for manipulating the transform argument used in SVG\n */\nexport class Transform {\n    /**\n     * Initialize the Transform object\n     * @param {string} [string] string in the format of the `transform` argument in SVG, for example `translate(360 150) rotate(90 30 20)`\n     */\n    constructor(string) {\n        /**\n         * array of {@link Property} instances\n         * @type {Array}\n         */\n        this.items = [];\n\n        if(string!==undefined) {\n            for (const item of string.split(\")\")) {\n                if(item) { // if not empty\n                    this.items.push(new Property(item + \")\"));\n                }\n            }\n        }\n    }\n\n    /**\n     * convert distances from SVG pixels to grid pixels\n     * @param  {Canvas} parentSVG instance of [Canvas](./module-Canvas.html)\n     */\n    toGridPixels(parentSVG) {\n        for (let item of this.items) {\n            if(item.name === \"translate\") {\n                item.args = [\n                    parentSVG.SVGToGrid(item.args[0]),\n                    parentSVG.SVGToGrid(item.args[1]),\n                ]\n            } else if(item.name === \"rotate\") {\n                item.args = [\n                    item.args[0],\n                    parentSVG.SVGToGrid(item.args[1]),\n                    parentSVG.SVGToGrid(item.args[2]),\n                ]\n            }\n        }\n    }\n\n    /**\n     * convert distances from grid pixels to SVG pixels\n     * @param  {Canvas} parentSVG instance of [Canvas](./module-Canvas.html)\n     */\n    toSVGPixels(parentSVG) {\n        for (let item of this.items) {\n            if(item.name === \"translate\") {\n                item.args = [\n                    parentSVG.gridToSVG(item.args[0]),\n                    parentSVG.gridToSVG(item.args[1]),\n                ]\n            } else if(item.name === \"rotate\") {\n                item.args = [\n                    item.args[0],\n                    parentSVG.gridToSVG(item.args[1]),\n                    parentSVG.gridToSVG(item.args[2]),\n                ]\n            }\n        }\n    }\n\n    /**\n     * find a transform property by name and get its index in the [items](#items) array\n     * @param  {string} name name of the property\n     * @return {number}      index of the property in the array of properties or `-1` if not found\n     */\n    getIndex(name) {\n        for(let i = 0 ; i < this.items.length; i++) {\n            if(name === this.items[i].name) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * get the translate property\n     * @return {Object} object containing parameters of the translate attribute\n     */\n    getTranslate() {\n        let args = this.getArguments(this.getIndex(\"translate\"));\n\n        return {\n            x: Number(args[0]),\n            y: Number(args[1])\n        }\n    }\n\n    /**\n     * get the rotate property\n     * @return {Object} object containing parameters of the rotate attribute\n     */\n    getRotate() {\n        let args = this.getArguments(this.getIndex(\"rotate\"));\n\n        return {\n            deg: Number(args[0]),\n            centreX: Number(args[1]),\n            centreY: Number(args[2])\n        }\n    }\n\n    /**\n     * set translate to the specified values\n     * @param {number} x horizontal translation\n     * @param {number} y vertical translation\n     */\n    setTranslate(x, y) {\n        this.setParameter(\"translate\", [x, y]);\n    }\n\n    /**\n     * set rotate to the specified values\n     * @param {number} deg     angle of the rotation in degrees\n     * @param {number} centreX horizontal position of the centre of the rotation\n     * @param {number} centreY vertical position of the centre of the rotation\n     */\n    setRotate(deg, centreX, centreY) {\n        this.setParameter(\"rotate\", [deg, centreX, centreY]);\n    }\n\n    /**\n     * rotate by 90 degrees to the right or left, depending on the parameter `right`\n     * @param {number} centreX horizontal position of the centre of the rotation\n     * @param {number} centreY vertical position of the centre of the rotation\n     * @param {boolean} right rotate to the right if `true`, to the left if `false`\n     */\n    rotateRightAngle(centreX, centreY, right) {\n        const amount = right ? 90 : 270;\n\n        if(this.getIndex(\"rotate\")===-1) {\n            this.setRotate(amount, centreX, centreY);\n        } else {\n            let newRotation = (parseInt(this.getRotate().deg) + amount) % 360;\n\n            if(newRotation===180) {\n                // swap centre coordinates\n                // because rotate(c, x, y) is defined like transform(-x, -y) rotate(c) transform(x, y)\n                let a = centreX;\n                centreX = centreY;\n                centreY = a;\n            }\n\n            this.setRotate(\n                newRotation,\n                centreX,\n                centreY\n            );\n        }\n    }\n\n    /**\n     * rotate by 90 degrees to the right\n     * @param  {number} centreX horizontal position of the centre of the rotation\n     * @param  {number} centreY vertical position of the centre of the rotation\n     */\n    rotateRight(centreX, centreY) {\n        this.rotateRightAngle(centreX, centreY, true);\n    }\n\n    /**\n     * rotate by 90 degrees to the left\n     * @param  {number} centreX horizontal position of the centre of the rotation\n     * @param  {number} centreY vertical position of the centre of the rotation\n     */\n    rotateLeft(centreX, centreY) {\n        this.rotateRightAngle(centreX, centreY, false);\n    }\n\n    /**\n     * get the transform values in a string\n     * @return {string} string that can be used as a value for the transform property of a SVG element\n     */\n    get() {\n        let retVal;\n        for(const item of this.items) {\n            if(retVal) {\n                retVal += \" \" + item.get();\n            } else {\n                retVal = item.get();\n            }\n        }\n        return retVal;\n    }\n\n    /**\n     * get arguments of a property specified by index\n     * @param  {number} index index of the property\n     * @return {array}       array of arguments of the specified property\n     */\n    getArguments(index) {\n        return this.items[index].args;\n    }\n\n    /**\n     * set argumets of a property specified by name\n     * @param {string} name name of the property\n     * @param {array} args array of arguments of the specified property\n     */\n    setParameter(name, args) {\n        // determine index of the parameter (if set), else index == -1\n        let index = this.getIndex(name);\n\n        // if the property has been already set, change it (rewrite the array in the right index)\n        // else create a new one (set index to the length of an array --> ad an item to the end)\n        if(index===-1) {\n            index = this.items.length;\n            this.items[index] = new Property();\n            this.items[index].setName(name);\n        }\n\n        // save args under the right index\n        this.items[index].setArguments(args);\n    }\n}\n\n/**\n * parent class for all network elements\n */\nclass NetworkElement {\n    /**\n     * Basic constructor for NetworkElement\n     * @param {Canvas} parentSVG reference to the instance of {@link Canvas} that this element belongs to\n     */\n    constructor(parentSVG) {\n        if(!parentSVG) {\n            console.error(\"Parent SVG element has to be defined.\");\n        }\n        this.parentSVG = parentSVG;\n\n        // used to store the svjObject's instance of this element\n        this.svgObj = undefined;\n    }\n\n    /**\n     * Get the unique ID of the SVG element tied to this logical element\n     * @return {string} ID of the SVG element\n     */\n    get id() {\n        return this.svgObj.id;\n    }\n\n    /**\n     * empty callback function to prevent error messages, function is implemented later in the {@link Box} class\n     */\n    onMouseDown() {}\n\n    /**\n     * empty function to prevent error messages, function is implemented later in the {@link Box} and {@link Connector} classes\n     */\n    onMouseUp() {}\n\n    /**\n     * empty function to prevent error messages, function is implemented later in the {@link Box} class\n     */\n    onMouseMove() {}\n\n    /**\n     * \"virtual\" getter for json data, prints an error that it has to be redefined in the derived classes\n     */\n    get exportData() {\n        console.error(\"'json' getter has not been defined for this element\", this);\n        return undefined;\n    }\n}\n\n/**\n * parent class for input and output connectors\n * @extends NetworkElement\n */\nclass Connector extends NetworkElement {\n    /**\n     * @param {Canvas} parentSVG link to the {@link Canvas} instance that this connector will belong to\n     * @param {number} gridSize  size of the grid in SVG pixels\n     * @param {number} left      horizontal position defined in grid units (SVG pixels divided by the grid size)\n     * @param {number} top       vertical position defined in grid units (SVG pixels divided by the grid size)\n     */\n    constructor(parentSVG, left, top) {\n        super(parentSVG);\n\n        /**\n         * size of the grid in SVG pixels\n         * @type {number}\n         */\n        this.gridSize = parentSVG.gridSize;\n        /**\n         * size of the connector in SVG pixels\n         * @type {number}\n         */\n        this.connectorSize = parentSVG.gridSize;\n        /**\n         * offset of the connector from the grid in SVG pixels\n         * @type {number}\n         */\n        this.connectorOffset = this.connectorSize / 2;\n\n        /**\n         * instance of {@link svgObjects.svgObj} that holds all SVG information about this connector\n         * @type {svgObj}\n         */\n        this.svgObj = new svgObj.Rectangle(\n            left * this.gridSize - this.connectorOffset,\n            top * this.gridSize - this.connectorOffset,\n            this.connectorSize,\n            this.connectorSize,\n            \"none\",\n            \"black\"\n        );\n\n        this.svgObj.$el.addClass(\"connector\");\n\n        /**\n         * this flag describes whether this connector is an input connector\n         * @type {Boolean}\n         */\n        this.isInputConnector = false;\n\n        /**\n         * current logical state of this connector\n         * @type {Logic.state}\n         */\n        this.elementState = Logic.state.unknown;\n        this.svgObj.addClass(stateClasses.unknown);\n\n        /**\n         * set of ids of all wires connected to this connector\n         * @type {Set}\n         */\n        this.wireIds = new Set();\n    }\n\n    /**\n     * whether this connector is an output connector\n     * @return {Boolean}\n     */\n    get isOutputConnector() {\n        return !this.isInputConnector;\n    }\n\n    /**\n     * whether this connector is an output connector\n     * @return {Boolean}\n     */\n    set isOutputConnector(value) {\n        this.isInputConnector = !value;\n    }\n\n    /**\n     * add a wire id to the list of wire ids\n     * @param {string} wireId\n     */\n    addWireId(wireId) {\n        this.wireIds.add(wireId);\n    }\n\n    /**\n     * remove a wire id from the list of wire ids\n     * @param {string} wireId\n     */\n    removeWireId(wireId) {\n        this.wireIds.delete(wireId);\n    }\n\n    /**\n     * remove a wire specified by ID and update the connector\n     * @param  {string} wireId ID of the wire to be removed\n     */\n    removeWireIdAndUpdate(wireId) {\n        this.removeWireId(wireId);\n    }\n\n    /**\n     * set logical state of the connector\n     * @param {Logic.state} state new state of the connector\n     */\n    setState(state) {\n        this.svgObj.removeClasses(stateClasses.on, stateClasses.off, stateClasses.unknown, stateClasses.oscillating);\n\n        switch (state) {\n            case Logic.state.unknown:\n                this.svgObj.addClass(stateClasses.unknown);\n                break;\n            case Logic.state.on:\n                this.svgObj.addClass(stateClasses.on);\n                break;\n            case Logic.state.off:\n                this.svgObj.addClass(stateClasses.off);\n                break;\n            case Logic.state.oscillating:\n                this.svgObj.addClass(stateClasses.oscillating);\n                break;\n        }\n\n        this.elementState = state;\n    }\n\n    /**\n     * get state of this connector\n     * @return {Logic.state}\n     */\n    get state() {\n        return this.elementState;\n    }\n\n    /**\n     * get svgObj instance content of this connector\n     * @return {svgObjects.Rectangle}\n     */\n    get() {\n        return this.svgObj;\n    }\n\n    /**\n     * call [wireCreationHelper](./module-Canvas.html#wireCreationHelper) on mouse up\n     */\n    onMouseUp() {\n        this.parentSVG.wireCreationHelper(this.svgObj.id);\n    }\n}\n\n/**\n * Connector that gets its state from a connected value and passes it through to the {@link Box} this connector belongs to.\n * @extends Connector\n */\nexport class InputConnector extends Connector {\n    /**\n     * Call the constructor from the parent {@link Connector} class and set isInputConnector to true.\n     * @param {Canvas} parentSVG link to the {@link Canvas} instance that this connector will belong to\n     * @param {number} left      horizontal position defined in grid units (SVG pixels divided by the grid size)\n     * @param {number} top       vertical position defined in grid units (SVG pixels divided by the grid size)\n     */\n    constructor(parentSVG, left, top) {\n        super(parentSVG, left, top);\n\n        this.isInputConnector = true;\n    }\n\n    /**\n     * Call the setState method of {@link Connector} and than refresh the state of the connected {@link Box}\n     * @param {Logic.state} state new {@link Logic.state} of the connector\n     */\n    setState(state) {\n        super.setState(state);\n\n        let gate = this.parentSVG.getBoxByConnectorId(this.svgObj.id);\n        gate.refreshState();\n    }\n\n    /**\n     * remove the wire (by calling the removeWireIdAndUpdate of {@link Connector})\n     * and update state of this connector by setting it to undefined using the setState method\n     * @param  {string} wireId ID of the {@link Wire}\n     */\n    removeWireIdAndUpdate(wireId) {\n        super.removeWireIdAndUpdate(wireId);\n        this.setState(Logic.state.unknown);\n    }\n}\n\n/**\n * Connector that takes a state defined by the {@link Box} it belongs to and passes it to all connected wire\n * @extends Connector\n */\nexport class OutputConnector extends Connector {\n    /**\n     * Call the constructor from the parent {@link Connector} class and set isOutputConnector to true.\n     * @param {Canvas} parentSVG link to the {@link Canvas} instance that this connector will belong to\n     * @param {number} left      horizontal position defined in grid units (SVG pixels divided by the grid size)\n     * @param {number} top       vertical position defined in grid units (SVG pixels divided by the grid size)\n     */\n    constructor(parentSVG, left, top) {\n        super(parentSVG, left, top);\n\n        this.isOutputConnector = true;\n    }\n\n    /**\n     * Call the setState method of {@link Connector} and than set the state of the connected {@link Wire}s\n     * @param {Logic.state} state new {@link Logic.state} of the connector\n     */\n    setState(state) {\n        super.setState(state);\n\n        for (const wireId of this.wireIds) {\n            this.parentSVG.getWireById(wireId).setState(state);\n        }\n    }\n}\n\n/**\n * Parent class for gates and input and output boxes. Defines all the factors\n * that the boxes have in common (svgObj structure, draggability and rotatability...)\n * @extends NetworkElement\n */\nclass Box extends NetworkElement {\n    /**\n     * @param {Canvas} parentSVG  instance of [Canvas](./module-Canvas.html)\n     * @param {string} name       name of the element (input, output, and, or, xor...)\n     * @param {string} category   type of the element (io, gate)\n     * @param {number} gridWidth  width of the element in grid pixels\n     * @param {number} gridHeight height of the element in grid pixels\n     */\n    constructor(parentSVG, name, category, gridWidth, gridHeight) {\n        super(parentSVG);\n\n        /**\n         * specifies the box type within the category (input/output in io, and/or/... in gate)\n         * @type {string}\n         */\n        this.name = name;\n\n        /**\n         * specifies the box category (io for input or output, gate for logic gates)\n         * @type {string}\n         */\n        this.category = category;\n\n        /**\n         * size of the grid in SVG pixels\n         * @type {number}\n         */\n        this.gridSize = this.parentSVG.gridSize;\n\n        /**\n         * array of connectors of this box\n         * @type {Array}\n         */\n        this.connectors = [];\n\n        /**\n         * svgObj containing all SVG data used to display this box\n         * @type {svgObj}\n         */\n        this.svgObj = new svgObj.Group();\n\n        /**\n         * width of this element in SVG pixels\n         * @type {number}\n         */\n        this.width = gridWidth * this.gridSize;\n        /**\n         * height of this element in SVG pixels\n         * @type {number}\n         */\n        this.height = gridHeight * this.gridSize;\n\n        /**\n         * width of this element in grid pixels\n         * @type {number}\n         */\n        this.gridWidth = gridWidth;\n        /**\n         * height of this element in grid pixels\n         * @type {number}\n         */\n        this.gridHeight = gridHeight;\n\n        // transparent background rectangle\n        let rectangle = new svgObj.Rectangle(0, 0, this.width, this.height, \"none\", \"none\");\n        rectangle.$el.addClass('rect');\n\n        this.svgObj.addChild(rectangle);\n\n        // image of the element\n        this.image = new svgObj.SvgImage(0, 0, this.width, this.height, this.url);\n        this.svgObj.addChild(this.image);\n\n        // add type=\"gate\", used in special callbacks in contextmenu\n        this.svgObj.addAttr({\"type\": category});\n\n        this.svgObj.$el.addClass(\"box\");\n        this.svgObj.$el.addClass(category);\n    }\n\n    /**\n     * url of the image depicting this object\n     * @type {string}\n     */\n    get url() {\n        const\n            category = this.category || \"\",\n            name = this.name || \"\",\n            suffix = this.imgSuffix || \"\";\n\n        return `img/svg/${category}/${name}${suffix}.svg`;\n    }\n\n    /**\n     * get all input connectors of this box\n     * @return {Array} array of input connectors\n     */\n    get inputConnectors() {\n        return this.connectors.filter(conn => conn.isInputConnector)\n    }\n\n    /**\n     * get all output connectors of this box\n     * @return {Array} array of output connectors\n     */\n    get outputConnectors() {\n        return this.connectors.filter(conn => conn.isOutputConnector)\n    }\n\n    /**\n     * get data of this box as a JSON-ready object\n     * @return {Object} javascript object containing essential data for this box\n     */\n    get exportData() {\n        let connections = [];\n\n        // go through all connectors\n        let counter = 0\n        for (const conn of this.connectors) {\n            // go through each its wire id\n            for (const item of conn.wireIds) {\n                let thisWireId;\n                if(!this.parentSVG.exportWireIdMap.has(item)) {\n                    // if the wire id is not in the map, add it and assign new arbitrary id\n                    this.parentSVG.exportWireIdMap.set(item, this.parentSVG.exportWireId);\n                    thisWireId = this.parentSVG.exportWireId;\n                    this.parentSVG.exportWireId++;\n                } else {\n                    // else get id from the map\n                    thisWireId = this.parentSVG.exportWireIdMap.get(item);\n                }\n\n\n                // add this connection to the list\n                connections[connections.length] = {\n                    index: counter,\n                    type: conn.type,\n                    wireId: thisWireId\n                };\n            }\n            counter++\n        }\n\n        return {\n            name: this.name,\n            category: this.category,\n            transform: this.getTransform(true),\n            connections: connections\n        };\n    }\n\n    /**\n     * get set of nodes that are not suitable for wire routing\n     * @param  {Number} [marginTop=0]    top margin of the element (distance from the element that should be also blocked)\n     * @param  {Number} [marginRight=0]  right margin of the element\n     * @param  {Number} [marginBottom=0] bottom margin of the element\n     * @param  {Number} [marginLeft=0]   left margin of the element\n     * @param  {Number} specialNodes     additional nodes that should be added to the set\n     * @return {Set}                     set of not suitable nodes\n     */\n    generateBlockNodes(marginTop = 0, marginRight = 0, marginBottom = 0, marginLeft = 0, ...specialNodes) {\n        this.blockedNodes = new Set();\n        for(let x = marginLeft ; x <= this.gridWidth - marginRight ; x++) {\n            for(let y = marginTop ; y <= this.gridHeight - marginBottom ; y++) {\n                this.blockedNodes.add({\n                    x: x,\n                    y: y\n                });\n            }\n        }\n\n        for (let node of specialNodes) {\n            this.blockedNodes.add(node);\n        }\n    }\n\n    /**\n     * empty function, redefined in inherited elements\n     * refreshState takes input connector values and sets output values accordingly\n     */\n    refreshState() {\n        console.warn(\"Calling the virtual function refreshState has no effect.\");\n    }\n\n    /**\n     * change image to another one that ends with a specified suffix\n     *\n     * *usage:* `changeImage(\"abc\")` changes image url to `image-abc.svg`,\n     * `changeImage()` changes image url to the default one (`image.svg`)\n     * @param  {string} [suffix] new suffix for the image\n     */\n    changeImage(suffix) {\n        if(suffix === undefined || suffix === \"\") {\n            this.imgSuffix = \"\";\n        } else {\n            this.imgSuffix = \"-\" + suffix;\n        }\n\n        this.image.changeUrl(this.url);\n    }\n\n    /**\n     * get a jQuery element representing this box\n     * @return {jQuery.element}\n     */\n    get() {\n        return this.svgObj.get();\n    }\n\n    /**\n     * rotate the set of blocked nodes by 90 degrees to the right or to the left, depending on the parameter\n     *\n     * used to rotate the nodes when the object itself is rotated\n     * @param  {boolean} right rotate clockwise if true, counterclockwise if false\n     */\n    rotateBlockedNodes(right) {\n        if(this.rotationParity===undefined) {\n            this.rotationParity = false;\n        }\n\n        this.rotationParity = !this.rotationParity;\n\n        let newBlockedNodes = new Set();\n\n        // rotate the node\n\n        for (const node of this.blockedNodes) {\n            let newNode;\n\n            if(this.rotationParity) {\n                if(right) {\n                    newNode = {\n                        x: Math.abs(node.y - this.gridHeight),\n                        y: node.x\n                    };\n                } else {\n                    newNode = {\n                        x: node.y,\n                        y: Math.abs(node.x - this.gridWidth)\n                    };\n                }\n            } else {\n                if(right) {\n                    newNode = {\n                        x: Math.abs(node.y - this.gridWidth),\n                        y: node.x\n                    };\n                } else {\n                    newNode = {\n                        x: node.y,\n                        y: Math.abs(node.x - this.gridHeight)\n                    };\n                }\n            }\n\n            newBlockedNodes.add(newNode);\n        }\n\n        this.blockedNodes = newBlockedNodes;\n    }\n\n    /**\n     * rotate the set of blocked nodes to the right\n     *\n     * used to rotate the nodes when the object itself is rotated\n     */\n    rotateBlockedNodesRight() {\n        this.rotateBlockedNodes(true);\n    }\n\n    /**\n     * rotate the set of blocked nodes to the right\n     *\n     * used to rotate the nodes when the object itself is rotated\n     */\n    rotateBlockedNodesLeft() {\n        this.rotateBlockedNodes(false);\n    }\n\n    /**\n     * add a connector to the element on the specified position\n     * @param {number}  left             horizontal distance from the left edge of the element\n     * @param {number}  top              vertical distance from the top edge of the element\n     * @param {Boolean} isInputConnector whether or not should this connector an input connector (`true` for input connector, `false` for output connector)\n     */\n    addConnector(left, top, isInputConnector) {\n        let index = this.connectors.length;\n        if(isInputConnector) {\n            this.connectors[index] = new InputConnector(this.parentSVG, left, top);\n        } else {\n            this.connectors[index] = new OutputConnector(this.parentSVG, left, top);\n        }\n        this.svgObj.addChild(this.connectors[index].get());\n    }\n\n    /**\n     * add an input connector to the element on the specified position\n     * @param {number} left horizontal distance from the left edge of the element\n     * @param {number} top  vertical distance from the top edge of the element\n     */\n    addInputConnector(left, top) {\n        return this.addConnector(left, top, true)\n    }\n\n    /**\n     * add an output connector to the element on the specified position\n     * @param {number} left horizontal distance from the left edge of the element\n     * @param {number} top  vertical distance from the top edge of the element\n     */\n    addOutputConnector(left, top) {\n        return this.addConnector(left, top, false)\n    }\n\n    /**\n     * get the connector object based on its id\n     * @param  {string} connectorId ID of the {@link Connector}\n     * @return {Connector}             instance of the {@link Connector} or `undefined` if not found\n     */\n    getConnectorById(connectorId) {\n        for(let i = 0 ; i < this.connectors.length ; i++) {\n            if(this.connectors[i].id===connectorId) {\n                return this.connectors[i];\n            }\n        }\n        // if connector not found, return undefined\n        return undefined;\n    }\n\n    /**\n     * get the instance of {@link Transform} representing the state of the transform attribute of this element\n     * @param  {Boolean} [gridPixels=false] if `true`, function will return the result in grid pixels instead of SVG pixels\n     * @return {Transform}                  {@link Transform} of the element\n     */\n    getTransform(gridPixels = false) {\n        let transform;\n        if (!this.svgObj.$el.attr(\"transform\")) {\n            // the element does not have a \"transform\" property --> create it\n            transform = new Transform();\n            transform.setTranslate(0, 0);\n            this.svgObj.addAttr({\"transform\": transform.get()});\n        } else {\n            // the element does have a \"transform\" property --> change it\n            transform = new Transform(this.svgObj.$el.attr(\"transform\"));\n        }\n\n        // convert values to grid pixels\n        if(gridPixels) {\n            transform.toGridPixels(this.parentSVG);\n        }\n\n        return transform;\n    }\n\n    /**\n     * get the instance of {@link Transform} representing the state of the transform attribute of this element _with lenght units in grid pixels_\n     * @return {Transform} {@link Transform} of the element\n     */\n    getGridPixelTransform() {\n        return this.getTransform(true);\n    }\n\n    /**\n     * set the transform attribute of this element\n     * @param {Transform} transform {@link Transform} of the element (with lengths specified in SVG pixels)\n     */\n    setTransform(transform) {\n        this.svgObj.addAttr({\"transform\": transform.get()});\n    }\n\n    /**\n     * function that is called on every mouse down on this element\n     *\n     * moves the element to the front and calls onMouseDownLeft if applicable\n     * @param  {jQuery.MouseEvent} event\n     */\n    onMouseDown(event) {\n        this.mouseLeft = false;\n        if(event.which === 1) {\n            this.mouseLeft = true;\n            this.onMouseDownLeft(event);\n\n            // move the DOM element to front\n            this.parentSVG.moveToFrontById(this.svgObj.id);\n        }\n    }\n\n    /**\n     * function that is called on every left mouse down on this element\n     *\n     * prepares element for the \"click\" and \"drag and drop\" actions\n     * @param  {jQuery.MouseEvent} event\n     */\n    onMouseDownLeft(event) {\n        this.mouseMoved = false;\n\n        let transform = this.getTransform();\n\n        // save the current item position into a variable\n        let currentPosition = transform.getTranslate();\n\n        let {pageX, pageY} = this.parentSVG.viewbox.transformEvent(event)\n\n        // calculate mouse offset from the object origin\n        this.offset = {\n            x: pageX - currentPosition.x,\n            y: pageY - currentPosition.y\n        };\n    }\n\n    /**\n     * function that is called on every left mouse move with this element\n     * applies the correct transform values to provide the \"drag and drop\" functionality\n     * @param  {jQuery.MouseEvent} event\n     */\n    onMouseMove(event) {\n        if(this.mouseLeft) {\n            this.svgObj.$el.addClass('grabbed');\n\n            this.mouseMoved = true;\n\n            let {pageX, pageY} = this.parentSVG.viewbox.transformEvent(event)\n\n            const left = pageX - this.offset.x;\n            const top = pageY - this.offset.y;\n\n            let transform = this.getTransform();\n            transform.setTranslate(left, top);\n\n            this.setTransform(transform);\n\n            this.updateWires(true);\n        }\n    }\n\n    /**\n     * function that is called on every mouse up on this element\n     * provides the \"click\" functionality and calls the onDrop handler for the \"drag and drop\" functionality\n     * @param  {jQuery.MouseEvent} event\n     */\n    onMouseUp(event) {\n        if(event.which === 1) {\n            if(this.mouseMoved) {\n                this.onDrop(event);\n            } else {\n                this.onClick();\n            }\n        } else if (event.which === 2 ) {\n            this.onClickMiddle(event);\n        }\n\n        this.svgObj.$el.removeClass('grabbed');\n    }\n\n    /**\n     * called by onMouseUp when the mouse has been moved between onMouseDown and onMouseUp\n     *\n     * applies grid snapping of the element on the end of the \"drag and drop\" action\n     * @param  {jQuery.MouseEvent} event\n     */\n    onDrop(event) {\n        let {pageX, pageY} = this.parentSVG.viewbox.transformEvent(event)\n\n        let left = pageX - this.offset.x;\n        let top = pageY - this.offset.y;\n\n        left = this.parentSVG.snapToGrid(left);\n        top = this.parentSVG.snapToGrid(top);\n\n        let transform = this.getTransform();\n        transform.setTranslate(left, top);\n\n        this.setTransform(transform);\n\n        this.updateWires();\n\n        // if tutorial exists, call tutorial callback\n        if(this.parentSVG.tutorial) {\n            this.parentSVG.tutorial.onBoxMoved();\n        }\n    }\n\n    /**\n     * empty function, will be redefined in InputBox\n     */\n    onClick() {}\n\n    /**\n     * custom callback function for middle click that rotates the box by 90 degrees to the right\n     */\n    onClickMiddle(event) {\n        // get the transform value for this box\n        let transform = this.getTransform();\n\n        // get the bounding rectangle for this box\n        let rect = this.svgObj.$el[0].getBoundingClientRect();\n\n        // use the bounding rectangle dimensions to figure out the geometrical centre of the box\n        let centreX = Math.round(rect.width / 2);\n        let centreY = Math.round(rect.height / 2);\n\n        centreX -= centreX % this.gridSize;\n        centreY -= centreY % this.gridSize;\n\n        // apply the rotation to the transform object\n        if(event.ctrlKey) {\n            transform.rotateLeft(centreX, centreY);\n        } else {\n            transform.rotateRight(centreX, centreY);\n        }\n\n\n        // apply the modified transform object ot the svgObj\n        this.svgObj.addAttr({\"transform\": transform.get()});\n\n        // rotate also the blocked nodes\n        if(event.ctrlKey) {\n            this.rotateBlockedNodesLeft();\n        } else {\n            this.rotateBlockedNodesRight();\n        }\n\n        // update the wires\n        this.updateWires();\n\n        // if tutorial exists, call tutorial callback\n        if(this.parentSVG.tutorial) {\n            this.parentSVG.tutorial.onBoxRotated();\n        }\n    }\n\n    /**\n     * Updates all wires connected to this box. Iterates over all wires that are connected to this box\n     * and calls routeWire (or temporaryWire if the `temporary` parameter is set to true) to update the wire routing\n     * @param  {Boolean} [temporary=false] [description]\n     */\n    updateWires(temporary = false) {\n        this.connectors.forEach(conn => {\n            conn.wireIds.forEach(wireId => {\n                let wire = this.parentSVG.getWireById(wireId);\n                if(temporary) {\n                    wire.temporaryWire();\n                } else {\n                    wire.routeWire();\n                }\n            })\n        })\n    }\n}\n\n/**\n * InputBox has only output connectors and is used to set the input states for the logic network.\n * @extends Box\n */\nexport class InputBox extends Box {\n    /**\n     * @param {Canvas} parentSVG  instance of [Canvas](./module-Canvas.html)\n     * @param {Boolean} [isOn=false] the initial state of the inputbox (`true` is *on*, `false` is *off*)\n     */\n    constructor(parentSVG, isOn = false) {\n        const gridWidth = 7;\n        const gridHeight = 4;\n\n        super(parentSVG, \"input\", \"other\", gridWidth, gridHeight);\n\n        this.addConnector(gridWidth, gridHeight / 2, false);\n\n        this.on = isOn;\n\n        this.generateBlockNodes();\n    }\n\n    /**\n     * get data of this input box as a JSON-ready object\n     * @return {Object} javascript object containing essential data for this input box\n     */\n    get exportData() {\n        let data = super.exportData;\n        data.isOn = this.isOn;\n\n        return data;\n    }\n\n    generateBlockNodes() {\n        // block the input connector node\n        const specialNode = {\n            x: this.gridWidth,\n            y: this.gridHeight / 2\n        }\n        super.generateBlockNodes(0, 1, 1, 0, specialNode);\n    }\n\n    /**\n     * start a new simulation from the output connector\n     */\n    refreshState() {\n        this.parentSVG.startNewSimulation(this.connectors[0], this.connectors[0].state)\n    }\n\n    /**\n     * set the state of the inputbox to the corresponding value\n     * @param  {Boolean} isOn set to *on* if `true`, set to *off* if `false`\n     */\n    set on(isOn) {\n        if (isOn) {\n            // turn on\n            this.changeImage(\"on\");\n            this.connectors[0].setState(Logic.state.on);\n            this.refreshState()\n        } else {\n            // turn off\n            this.changeImage();\n            this.connectors[0].setState(Logic.state.off);\n            this.refreshState()\n        }\n\n        this.isOn = isOn;\n    }\n\n    /**\n     * get the state of the inputbox (`true` if *on*, `false` if *off*)\n     * @return {Boolean} [description]\n     */\n    get on() {\n        return this.isOn;\n    }\n\n    /**\n     * toggle the state of the inputbox\n     */\n    onClick() {\n        this.on = !this.on;\n\n        if(this.parentSVG.tutorial) {\n            this.parentSVG.tutorial.onChangeInputBoxState();\n        }\n    }\n}\n\n/**\n * OutputBox has only input connectors and is used to visualize the output states of the logic network.\n * @extends Box\n */\nexport class OutputBox extends Box {\n    /**\n     * @param {Canvas} parentSVG  instance of [Canvas](./module-Canvas.html)\n     */\n    constructor(parentSVG) {\n        const gridHeight = 4;\n        const gridWidth = 5;\n\n        super(parentSVG, \"output\", \"other\", gridWidth, gridHeight);\n\n        this.addConnector(0, gridHeight / 2, true);\n\n        this.generateBlockNodes();\n    }\n\n    /**\n     * set state of this output box to match the state of its input connector\n     */\n    refreshState() {\n        this.setState(this.connectors[0].state);\n    }\n\n    /**\n     * Reflect the input connector state in the appearance of the element - set\n     * the element image to represent the corresponding state\n     * @param {Logic.state} state new state of this outputBox\n     */\n    setState(state) {\n        switch (state) {\n            case Logic.state.on:\n                this.changeImage(\"on\");\n\n                // if tutorial exists, call tutorial callback\n                if(this.parentSVG.tutorial) {\n                    this.parentSVG.tutorial.onOutputBoxTrue();\n                }\n                break;\n            case Logic.state.off:\n                this.changeImage(\"off\");\n                break;\n            case Logic.state.unknown:\n                this.changeImage();\n                break;\n            case Logic.state.oscillating:\n                this.changeImage(\"osc\");\n                break;\n        }\n    }\n\n    generateBlockNodes() {\n        // block the input connector node\n        const specialNode = {\n            x: 0,\n            y: this.gridHeight / 2\n        }\n        super.generateBlockNodes(0, 0, 0, 1, specialNode);\n    }\n}\n\n/**\n * Gate is a box that processes the states of its input connectors and returns the result in its output connectors.\n * @extends Box\n */\nexport class Gate extends Box {\n    /**\n     * @param {Canvas} parentSVG  instance of [Canvas](./module-Canvas.html)\n     * @param {string} name       name of the gate (and, not, xor...)\n     */\n    constructor(parentSVG, name) {\n        const width = 9;\n        const height = 4;\n\n        super(parentSVG, name, \"gate\", width, height);\n\n        // ADD CONNECTORS\n\n        let specialNodes = [];\n\n        // output\n        this.addConnector(width, height / 2, false);\n\n        // block the output connector\n        specialNodes.push({\n            x: width,\n            y: height / 2\n        });\n\n        if(this.name===\"not\" || this.name===\"repeater\") {\n            // input\n            this.addConnector(0, height / 2, true);\n            // block the input connector\n            specialNodes.push({\n                x: 0,\n                y: height / 2\n            });\n        } else {\n            // input\n            this.addConnector(0, height / 4, true);\n            this.addConnector(0, height / (4/3), true);\n\n            // block the input connectors\n            specialNodes.push({\n                x: 0,\n                y: height / 4\n            })\n            specialNodes.push({\n                x: 0,\n                y: height / (4/3)\n            });\n\n            // add one blocked node between the inputs (for better looking wiring)\n            specialNodes.push({\n                x: 0,\n                y: height / 2\n            });\n        }\n\n        this.generateBlockNodes(...specialNodes);\n\n        this.refreshState();\n    }\n\n    /**\n     * array of valid gate names\n     * @type {Set}\n     */\n    static get validGates() {\n        return new Set([\"not\", \"and\", \"or\", \"nand\", \"nor\", \"xor\", \"xnor\", \"repeater\"]);\n    }\n\n    generateBlockNodes(...specialNodes) {\n        if(specialNodes!==undefined) {\n            super.generateBlockNodes(0, 1, 0, 1, ...specialNodes);\n        } else {\n            super.generateBlockNodes(0, 1, 0, 1);\n        }\n    }\n\n    /**\n     * proccess the input connector states and reflect them in the output connector states according\n     * to the logic corresponding to this gate's name\n     */\n    refreshState() {\n        let state = Logic.state.unknown\n        switch (this.name) {\n            case \"and\":\n                state = Logic.and(this.connectors[1].state, this.connectors[2].state)\n                break;\n            case \"nand\":\n                state = Logic.nand(this.connectors[1].state, this.connectors[2].state)\n                break;\n            case \"nor\":\n                state = Logic.nor(this.connectors[1].state, this.connectors[2].state)\n                break;\n            case \"not\":\n                state = Logic.not(this.connectors[1].state)\n                break;\n            case \"or\":\n                state = Logic.or(this.connectors[1].state, this.connectors[2].state)\n                break;\n            case \"xnor\":\n                state = Logic.xnor(this.connectors[1].state, this.connectors[2].state)\n                break;\n            case \"xor\":\n                state = Logic.xor(this.connectors[1].state, this.connectors[2].state)\n                break;\n            case \"repeater\":\n                state = this.connectors[1].state\n                break;\n        }\n        // notify the simulator about this change\n        this.parentSVG.simulation.notifyChange(this.connectors[0].id, state)\n    }\n}\n\n/**\n * Blackbox is a box that is defined by its evaluation function\n * @extends Box\n */\nexport class Blackbox extends Box {\n    /**\n     * @param {Canvas} parentSVG  instance of [Canvas](./module-Canvas.html)\n     * @param {number} inputConnectors  number of input connectors\n     * @param {number} outputConnectors number of output connectors\n     * @param {Function} evalFunction   function that takes `inputConnectors` [Logic.state](./module-Logic.html#.state)s\n     *                                  and returns `outputConnectors` Logic.states.\n     * @param {String} [name]        name that will be displayed on the blackbox\n     */\n    constructor(parentSVG, inputConnectors, outputConnectors, evalFunction, name = \"\") {\n        const width = 11;\n        const height = Math.max(inputConnectors, outputConnectors) * 2;\n\n        super(parentSVG, name, \"blackbox\", width, height);\n\n        const connectorPinLenght = 2.5 * this.gridSize;\n\n        // override default svgObj structure\n        this.svgObj = new svgObj.Group();\n\n        // transparent background rectangle\n        let hitbox = new svgObj.Rectangle(0, 0, this.width, this.height, \"none\", \"none\");\n        hitbox.$el.addClass('rect');\n\n        this.svgObj.addChild(hitbox);\n\n        // main rectangle\n        const bodyWidth = this.width - 2 * connectorPinLenght;\n\n        let rectangle = new svgObj.Rectangle(connectorPinLenght, 0, bodyWidth, this.height, \"white\", \"black\");\n        rectangle.addAttr({'stroke-width': '2.5'});\n        rectangle.$el.addClass('rect');\n\n        this.svgObj.addChild(rectangle);\n\n        // text description of the box\n        const textWidth = bodyWidth - this.gridSize;\n        const textHeight = this.height - this.gridSize;\n        let text = new svgObj.MultiLineText(\n            (this.width - textWidth) / 2, // horizontal centering\n            (this.height - textHeight) / 2, // vertical centering\n            textWidth,\n            textHeight,\n            name.toUpperCase(),\n            this.gridSize * 1.2\n        );\n        this.svgObj.addChild(text);\n\n        // add input connectors\n        for (let i = 0 ; i < inputConnectors ; ++i) {\n            const gridPosition = (i * 2) + 1;\n            const pixelPosition = gridPosition * this.gridSize;\n\n            let pin = new svgObj.PolyLine(\n                new svgObj.PolylinePoints([\n                    new svgObj.PolylinePoint(0, pixelPosition),\n                    new svgObj.PolylinePoint(connectorPinLenght, pixelPosition),\n                ]),\n                1,\n                \"black\"\n            )\n\n            this.svgObj.addChild(pin);\n\n            // add the connector\n            this.addInputConnector(0, gridPosition);\n        }\n\n        // add output connectors\n        for (let i = 0 ; i < outputConnectors ; ++i) {\n            const gridPosition = (i * 2) + 1;\n            const pixelPosition = gridPosition * this.gridSize;\n\n            let pin = new svgObj.PolyLine(\n                new svgObj.PolylinePoints([\n                    new svgObj.PolylinePoint(this.width - connectorPinLenght, pixelPosition),\n                    new svgObj.PolylinePoint(this.width, pixelPosition),\n                ]),\n                1,\n                \"black\"\n            )\n\n            this.svgObj.addChild(pin);\n\n            this.addOutputConnector(width, gridPosition);\n        }\n\n        this.svgObj.$el.addClass(\"box\");\n\n        /**\n         * function that takes `inputConnectors` [Logic.state](./module-Logic.html#.state)s\n         * and returns `outputConnectors` Logic.states.\n         */\n        this.evalFunction = evalFunction;\n\n        // regenerate the blocked nodes after adding all the connectors\n        this.generateBlockNodes();\n    }\n\n    /**\n     * get data of this blackbox as a JSON-ready object\n     * @return {Object} javascript object containing essential data for this blackbox\n     */\n    get exportData() {\n        let data = super.exportData;\n        data.inputs = this.inputConnectors.length;\n        data.outputs = this.outputConnectors.length;\n\n        // generate the truth table\n\n        data.table = []\n\n        // array of tested input states\n        const stateList = Logic.stateList;\n\n        // recursive function that generates all possible inputs\n        const getPermutations = (length) => {\n            let permutations = [];\n            switch (length) {\n                case 0:\n                    return [];\n                case 1:\n                    for (const state of stateList) {\n                        permutations.push([state])\n                    }\n                    return permutations;\n                default:\n                    for (const state of stateList) {\n                        for(const perm of getPermutations(length - 1)) {\n                            permutations.push([state, ...perm])\n                        }\n                    }\n                    return permutations;\n            }\n        }\n\n        // generate outputs for all the possible inputs\n        for (const inputValues of getPermutations(data.inputs)) {\n            const outputValues = this.evalFunction(...inputValues);\n\n            // if there is an output value that is not Logic.state.unknown, add this line to the\n            // truthtable, otherwise don't add it (if all output values are Logic.state.unknown,\n            // the input combination does not have to be defines, because Logic.state.unknown is the default value)\n            if (outputValues.reduce((accumulator, current) => {\n                return accumulator || current !== Logic.state.unknown\n            })) {\n                data.table.push([...inputValues, ...outputValues])\n            }\n        }\n\n        return data;\n    }\n\n    /**\n     * proccess the input connector states and reflect them in the output connector states according\n     * to the logic defined by this.evalFunction\n     */\n    refreshState() {\n        const inputStates = this.inputConnectors.map(conn => conn.state);\n        // call the evalFunction to get the output states\n        const outputStates = this.evalFunction(...inputStates);\n\n        // apply the outputStates to the outputConnectors\n        for (let i = 0; i < outputStates.length ; ++i) {\n            this.outputConnectors[i].setState(outputStates[i]);\n        }\n    }\n\n    generateBlockNodes() {\n        // add blocked nodes on the connectors and between them as well\n\n        let specialNodes = []\n        for (let i = 1 ; i < this.inputConnectors.length * 2 ; ++i) {\n            specialNodes.push({\n                x: 0,\n                y: i\n            })\n        }\n        for (let i = 1 ; i < this.outputConnectors.length * 2 ; ++i) {\n            specialNodes.push({\n                x: this.gridWidth,\n                y: i\n            })\n        }\n\n        super.generateBlockNodes(0, 1, 0, 1, ...specialNodes);\n    }\n}\n\n/**\n * Wire represents connection of two {@link Connector}s.\n * @extends NetworkElement\n */\nexport class Wire extends NetworkElement {\n    /**\n     * @param {Canvas} parentSVG  instance of [Canvas](./module-Canvas.html)\n     * @param {string}  fromId    id of the first connector this wire will be connected to\n     * @param {string}  toId      id of the second connector this wire will be connected to\n     * @param {Boolean} [refresh=true] if `true`, the [Canvas](./module-Canvas.html) will refresh after creating this wire\n     */\n    constructor(parentSVG, fromId, toId, refresh = true, route = true) {\n        super(parentSVG);\n\n        this.gridSize = parentSVG.gridSize;\n\n        this.fromId = fromId;\n        this.toId = toId;\n\n        this.startBox = this.parentSVG.getBoxByConnectorId(fromId);\n        this.endBox = this.parentSVG.getBoxByConnectorId(toId);\n\n        this.boxes = [this.startBox, this.endBox]\n\n        this.startConnector = this.parentSVG.getConnectorById(fromId);\n        this.endConnector = this.parentSVG.getConnectorById(toId);\n\n        this.connectors = [this.startConnector, this.endConnector]\n\n        if(route) {\n            this.routeWire(true, refresh);\n        } else {\n            this.temporaryWire();\n        }\n\n        this.elementState = Logic.state.unknown;\n\n        for (let connector of this.connectors) {\n            if(connector.isOutputConnector) {\n                this.setState(connector.state);\n            }\n        }\n\n        this.svgObj.$el.addClass(\"wire\");\n    }\n\n    /**\n     * get data of this wire as a JSON-ready object\n     * @return {Object} javascript object containing essential data for this wire\n     */\n    get exportData() {\n        return {\n            fromId: this.fromId,\n            toId: this.toId\n        };\n    }\n\n    /**\n     * set the state of this wire to match the state of the input connector it is connected to\n     * @param {Logic.state} state [description]\n     */\n    setState(state) {\n        this.svgObj.removeClasses(stateClasses.on, stateClasses.off, stateClasses.unknown, stateClasses.oscillating);\n\n        switch (state) {\n            case Logic.state.unknown:\n                this.svgObj.addClass(stateClasses.unknown);\n                break;\n            case Logic.state.on:\n                this.svgObj.addClass(stateClasses.on);\n                break;\n            case Logic.state.off:\n                this.svgObj.addClass(stateClasses.off);\n                break;\n            case Logic.state.oscillating:\n                this.svgObj.addClass(stateClasses.oscillating);\n                break;\n        }\n\n        if (this.startConnector.isInputConnector) {\n            this.startConnector.setState(state);\n        }\n        if(this.endConnector.isInputConnector) {\n            this.endConnector.setState(state);\n        }\n\n        this.elementState = state;\n    }\n\n    /**\n     * get the current [Logic.state](./modules-Logic.html#.state) of this wire\n     * @return {Logic.state}\n     */\n    get state() {\n        return this.elementState;\n    }\n\n    /**\n     * update the state of this wire\n     */\n    updateWireState() {\n        for (const box of this.boxes) {\n            box.refreshState()\n        }\n    }\n\n    /**\n     * get the jQuery element for this wire\n     * @return {jQuery.element}\n     */\n    get() {\n        return this.svgObj.get();\n    }\n\n    /**\n     * get the polyline points for a temporary wire placement connecting the two connectors\n     * @return {PolylinePoints} new instance of {@link PolylinePoints}\n     */\n    getTemporaryWirePoints() {\n        let points = new svgObj.PolylinePoints();\n        points.append(new svgObj.PolylinePoint(this.wireStart.x, this.wireStart.y));\n        points.append(new svgObj.PolylinePoint(this.wireEnd.x, this.wireEnd.y));\n        return points;\n    }\n\n    /**\n     * route the wire using the temporary wire points\n     */\n    temporaryWire() {\n        this.wireStart = this.parentSVG.getConnectorPosition(this.startConnector, false);\n        this.wireEnd = this.parentSVG.getConnectorPosition(this.endConnector, false);\n\n        this.setWirePath(this.getTemporaryWirePoints());\n    }\n\n    /**\n     * route the wire using the modified A* wire routing algorithm\n     */\n    routeWire(snapToGrid = true, refresh = true) {\n        this.wireStart = this.parentSVG.getConnectorPosition(this.startConnector, snapToGrid);\n        this.wireEnd = this.parentSVG.getConnectorPosition(this.endConnector, snapToGrid);\n\n        this.points = this.findRoute(\n            {\n                x: this.wireStart.x / this.gridSize,\n                y: this.wireStart.y / this.gridSize\n            },\n            {\n                x: this.wireEnd.x / this.gridSize,\n                y: this.wireEnd.y / this.gridSize\n            });\n\n        this.setWirePath(this.points);\n\n        if (refresh)\n            this.updateWireState();\n\n        // regenerate inconvenient nodes\n        this.generateInconvenientNodes();\n    }\n\n    /**\n     * set the wire to follow the specified points\n     * @param {PolylinePoints} points instance of {@link PolylinePoints}\n     */\n    setWirePath(points) {\n        // set the line\n        if(this.svgObj!==undefined) {\n            // this.svgObj.updatePoints(points);\n            for (let child of this.svgObj.children) {\n                child.updatePoints(points);\n            }\n        } else {\n            this.svgObj = new svgObj.Group();\n\n            let hitbox = new svgObj.PolyLine(points, 10, 'white');\n            hitbox.addClass(\"hitbox\");\n            hitbox.addAttr({opacity: 0});\n            this.svgObj.addChild(hitbox);\n\n            let mainLine = new svgObj.PolyLine(points, 2);\n            mainLine.addClass(\"main\", \"stateUnknown\");\n            this.svgObj.addChild(mainLine);\n        }\n    }\n\n    pathToPolyline(path) {\n        let totalPath = new svgObj.PolylinePoints();\n        for (const point of path) {\n            totalPath.append(new svgObj.PolylinePoint(point.x * this.gridSize, point.y * this.gridSize));\n        }\n        return totalPath;\n    }\n\n    /**\n     * find a nice route for the wire\n     * @param  {Object} start object containing numeric attributes `x` and `y` that represent the first endpoint of the wire in grid pixel\n     * @param  {Object} end   object containing numeric attributes `x` and `y` that represent the second endpoint of the wire in grid pixels\n     * @return {PolylinePoints}       [description]\n     */\n    findRoute(start, end) {\n        let nonRoutable = this.parentSVG.getNonRoutableNodes();\n\n        let punishedButRoutable;\n        if(this.svgObj===undefined) {\n            punishedButRoutable = this.parentSVG.getInconvenientNodes();\n        } else {\n            punishedButRoutable = this.parentSVG.getInconvenientNodes(this.svgObj.id);\n        }\n\n        let path = findPath(start, end, nonRoutable, punishedButRoutable, this.gridSize);\n\n        if(path) {\n            return this.pathToPolyline(path);\n        }\n\n\n        // if a path was not found, try again but don't take into account the punished and non routable node\n        path = findPath(start, end, new Set(), new Set(), this.gridSize);\n\n        if(path) {\n            return this.pathToPolyline(path);\n        }\n\n        // if the path was still not found, give up and return temporary points\n        return this.getTemporaryWirePoints();\n    }\n\n    /**\n     * generate a set of nodes, that are inconvenient for wiring, but can be used, just are not preferred\n     * @return {Set} set of nodes (objects containing x and y coordinates) that are not preferred for wiring\n     */\n    generateInconvenientNodes() {\n        this.inconvenientNodes = new Set();\n\n        let prevPoint;\n\n        this.points.forEach(point => {\n            const\n                x = this.parentSVG.SVGToGrid(point.x),\n                y = this.parentSVG.SVGToGrid(point.y);\n\n            if (prevPoint === undefined) {\n                // if the prevPoint is undefined, add the first point\n                this.inconvenientNodes.add({x, y});\n            } else {\n                // else add all the point between the prevPoint (excluded) and point (included)\n\n                if(prevPoint.x === x) {\n                    // if the line is horizontal\n                    let from = Math.min(prevPoint.y, y);\n                    let to = Math.max(prevPoint.y, y);\n\n                    while(from <= to) {\n                        this.inconvenientNodes.add({x: x, y: from});\n                        from++;\n                    }\n                } else if(prevPoint.y === y) {\n                    // if the line is vertical\n                    let from = Math.min(prevPoint.x, x);\n                    let to = Math.max(prevPoint.x, x);\n\n                    while(from <= to) {\n                        this.inconvenientNodes.add({x: from, y: y});\n                        from++;\n                    }\n                } else {\n                    // line is neither horizontal nor vertical, throw an error for better future debugging\n                    // console.error(\"getInconvenientNodes: line between two points is neither horizontal nor vertical\");\n                }\n            }\n\n            // set new prevPoint\n            prevPoint = {x, y};\n        });\n    }\n}\n","import {manhattanDistance} from './helperFunctions'\nimport MapWithDefaultValue from './mapWithDefaultValue'\n\nimport { PriorityQueue } from 'libstl'; // note: imported from a node module\n\n/**\n * returns `true` if the specified set of points contains the specified point (and returns `false` otherwise)\n * @param {Set} set set of points\n * @param {Object} point object containing numeric attributes `x` and `y`\n */\nfunction setHasThisPoint(set, point) {\n    for (let item of set) {\n        if (item.x === point.x && item.y === point.y) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Helper that moves the passed point in the specified direction. It simply adds or subtracts 1 from one of the coordinates depending on the direction attribute.\n * @param  {Object} point     object containing numeric attributes `x` and `y`\n * @param  {number} direction directions:\n *                              - 0: up\n *                              - 1: right\n *                              - 2: down\n *                              - 3: left\n * @return {Object}           object containing numeric attributes `x` and `y`\n */\nfunction movePoint(point, direction) {\n    switch (direction) {\n        case 0: // up\n            return {\n                x: point.x,\n                y: point.y - 1\n            };\n        case 1: // right\n            return {\n                x: point.x + 1,\n                y: point.y\n            };\n        case 2: // down\n            return {\n                x: point.x,\n                y: point.y + 1\n            };\n        case 3: // left\n            return {\n                x: point.x - 1,\n                y: point.y\n            };\n    }\n}\n\n/**\n * helper backtracking function used by the aStar algorithm to construct the final path\n * @param  {Object} cameFrom    object containing numeric attributes `x` and `y`\n * @param  {Object} currentNode object containing numeric attributes `x` and `y`\n * @return {TODO}\n */\nfunction reconstructPath(cameFrom, currentNode) {\n    let path = [];\n\n    path.push({\n        x: currentNode.x,\n        y: currentNode.y\n    })\n\n    while (cameFrom.has(currentNode)) {\n        currentNode = cameFrom.get(currentNode);\n        path.push({\n            x: currentNode.x,\n            y: currentNode.y\n        })\n    }\n\n    return path;\n}\n\n/**\n * Heavily modified implementation of the A* algorithm\n * @param  {Object} start object containing numeric attributes `x` and `y` that represent the first endpoint of the wire in grid pixels\n * @param  {Object} end   object containing numeric attributes `x` and `y` that represent the second endpoint of the wire in grid pixels\n * @param  {Set} nonRoutable set of non routable nodes\n * @param  {Set} punishedButRoutable set of nodes that are not optimal for routing\n * @return {TODO}\n */\nexport default function findPath(start, end, nonRoutable, punishedButRoutable) {\n\n    const distanceFunction = manhattanDistance;\n\n    const wireCrossPunishment = 1;\n    const wireBendPunishment = 1;\n\n    // number of nodes, that can be opened at once\n    // once is this limit exceeded, aStar will fail and return undefined\n    const maxNodeLimit = 100000;\n\n    let closedNodes = new Set();\n    let openNodes = new Set();\n    let openNodeQueue = new PriorityQueue();\n\n    // functions for working with open nodes:\n\n    /**\n     * add a new open node to the structure\n     * @param {Object} node   object containing numeric attributes `x` and `y` that represent the first endpoint of the wire\n     * @param {number} fscore fScore of this node\n     */\n    const addOpenNode = (node, fscore) => {\n        openNodes.add(node);\n        // flip the fscore, because PriorityQueue uses max heap\n        openNodeQueue.enqueue(node, 1 / fscore);\n    }\n\n    /**\n     * get the open node with the lowest fScore and remove it\n     * @return {Object} object containing numeric attributes `x` and `y` that represent the first endpoint of the wire\n     */\n    const getOpenNode = () => {\n        const node = openNodeQueue.dequeue();\n        openNodes.delete(node);\n        return node;\n    }\n\n    let cameFrom = new Map();\n\n    // default value: infinity\n    let gScore = new MapWithDefaultValue(Infinity);\n    gScore.set(start, 0);\n\n    let startFScore = distanceFunction(start, end);\n\n    addOpenNode(start, startFScore);\n\n    openNodes.add(start);\n    openNodeQueue.enqueue(start, 1 / startFScore);\n\n    while (openNodes.size > 0) {\n        // get the value from openNodes that has the lowest fScore\n        const currentNode = getOpenNode();\n\n        // if we reached the end point, reconstruct the path and return it\n        if (currentNode.x == end.x && currentNode.y == end.y) {\n            return reconstructPath(cameFrom, currentNode);\n        }\n\n        // add this node to the closed nodes\n        closedNodes.add(currentNode);\n\n        // the farthest points accessible without avoiding obstacles in every direction\n        // (but max 50 in each direction)\n        for (let direction = 0; direction < 4; direction++) {\n            let newPoint = movePoint(currentNode, direction);\n\n            let wiresCrossed = 0;\n\n            for (let i = 0; i < 50; i++) {\n                // if newPoint is in the set of non routable points,\n                // don't add it and stop proceeding in this direction\n                if (setHasThisPoint(nonRoutable, newPoint)) {\n                    // if this not the end point, break\n                    if (newPoint.x !== end.x || newPoint.y !== end.y) {\n                        break;\n                    }\n                }\n\n                // skip this node, if it has been already closed\n                // or if it is on the list of non routable nodes\n                if (closedNodes.has(newPoint)) {\n                    continue;\n                }\n\n                // calculate possible GScore by applying a punishment for each node (\"bend\") in the path\n                let newGScore = wireBendPunishment + gScore.getWithDefault(currentNode);\n\n                if (setHasThisPoint(punishedButRoutable, newPoint)) {\n                    // if the node is in the set of punished nodes, apply the punishment\n                    wiresCrossed++;\n                }\n\n                // apply the punishment for each wire crossed in this direction\n                // note: we are counting the wires crossed when exporting this direction, not the wires\n                // crossed in the final path, there will be probably only at most of these nodes in the\n                // final path, not multiple\n                newGScore += wiresCrossed * wireCrossPunishment;\n\n                // skip this node if it has worst estimage gscore than in the gscore table\n                if (newGScore >= gScore.getWithDefault(newPoint)) {\n                    continue;\n                }\n\n                cameFrom.set(newPoint, currentNode);\n                gScore.set(newPoint, newGScore);\n\n                const newFScore = newGScore + distanceFunction(newPoint, end);\n\n                if (!openNodes.has(newPoint)) {\n                    // add the point to the list of points\n                    addOpenNode(newPoint, newFScore);\n                }\n\n                // move to the next point in the direciton\n                newPoint = movePoint(newPoint, direction);\n            }\n        }\n\n        if (openNodes.size > maxNodeLimit) {\n            console.log(`aStar: Number of open nodes (${openNodes.size}) exceeded the limit for open nodes (${maxNodeLimit}).`)\n            break;\n        }\n    }\n    // if we got here, the path was not found\n\n    return undefined;\n}\n","import { getJSONString } from \"./helperFunctions\";\n\n/**\n * FloatingButton represents a button that is used in the floating menu in the right bottom corner\n * of the application. It may have a custom tooltip and callback on the click event\n */\nclass FloatingButton {\n    /**\n     * @param {string} buttonClass Custom string that identifies the SVG icon used on this button. This string is also added as a CSS class to the button.\n     * @param {string} tooltip     tooltip for the button, that will be displayed on hover and also used as alternative title for the image\n     * @param {Function} clickEvent  custom callback when user clicks the button\n     * @param {Canvas} parentSVG   reference to the parent SVG element\n     */\n    constructor(buttonClass, tooltip, clickEvent, parentSVG) {\n        /**\n         * jQuery element representing the button\n         * @type {jQuery.element}\n         */\n        this.$el = $('<a>')\n\n        // add classes to the element\n        this.$el.addClass(\"button\");\n        this.$el.addClass(buttonClass);\n\n        // add the icon\n        this.$el.append(\n            $(\"<img>\")\n            .attr(\"src\", `img/gui/${buttonClass}.svg`)\n            .attr(\"alt\", tooltip)\n        );\n\n        // add the tooltip element and an event listener if tooltip is defined\n        if (tooltip) {\n            /**\n             * jQuery element representing the tooltip\n             * @type {jQuery.element}\n             */\n            this.$tooltip = $(\"<div>\");\n            this.$tooltip\n                .addClass(\"tooltip\")\n                .html(tooltip);\n\n            parentSVG.$svg.after(this.$tooltip);\n\n            this.$el.hover(() => {\n                this.$tooltip.fadeIn(200);\n            }, () => {\n                this.$tooltip.fadeOut(200);\n            });\n        }\n\n        // add an event listener on click, if the callback function is defined\n        if (clickEvent) {\n            this.$el.on(\"click\", clickEvent);\n        }\n    }\n}\n\n/** @module FloatingMenu */\n/**\n * Class to represent the floating menu in the right bottom corner of the page.\n * It instantiates all the buttons and their callbacks.\n */\nexport default class FloatingMenu {\n    /**\n     * @param {Canvas} parentSVG reference to the Canvas element this menu is associated with\n     */\n    constructor(parentSVG) {\n        /**\n         * the jQuery element containing all buttons\n         * @type {jQuery.element}\n         */\n        this.$el = $('<div>')\n\n        const id = 'floatingMenu';\n\n        this.$el.attr(\"id\", id);\n\n        // const $loader = $(\"<div>\").addClass(\"loader\").addClass(\"hidden\");\n\n\n        /* EXPORT */\n        this.append(\n            new FloatingButton(\"export\", \"Get code for this network\", () => {\n                // create the popup container holding all popup content (that will be passed to lity)\n                let $popup = $(\"<div>\")\n                    .addClass(\"importExport\")\n                    .addClass(\"export\");\n\n                // generate the block with code to be displayed and append it to the popup element\n                const $textblock = $(\"<textarea>\").text(\n                    getJSONString(parentSVG.exportData, true)\n                )\n\n                $popup.append($textblock);\n\n                // generate the links\n                $popup.append(\n                    $(\"<a>\").attr({\n                        \"href\": getJSONString(parentSVG.exportData, true, true),\n                        \"class\": \"download\",\n                        \"download\": \"network.json\"\n                    }).append(\n                        $(\"<img>\").attr('src', \"img/gui/export.svg\")\n                    ).append(\" expanded JSON\")\n                );\n                $popup.append(\n                    $(\"<a>\").attr({\n                        \"href\": getJSONString(parentSVG.exportData, false, true),\n                        \"class\": \"download\",\n                        \"download\": \"network.min.json\"\n                    }).append(\n                        $(\"<img>\").attr('src', \"img/gui/export.svg\")\n                    ).append(\" compact JSON\")\n                );\n\n                lity($popup);\n\n                // highlight the text in the textblock\n                $textblock.select();\n            }, parentSVG)\n        );\n\n        /* Tutorial */\n        this.append(\n            new FloatingButton(\"tutorial\", \"Start the tutorial\", () => {\n                parentSVG.startTutorial();\n            }, parentSVG)\n        );\n\n        parentSVG.$svg.after(this.$el);\n\n        /* HELP */\n\n        let help = new FloatingButton(\"help\", \"Display a help page\", false, parentSVG);\n        help.$el.attr({\n            'href': './docs/user.html',\n            'data-lity': ''\n        });\n        this.append(help);\n\n        parentSVG.$svg.after(this.$el);\n    }\n\n    /**\n     * append a FloatingButton to this menu\n     * @param  {FloatingButton} menuItem append an instance of  {@link FloatingButton} to this menu\n     */\n    append(menuItem) {\n        this.$el.append(menuItem.$el);\n    }\n}\n","\"use strict\";\n\n/**\n * @module HelperFunctions\n */\n\nimport stringify from \"json-stringify-pretty-compact\"; // note: imported from a module\n\n/**\n * add a cross browser event listener on a mouse scroll\n * @param {string} query DOM query of the element that the listener will be added to\n * @param {Function} func  Function that will be called when the event occurs. The function takes as a parameter an event object.\n */\nexport function addMouseScrollEventListener(query, func) {\n    let MouseWheelHandler = event => {\n        // redeclare for old IE support\n        var event = window.event || event; // eslint-disable-line no-redeclare\n\n        event.delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail)));\n\n        func(event)\n\n        return false;\n    }\n\n    let svgelement;\n\n    // if the query is a simple DOM id selector, we can use getElementById which has better backwards compatibility\n    if(query.match(/^#\\w+$/)) {\n        svgelement = document.getElementById(query.substr(1))\n    } else {\n        svgelement = document.querySelector(query)\n    }\n\n    if (svgelement.addEventListener) {\n        // IE9, Chrome, Safari, Opera\n        svgelement.addEventListener(\"mousewheel\", MouseWheelHandler, false);\n        // Firefox\n        svgelement.addEventListener(\"DOMMouseScroll\", MouseWheelHandler, false);\n    } else  {\n        // IE 6/7/8\n        svgelement.attachEvent(\"onmousewheel\", MouseWheelHandler);\n    }\n    svgelement.addEventListener('mousewheel', function(e) {\n        console.log('event', e)\n    }, false)\n}\n\n/**\n * convert a data object to JSON string or to a data URI containing a JSON string\n * @param  {Object}  data            object that will be serialized into a JSON string\n * @param  {Boolean} [pretty=false]  if `true`, the code will be proprerly indented, else a more compact syntax will be used\n * @param  {Boolean} [dataUri=false] return dataUri containing the JSON string instead of the pure JSON string\n * @return {string}\n */\nexport function getJSONString(data, pretty = false, dataUri = false) {\n    if(dataUri) {\n        return 'data:application/json;charset=utf-8,'\n            + encodeURIComponent(getJSONString(data, pretty));\n    } else {\n        switch (pretty) {\n            case true:\n                return stringify(data, {maxLength: 50});\n            case false:\n                return JSON.stringify(data);\n        }\n    }\n}\n\n/**\n * returns the Manhattan distance between the points _a_ and _b_\n * @param  {Object} a object containing numeric attributes `x` and `y`\n * @param  {Object} b object containing numeric attributes `x` and `y`\n * @return {number}\n */\nexport function manhattanDistance(a, b) {\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n}\n","/** @module Id */\n\n/**\n * the current instance of Id\n * @type {Id}\n */\nlet existingIdInstance;\n\n/**\n * singleton to generate unique id's\n *\n * usage: `let id = new Id().unique`\n */\nexport default class Id {\n    constructor() {\n        if(!existingIdInstance){\n            existingIdInstance = this;\n        }\n\n        /**\n         * prefix for the id, that is common in all the Ids\n         * @type {String}\n         */\n        this.prefix = \"id\";\n\n        /**\n         * numeric part of the next id (the next id without the prefix)\n         * @type {number}\n         */\n        this.nextId = 0;\n\n        return existingIdInstance;\n    }\n\n    /**\n     * get unique ID\n     * @return {string} new unique ID\n     */\n    get unique() {\n        let retVal = this.prefix + this.nextId;\n\n        // find next unused idXXXX to prevent id collision that might be caused by some other component\n        // (it really should not happen, but this is a simple way to ensure it)\n        while($(\"#\"+retVal).length) {\n            this.nextId++;\n            retVal = this.generate();\n        }\n        // return this id\n        this.nextId++;\n\n        return retVal;\n    }\n}\n","\"use strict\";\n\n/** @module Logic */\n/**\n * definitions of logic states and basic logic functions used in the simulation\n */\nexport default class Logic {\n    /**\n     * Enum for logic states.\n     *\n     * States:\n     * - `unknown`\n     * - `on`\n     * - `off`\n     * - `oscillating`\n     * @type {Number}\n     */\n    static get state() {\n        return {\n            unknown: 0,\n            on: 1,\n            off: 2,\n            oscillating: 3\n        }\n    }\n\n    /**\n     * list of all states that can be used in the simulation\n     *\n     * This getter iterates over Logic.state and returns an array containing all values of Logic.state's members\n     * @type {Array}\n     */\n    static get stateList() {\n        let states = [];\n\n        // iterate over all defined states and add their values to the states array\n        Object.keys(Logic.state).forEach(key => {\n            states.push(Logic.state[key]);\n        });\n\n        return states;\n    }\n\n    /**\n     * Logic AND\n     * @param  {Logic.state} a first input state\n     * @param  {Logic.state} b second input state\n     * @return {Logic.state}   output state\n     */\n    static and(a, b) {\n        return Logic.runSymmetricRules(a, b, [\n            [Logic.state.on, Logic.state.on, Logic.state.on],\n            [Logic.state.on, Logic.state.off, Logic.state.off],\n            [Logic.state.on, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.on, Logic.state.oscillating, Logic.state.oscillating],\n\n            [Logic.state.off, Logic.state.off, Logic.state.off],\n            [Logic.state.off, Logic.state.unknown, Logic.state.off],\n            [Logic.state.off, Logic.state.oscillating, Logic.state.off],\n\n            [Logic.state.unknown, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.unknown, Logic.state.oscillating, Logic.state.unknown],\n\n            [Logic.state.oscillating, Logic.state.oscillating, Logic.state.oscillating]\n        ]);\n    }\n    /**\n     * Logic NAND\n     * @param  {Logic.state} a first input state\n     * @param  {Logic.state} b second input state\n     * @return {Logic.state}   output state\n     */\n    static nand(a, b) {\n        return Logic.not(Logic.and(a, b));\n    }\n\n    /**\n     * Logic NOR\n     * @param  {Logic.state} a first input state\n     * @param  {Logic.state} b second input state\n     * @return {Logic.state}   output state\n     */\n    static nor(a, b) {\n        return Logic.not(Logic.or(a, b));\n    }\n\n    /**\n     * Logic NOT\n     * @param  {Logic.state} a first input state\n     * @return {Logic.state}   output state\n     */\n    static not(a) {\n        if(a === Logic.state.on) {\n            return Logic.state.off;\n        } else if (a === Logic.state.off) {\n            return Logic.state.on;\n        } else {\n            return a;\n        }\n    }\n\n    /**\n     * Logic OR\n     * @param  {Logic.state} a first input state\n     * @param  {Logic.state} b second input state\n     * @return {Logic.state}   output state\n     */\n    static or(a, b) {\n        return Logic.runSymmetricRules(a, b, [\n            [Logic.state.on, Logic.state.on, Logic.state.on],\n            [Logic.state.on, Logic.state.off, Logic.state.on],\n            [Logic.state.on, Logic.state.unknown, Logic.state.on],\n            [Logic.state.on, Logic.state.oscillating, Logic.state.on],\n\n            [Logic.state.off, Logic.state.off, Logic.state.off],\n            [Logic.state.off, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.off, Logic.state.oscillating, Logic.state.oscillating],\n\n            [Logic.state.unknown, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.unknown, Logic.state.oscillating, Logic.state.unknown],\n\n            [Logic.state.oscillating, Logic.state.oscillating, Logic.state.oscillating]\n        ]);\n    }\n\n    /**\n     * Logic XNOR\n     * @param  {Logic.state} a first input state\n     * @param  {Logic.state} b second input state\n     * @return {Logic.state}   output state\n     */\n    static xnor(a, b) {\n        return Logic.not(Logic.xor(a, b));\n    }\n\n    /**\n     * Logic XOR\n     * @param  {Logic.state} a first input state\n     * @param  {Logic.state} b second input state\n     * @return {Logic.state}   output state\n     */\n    static xor(a, b) {\n        return Logic.runSymmetricRules(a, b, [\n            [Logic.state.on, Logic.state.on, Logic.state.off],\n            [Logic.state.on, Logic.state.off, Logic.state.on],\n            [Logic.state.on, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.on, Logic.state.oscillating, Logic.state.oscillating],\n\n            [Logic.state.off, Logic.state.off, Logic.state.off],\n            [Logic.state.off, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.off, Logic.state.oscillating, Logic.state.oscillating],\n\n            [Logic.state.unknown, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.unknown, Logic.state.oscillating, Logic.state.unknown],\n\n            [Logic.state.oscillating, Logic.state.oscillating, Logic.state.oscillating]\n        ]);\n    }\n\n    /**\n     * Finds the correct rule in the array of rules and returns the corresponding return value.\n     * This function expects rules to be symmetric (so `a RULE b` should returns the same value as `b RULE a`),\n     * which allows to cut down on the `rules` array quite a bit\n     * @param  {Logic.state} a     first input state\n     * @param  {Logic.state} b     second input state\n     * @param  {Array} rules       Array of arrays. Each inner array represents a rule in the format [input1, input2, output].\n     *                             The function finds an array, where `a === input1` and `b === input1` (or `a === input2` and `b === input1`)\n     *                             and returns `output` from this array.\n     * @return {Logic.state}       output state\n     */\n    static runSymmetricRules(a, b, rules) {\n        // iterate through all the rules\n        for (const rule of rules) {\n            if ((rule[0] === a && rule[1] === b) || (rule[0] === b && rule[1] === a)) {\n                return rule[2];\n            }\n        }\n\n        // if no rule matches, the output state is unknown\n        return Logic.state.unknown;\n    }\n}\n","import Canvas from './canvas';\n\n/**\n * When the document is ready, initialize the application\n */\n$(() => {\n    new Canvas(\"#canvas\", 10);\n});\n","/** @module MapWithDefaultValue */\n/**\n * Map that has a default value specified in the constructor.\n *\n * For the complete documentation of the Map see [Map in the MDN web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n *\n * Usage:\n * ```JavaScript\n let myMap = new MapWithDefaultValue(Infinity);\n const value = myMap.getWithDefault(key)\n ```\n *\n * _Note: This version is written specially for ES6 compiled into ES5. In non-compiled ES6 is the implementation far more elegant:_\n *\n * ```JavaScript\n export class MapWithDefaultValue extends Map {\n     constructor(defaultValue) {\n         super();\n\n         this.default = defaultValue;\n     }\n\n     get(key) {\n         if(this.has(key)) {\n             return super.get(key);\n         } else {\n             return this.default;\n         }\n     }\n }```\n * @class MapWithDefaultValue\n * @param defaultValue {any} default value that will be returned when the requested key is not found in the map\n */\nexport default function(defaultValue) {\n    let map = new Map();\n    /**\n     * @param  {any} key key of a requested item\n     * @return {any} value of the item with the corresponding key, or defaultValue if the key is not found in the map\n     */\n    map.getWithDefault = (key) => {\n        return map.has(key)\n            ? map.get(key)\n            : defaultValue;\n    }\n    return map;\n}\n","\nclass Message {\n    constructor(text, onHide = undefined) {\n        this.$el = $(\"<div>\").addClass(\"message\").text(text);\n\n        this.onHide = onHide;\n    }\n\n    hide() {\n        this.$el.remove();\n\n        if(this.onHide) {\n            this.onHide();\n        }\n    }\n}\n\nclass LoadingMessage extends Message {\n    constructor(text, onHide = undefined) {\n        super(text, onHide);\n\n        this.$el.addClass(\"loading\");\n    }\n}\n\nclass ClosableMessage extends Message {\n    constructor(text, onHide = undefined) {\n        super(text, onHide);\n\n        this.$el.append(\n            $(\"<span>\").addClass(\"close\").click(() => {\n                this.hide();\n            })\n        )\n    }\n}\n\nclass ErrorMessage extends ClosableMessage {\n    constructor(text, onHide = undefined) {\n        super(text, onHide);\n\n        this.$el.addClass(\"error\");\n    }\n}\n\nclass WarningMessage extends ClosableMessage {\n    constructor(text, onHide = undefined) {\n        super(text, onHide);\n\n        this.$el.addClass(\"warning\");\n    }\n}\n\n/**\n * display messages to the user in a nice UI\n */\nexport default class Messages {\n    constructor() {\n        this.$el = $(\"<div>\").addClass('messages');\n\n        this.count = 0;\n\n        // place the progress info element\n        $('body').append(this.$el);\n    }\n\n    get count() {\n        return this.messageCount;\n    }\n\n    set count(value) {\n        this.messageCount = value;\n\n        if(this.messageCount < 1) {\n            this.hide();\n        } else {\n            this.display();\n        }\n    }\n\n    hide() {\n        this.$el.addClass('hidden');\n    }\n\n    display() {\n        this.$el.removeClass('hidden');\n    }\n\n    newMessage(text, constr = Message) {\n        let message = new constr(text, () => {\n            this.count--;\n        });\n\n        this.$el.append(message.$el);\n        this.count++;\n\n        return message;\n    }\n\n    newLoadingMessage(text) {\n        return this.newMessage(text, LoadingMessage);\n    }\n\n    newErrorMessage(text) {\n        return this.newMessage(text, ErrorMessage);\n    }\n\n    newWarningMessage(text) {\n        return this.newMessage(text, WarningMessage);\n    }\n}\n","/**\n * @module Library\n */\n\nconst libraryDir = './library/'\n\n/**\n * get list of networks from the library\n * @return {Promise} promise, the resolution is an object containing a list of libraries\n */\nexport function getLibrary() {\n    return new Promise((resolve, reject) => {\n        const libraryFile = libraryDir + 'networkList.json';\n\n        let request = new XMLHttpRequest();\n\n        request.addEventListener(\"load\", function() {\n            if(this.response) {\n                resolve(this.response.networks);\n            }\n        });\n\n        request.addEventListener([\"error\", \"abort\"], () => {\n            reject(\"Failed loading libraries.\")\n        });\n\n        request.open('GET', libraryFile, true);\n        request.responseType = 'json';\n        request.send();\n    });\n}\n\n/**\n * get a network from the library, specified by filename\n * @param  {string} networkName library file name without the extension\n * @return {Promise} promise, the resolution is an object containing the library import data\n */\nexport function getNetworkFromLibrary(networkName) {\n    return new Promise((resolve, reject) => {\n        let request = new XMLHttpRequest();\n\n        request.addEventListener(\"load\", function() {\n            if(this.response) {\n                resolve(this.response);\n            }\n        });\n\n        request.addEventListener([\"error\", \"abort\"], () => {\n            reject(`Failed loading library ${networkName}.`)\n        });\n\n        request.open('GET', libraryDir + networkName + '.json', true);\n        request.responseType = 'json';\n        request.send();\n    });\n}\n","import Logic from './logic'\n\n/**\n * @module Simulation\n */\n\n\nclass stateChange {\n    constructor(connectorId, state, whoCausedIt) {\n        this.connectorId = connectorId\n        this.state = state\n        this.whoCausedIt = whoCausedIt\n    }\n}\n\n/**\n * This class runs the network simulation.\n *\n * _note: all connectors that are used in this class are **output connectors**_\n */\nexport default class Simulation {\n    /**\n     * @param {Canvas} parentSVG instance of [Canvas](./module-Canvas.html)\n     */\n    constructor(parentSVG) {\n        /**\n         * instance of Canvas this Simulation belongs to\n         * @type {Canvas}\n         */\n        this.parentSVG = parentSVG\n\n        /**\n         * maps each affected output connector to it's directly preceeding output connectors\n         * @type {Map}\n         */\n        this.predecessors = new Map();\n\n        /**\n         * maps waveId to an array of affected outputConnectors\n         * @type {Map}\n         */\n        this.waves = new Map();\n        this.wave = 0\n\n        /**\n         * maps cycled connector id to set of states this connector was in\n         * @type {Map}\n         */\n        this.cycledConnectors = new Map()\n\n        /**\n         * set of cycled connectors that have been already resolved\n         * @type {Set}\n         */\n        this.resolvedCycledConnectors = new Set()\n\n    }\n\n    /**\n     * run the simulation\n     */\n    run() {\n        this.wave++;\n        while(this.waves.has(this.wave)) {\n            this.step()\n            this.waves.delete(this.wave) // clean old waves on the go\n            this.wave++\n        }\n    }\n\n    /**\n     * one step/wave of the simulation\n     *\n     * determines states of the connectors in the current wave, detects cycles\n     */\n    step() {\n        for (let {connectorId, state, whoCausedIt} of this.waves.get(this.wave)) {\n            // skip resolved cycles\n            if(this.resolvedCycledConnectors.has(connectorId)) {\n                continue\n            }\n\n            // skip connector that are cycles\n            if (this.cycledConnectors.has(connectorId)) {\n                // get the set of states that this connector appeared from the moment the signal first cycled\n                let states = this.cycledConnectors.get(connectorId)\n\n                // if the connector already had this state in this cycle, resolve the cycle\n                if(states.has(state)) {\n\n                    // if there are more states in the set, the connector is oscillating\n                    // (else it keeps its state and we just break the cycle)\n                    if(states.size > 1) {\n                        state = Logic.state.oscillating\n                    }\n\n                    // mark this connector as resolved\n                    this.resolvedCycledConnectors.add(connectorId)\n\n                // this is a new, unseen state, add it to the set and continue simulating the cycle\n                } else {\n                    states.add(state)\n                }\n\n                // map the modified set of states to the connector\n                this.cycledConnectors.set(connectorId, states)\n            }\n\n            this.whoCausedIt = connectorId\n            /*  process all outputConnectors by setting their state\n                this will trigger a following event chain:\n                    outputConnector changes\n                    -> all connected wires change\n                    -> all inputConnectors connected to these wires change\n                    -> all elements that contain these inputConnectors change\n                    -> these elements compute the new state of their output connectors and call notifyChange()\n            */\n\n\n            if(whoCausedIt) {\n                this.addPredecessor(connectorId, whoCausedIt)\n            }\n\n            if (!this.cycledConnectors.has(connectorId) && this.getAllPredecessors(connectorId).has(connectorId)) {\n                this.cycledConnectors.set(connectorId, new Set([state]))\n            }\n\n\n            // reflect the changes in SVG\n            let connector = this.parentSVG.getConnectorById(connectorId)\n            if(connector) {\n                connector.setState(state)\n            }\n        }\n        this.whoCausedIt = undefined\n    }\n\n    /**\n     * mark a predecessorConnectorId as a predecessor of connectorId\n     * @param {string} connectorId ID of a connector\n     * @param {string} predecessorConnectorId predecessor of `connectorId`\n     */\n    addPredecessor(connectorId, predecessorConnectorId) {\n        if(!this.predecessors.has(connectorId)) {\n            this.predecessors.set(connectorId, new Set())\n        }\n\n        this.predecessors.get(connectorId).add(predecessorConnectorId)\n    }\n\n    /**\n     * get set of all output connectors that are before this output connector\n     * @param  {string} connectorId ID of a connector\n     * @return {Set}                set of connector ids that are before this output connector\n     */\n    getAllPredecessors(connectorId) {\n        if(!this.predecessors.has(connectorId)) {\n            this.predecessors.set(connectorId, new Set())\n        }\n\n        let all = new Set()\n\n        this.predecessors.get(connectorId).forEach(all.add, all);\n\n        let prevSize = 0\n        let size = all.size\n        while(prevSize < size) {\n            for (let connector of all) {\n                if (this.predecessors.has(connector)) {\n                    this.predecessors.get(connector).forEach(all.add, all);\n                }\n            }\n            prevSize = size\n            size = all.size\n        }\n\n        return all\n    }\n\n    /**\n     * Notify a change in the network. This function adds the changed connector to the next wave\n     * @param  {string} connectorId ID of the changed connector\n     * @param  {Logic.state} state  new [Logic.state](./module-Logic.html#.state) of the connector\n     */\n    notifyChange(connectorId, state) {\n        let waveId = this.wave + 1\n\n        if(!this.waves.has(waveId)) {\n            this.waves.set(waveId, [])\n        }\n\n        this.waves.get(waveId).push(new stateChange(connectorId, state, this.whoCausedIt));\n    }\n}\n","import Id from './id'\n\n/**\n * Parent class for all svgObjects\n */\nclass Tag {\n    /**\n     * @param {string} tagName SVG tag identifier (`rect`, `image`, `polyline`)\n     */\n    constructor(tagName) {\n        /**\n         * SVG tag identifier (`rect`, `image`, `polyline`)\n         * @type {string}\n         */\n        this.tagName = tagName;\n\n        /**\n         * jQuery element for this tag\n         * @type {jQuery.element}\n         */\n        this.$el = $(\"<\"+this.tagName+\">\");\n\n        /**\n         * unique ID of this SVG object\n         * @type {string}\n         */\n        this.id = new Id().unique;\n    }\n\n    /**\n     * add a class to this element\n     * @param {string} name class name to be added\n     */\n    addClass(name) {\n        this.$el.addClass(name);\n    }\n\n    /**\n     * remove class names from this element\n     * @param  {string} classes class names to be removed\n     */\n    removeClasses(...classes) {\n        for(let item of classes) {\n            this.$el.removeClass(item);\n        }\n    }\n\n    /**\n     * set attributes of this element\n     * @param {Object} assoc javascript object that will be mapped into attributes (`{key: value}` -> `key=\"value\"`)\n     */\n    addAttr(assoc) {\n        this.checkIfElementExistsInDOM();\n\n        // add attributes to the element\n        this.$el.attr(assoc);\n    }\n\n    /**\n     * get attribute value by name\n     * @param  {string} name name of the attribute\n     * @return {string}      value of the attribute\n     */\n    getAttr(name) {\n        this.checkIfElementExistsInDOM();\n\n        return this.$el.attr(name);\n    }\n\n    /**\n     * remove attribute by value\n     * @param  {string} name name of the attribute to be removed\n     */\n    removeAttr(name) {\n        this.checkIfElementExistsInDOM();\n\n        this.$el.removeAttr(name);\n    }\n\n    /**\n     * set id of this SVG object\n     * @param  {string} id new id for this object\n     */\n    set id(id) {\n        this.addAttr({\"id\": id});\n    }\n\n    /**\n     * get id of this SVG object\n     * @return {string}\n     */\n    get id() {\n        return this.getAttr(\"id\");\n    }\n\n    /**\n     * get jQuery element for this SVG object\n     * @return {jQuery.element}\n     */\n    get() {\n        this.checkIfElementExistsInDOM();\n        return this.$el;\n    }\n\n    /**\n     * check if the element exists in dom, if so, refetch it from DOM using jQuery\n     */\n    checkIfElementExistsInDOM() {\n        let $jqElement = $(\"#\"+this.$el.attr('id'));\n        if($jqElement.length) {\n            this.$el = $jqElement;\n        }\n    }\n}\n\n/**\n * represents visible element in SVG that has position and dimensions (for example `rectangle` is a SvgElement, but `pattern` is not, even though both are tags)\n * @extends Tag\n */\nclass SvgElement extends Tag {\n    /**\n     * @param {number} x       horizontal position in SVG pixels\n     * @param {number} y       vertical position in SVG pixels\n     * @param {number} w       width in SVG pixels\n     * @param {number} h       height in SVG pixels\n     * @param {string} tagName tag name of the element\n     */\n    constructor(x, y, w, h, tagName) {\n        super(tagName);\n\n        this.addAttr({\n            x: x,\n            y: y,\n            width: w,\n            height: h\n        });\n    }\n}\n\n/**\n * a rectangle in SVG\n * @extends SvgElement\n */\nexport class Rectangle extends SvgElement {\n    /**\n     * @param {number} x       horizontal position in SVG pixels\n     * @param {number} y       vertical position in SVG pixels\n     * @param {number} w       width in SVG pixels\n     * @param {number} h       height in SVG pixels\n     * @param {string} fill    filling color of the rectangle\n     * @param {string} stroke  stroke color of the rectangle\n     */\n    constructor(x, y, w, h, fill, stroke) {\n        super(x, y, w, h, \"rect\");\n        this.addAttr({\n            fill: fill,\n            stroke: stroke,\n            'stroke-width': 0.5,\n            'pointer-events': 'all' // to trigger hover even with transparent background\n        });\n    }\n}\n\n/**\n * an image in SVG\n * @extends SvgElement\n */\nexport class SvgImage extends SvgElement {\n    constructor(x, y, w, h, url) {\n        super(x, y, w, h, \"image\");\n        this.addAttr({\n            \"xlink:href\": url\n        });\n    }\n\n    /**\n     * change url of the image\n     * @param {string} url the new url of the image\n     */\n    changeUrl(url) {\n        this.addAttr({\n            \"xlink:href\": url\n        });\n    }\n}\n\n/**\n * SVG group, used for grouping elements, for example a gate is represented by many elements (rectangle, image, inivisible hitbox rectangle...),\n * but all of the elements need to be transformed together. Using groups the transform property can be set on the group which contains all the elements.\n * @extends Tag\n */\nexport class Group extends Tag {\n    constructor() {\n        super(\"g\");\n\n        this.children = [];\n    }\n\n    /**\n     * add an element to the group\n     * @param {SvgElement} el an instance of {@link SvgElement}\n     */\n    addChild(el) {\n        this.children.push(el);\n\n        this.$el.append(el.$el);\n        return el; // pro jednodussi \"let rect = g.addChild(new Rectangle(...\"\n    }\n}\n\n/**\n * one point of {@link PolylinePoints}, used in the {@link PolyLine} object\n */\nexport class PolylinePoint {\n    /**\n     * @param {number} x horizontal coordinate of the polyline point\n     * @param {number} y vertical coordinate of the polyline point\n     */\n    constructor(x, y) {\n        this.x = 0;\n        this.y = 0;\n        if(x !== undefined && y !== undefined) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    /**\n     * change the coordinates of this point\n     * @param {number} x horizontal coordinate of the polyline point\n     * @param {number} y vertical coordinate of the polyline point\n     */\n    set(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * create polyline from a comma separated string (e.g. from a string formatted like this: \"x,y\", for example \"15,8\")\n     * @param  {string} string string in the format \"x,y\" representing a point in the SVG polyline\n     * @return {PolylinePoint} newly created instance of {@link PolylinePoint}\n     */\n    static parseFromString(string) {\n        let arr = string.split(\",\");\n        return new PolylinePoint(arr[0], arr[1]);\n    }\n\n    /**\n     * return a string representation of this polyline point\n     * @return {string} string in the format \"x,y\"\n     */\n    get string() {\n        return this.x + \",\" + this.y;\n    }\n\n    /**\n     * compare polyline points, return `true` if they are equal, else return `false`\n     * @param  {PolylinePoint} a\n     * @param  {PolylinePoint} b\n     * @return {boolean}\n     */\n    static equals(a, b) {\n        return a.x === b.x && a.y === b.y;\n    }\n}\n\n/**\n * array-like structure used in {@link PolylinePoints}\n */\nclass SmartArray {\n    /**\n     * @param {Array} [arr] if set, initialized SmartArray will contain these values\n     */\n    constructor(arr) {\n        if(arr !== undefined) {\n            this.arr = arr;\n        } else {\n            this.arr = [];\n        }\n    }\n\n    /**\n     * get a deep copy of this array\n     * @return {SmartArray}\n     */\n    copy() {\n        return SmartArray($.extend(true, [], this.arr));\n    }\n\n    /**\n     * append an item to the array\n     * @param item new item that will be appended to the array\n     */\n    append(item) {\n        return this.addWithIndex(item, this.arr.length);\n    }\n\n    /**\n     * prepend an item to the array\n     * @param item new item that will be prepended to the array\n     */\n    prepend(item) {\n        return this.addWithIndex(item, 0);\n    }\n\n    /**\n     * add a new item at the specified index, move all following items\n     * @param item new item that will be added at the specified index\n     * @param {number} index index of this item\n     */\n    addWithIndex(item, index) {\n        for(let i = this.arr.length ; i > index ; --i) {\n            this.arr[i] = this.arr[i-1];\n        }\n        this.arr[index] = item;\n        return this; // to enable chaining of append / preppend / addWithIndex commands\n    }\n\n    /**\n     * get length of the array\n     * @return {number}\n     */\n    get length() {\n        return this.arr.length;\n    }\n\n    /**\n     * get item by index\n     * @param  {number} index index of the item\n     * @return contents of the array on the specified index\n     */\n    getItem(index) {\n        return this.arr[index];\n    }\n\n    /**\n     * @return last element of the array\n     */\n    get last() {\n        if(this.length!==0) {\n            return this.arr[this.length - 1];\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @return first element of the array\n     */\n    get first() {\n        if(this.length!==0) {\n            return this.arr[0];\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * remove an item from the array by index\n     * @param  {number} index index of the item that will be removed\n     */\n    remove(index) {\n        let length = this.length;\n\n        for(let i = index ; i < length ; ++i) {\n            this.arr[i] = this.arr[i + 1];\n        }\n        this.arr.pop();\n    }\n}\n\n/**\n * points of the {@link PolyLine}\n * @extends SmartArray\n */\nexport class PolylinePoints extends SmartArray {\n    /**\n     * @param {Array} [arr] array containing instances of {@link PolylinePoint}\n     */\n    constructor(arr) {\n        super(arr);\n    }\n\n    /**\n     * get a deep copy of this object\n     * @return {PolylinePoints}\n     */\n    copy() {\n        return new PolylinePoints($.extend(true, [], this.arr));\n    }\n\n    /**\n     * append a point\n     * @param  {PolylinePoint} point a new point\n     */\n    append(point) {\n        // call inherited function to handle the appending\n        super.append(point);\n\n        // if the second to last point is unnecessary, remove it\n        let length = this.length;\n        if ( length >= 3\n                && (    ( this.getItem(length - 3).x === this.getItem(length - 2).x &&\n                          this.getItem(length - 2).x === this.getItem(length - 1).x )\n                     || ( this.getItem(length - 3).y === this.getItem(length - 2).y &&\n                          this.getItem(length - 2).y === this.getItem(length - 1).y )\n                   )\n           )\n        {\n            this.remove(length - 2);\n        }\n\n        // return this element (to allow chaining)\n        return this;\n    }\n\n    /**\n     * parse polyline from string\n     * @param  {string} string string in the polyline format (`x1,y1 x2,y2, x3,y3`)\n     * @return {PolylinePoints} a new instance of {@link PolylinePoints} created by parsing the string\n     */\n    static parseFromString(string) {\n        let pointStrings = string.split(\" \");\n        let points = new PolylinePoints();\n\n        for(let i = 0 ; i < pointStrings.length ; ++i) {\n            points.append(PolylinePoint.parseFromString(pointStrings[i]));\n        }\n\n        return points;\n    }\n\n    /**\n     * get a string representation of this polyline\n     * @return {string} string in the polyline format (`x1,y1 x2,y2, x3,y3`)\n     */\n    get string() {\n        let string = \"\";\n        for(let i = 0 ; i < this.length ; ++i) {\n            if(i !== 0) {\n                string += \" \";\n            }\n            string += this.arr[i].string;\n        }\n        return string;\n    }\n\n    /**\n     * wrapper for foreach on the polyline points\n     * @param  {Function} func function that will be called on each element\n     */\n    forEach(func) {\n        for(let i = 0 ; i < this.arr.length ; ++i) {\n            func(this.arr[i]);\n        }\n    }\n}\n\n/**\n * SVG polyline (a path defined by sequence of points on plane)\n * @extends Tag\n */\nexport class PolyLine extends Tag {\n    /**\n     * @param {PolylinePoints} points points describing this polyline\n     * @param {number} [strokeWidth] width of the stroke for this polyline in SVG pixels\n     * @param {string} [color] CSS color of this polyline\n     */\n    constructor(points, strokeWidth, color) {\n        super(\"polyline\");\n\n        let attributes = {\n            points: points.string,\n            fill: \"none\",\n            \"stroke-width\": strokeWidth\n        };\n\n        if(color!==undefined) {\n            attributes.stroke = color\n        }\n\n        this.addAttr(attributes);\n    }\n\n    /**\n     * update points of this polyline\n     * @param {PolylinePoints} points new set of points describing this polyline\n     */\n    updatePoints(points) {\n        this.addAttr({\n            points: points.string\n        });\n    }\n}\n\n/**\n * Text element in SVG\n * @extends Tag\n */\nexport class Text extends Tag {\n    /**\n     * @param {number} x       horizontal position in SVG pixels\n     * @param {number} y       vertical position in SVG pixels\n     * @param {number} w       width of the text box in SVG pixels\n     * @param {number} h       height of the text box in SVG pixels\n     * @param {number} text    text content of the text box\n     * @param {string} size    CSS font size of the text\n     * @param {String} [color=\"black\"] color of the text\n     *\n     */\n    constructor(x, y, w, h, text, size, color = \"black\") {\n        super(\"text\");\n        this.addAttr({\n            x: x,\n            y: y,\n            width: w,\n            height: h,\n            fill: color\n        });\n\n        if(size) {\n            this.addAttr({\n                'font-size': size\n            })\n        }\n\n        this.$el.append(text);\n    }\n}\n\n/**\n * Multi line text element in SVG\n *\n * Multi line text is not natively supportend in SVG 1.1,\n * the workaround is to use the <foreignObject> element and display\n * a HTML paragraph inside of the SVG document.\n *\n * Because this technique is not supported by all of the browsers,\n * the foreignObject element is wrapped in <switch>, which\n * provides fallback for those cases.\n *\n * read more: [foreignObject on MDN web docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/foreignObject)\n *\n * @extends Tag\n */\nexport class MultiLineText extends Tag {\n    /**\n     * @param {number} x       horizontal position in SVG pixels\n     * @param {number} y       vertical position in SVG pixels\n     * @param {number} w       width of the text box in SVG pixels\n     * @param {number} h       height of the text box in SVG pixels\n     * @param {number} text    text content of the text box\n     * @param {string} size    CSS font size of the text\n     * @param {String} [color=\"black\"] color of the text\n     *\n     */\n    constructor(x, y, w, h, text, size, color = \"black\") {\n        super(\"switch\");\n\n        let foreignObject = new Tag(\"foreignObject\");\n        let alternativeText = new Text(x, y, w, h, text, size, color);\n\n        foreignObject.addAttr({\n            x,\n            y,\n            width: w,\n            height: h\n        });\n\n        let $wrapper = $(\"<div>\")\n            .attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\")\n            .addClass(\"multilinetext\")\n            .css(\"height\", h);\n\n        let $paragraph = $(\"<p>\")\n            .attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\")\n            .css(\"font-size\", size)\n            .append(text);\n\n        $wrapper.append($paragraph);\n        foreignObject.$el.append($wrapper)\n\n        this.$el.append(\n            foreignObject.$el\n        ).append(\n            alternativeText.$el\n        )\n    }\n\n}\n\n/**\n * pattern object in SVG\n * @extends Tag\n */\nexport class Pattern extends Tag {\n    /**\n     * @param {string} id     unique id of this pattern\n     * @param {number} width  width of one pattern tile in SVG pixels\n     * @param {number} height height of one pattern tile in SVG pixels\n     */\n    constructor(id, width, height) {\n        super(\"pattern\");\n\n        this.addAttr({\n            id: id,\n            x: 0,\n            y: 0,\n            width: width,\n            height: height,\n            patternUnits: \"userSpaceOnUse\",\n            viewBox: \"0 0 \"+width+\" \"+height\n        });\n    }\n\n    /**\n     * add a child to this pattern\n     *\n     * pattern behaves a little like {@link Group} - it contains child elements, which represent the content of one tile of the pattern\n     * and the whole package of the child elements is repeated on each tile of the pattern\n     * @param {SvgElement} el element that will be added to the pattern\n     */\n    addChild(el) {\n        this.$el.append(el.$el);\n        return el;\n    }\n}\n","/** @module Tutorial */\n/**\n * Display and manage the tutorial\n */\nexport default class Tutorial {\n    /**\n     * @param {Canvas} parentSVG instance of [Canvas](./module-Canvas.html) for this tutorial\n     * @param {Function} [onTutorialClosed] callback function when user closes or finishes the tutorial\n     */\n    constructor(parentSVG, onTutorialClosed) {\n        /**\n         * instance of [Canvas](./module-Canvas.html) for this tutorial\n         * @type {Canvas}\n         */\n        this.parentSVG = parentSVG;\n\n        /**\n         * helper variable for the `step` property, stores current state of the tutorial (step `0` means that tutorial is closed)\n         * @type {Number}\n         */\n        this.currentStep = 0;\n\n        /**\n         * jQuery element containing the tutorial popup\n         * @type {jQuery.element}\n         */\n        this.$tutorialWindow;\n        /**\n         * jQuery element for the dynamic part of the tutorial popup\n         * (text and buttons that are dependent on the current state of the tutorial)\n         * @type {Array}\n         */\n        this.$tutorialContent;\n\n        /**\n         * array of functions that represent intividual steps in the tutorial\n         * by default populated with step `0` that closes the tutorial\n         * @type {Array}\n         */\n        this.steps = [() => { this.closeWindow(onTutorialClosed) }];\n\n        // set up the tutorial\n        this.setUpTutorial();\n    }\n\n    /**\n     * get the current step of the tutorial, this number corresponds to the index in the `this.steps` array\n     * that contains the function for the last displayed step\n     * @return {Number}\n     */\n    get step() {\n        return this.currentStep;\n    }\n\n    /**\n     * change the current step of the tutorial, `0` means \"stop the tutorial\"\n     * @param  {Number} value the step of the tutorial to be displayed\n     */\n    set step(value) {\n        this.currentStep = value;\n\n        if(this.step < this.steps.length) {\n            this.steps[this.step]();\n\n            if(this.step === 1)\n                this.displayWindow();\n        } else {\n            this.step = 0;\n        }\n    }\n\n    /**\n     * reset all tutorial hooks\n     */\n    resetHooks() {\n        /**\n         * _tutorial hook_, called when the context menu is opened\n         */\n        this.onContextMenuOpened = () => {};\n\n        /**\n         * _tutorial hook_, called when a new element is added\n         */\n        this.onElementAdded = () => {};\n\n        /**\n         * _tutorial hook_, called when a box is moved\n         */\n        this.onBoxMoved = () => {};\n\n        /**\n         * _tutorial hook_, called when a box is rotated\n         */\n        this.onBoxRotated = () => {};\n\n        /**\n         * _tutorial hook_, called when an output box value is set to `on`\n         */\n        this.onOutputBoxTrue = () => {};\n\n        /**\n         * _tutorial hook_, called when the canvas is moved\n         */\n        this.onCanvasMoved = () => {};\n\n        /**\n         * _tutorial hook_, called when the canvas is zoomed\n         */\n        this.onCanvasZoomed = () => {};\n\n        /**\n         * _tutorial hook_, called when a box is removed\n         */\n        this.onElementRemoved = () => {};\n\n        /**\n         * _tutorial hook_, called when user changes the state of an input box\n         */\n        this.onChangeInputBoxState = () => {};\n    }\n\n    /**\n     * set up the tutorial: reset all tutorial hooks and define the order of tutorial steps\n     */\n    setUpTutorial() {\n        this.resetHooks();\n\n        this.steps.push(\n            () => { this.stepWelcome() },\n            () => { this.stepAddBoxes() },\n            () => { this.stepMoveCanvas() },\n            () => { this.stepZoomCanvas() },\n            () => { this.stepMoveBoxes() },\n            () => { this.stepWiring() },\n            () => { this.switchInputBox() },\n            () => { this.stepRemoveBox() },\n            () => { this.stepFinish() }\n        )\n    }\n\n    /**\n     * _tutorial step_: display context menu\n     */\n    stepWelcome() {\n        this.windowContent(\n            `Welcome to Hradla! To get started, click anywhere on the editing area with your right mouse button.`\n        )\n\n        this.onContextMenuOpened = () => {\n            this.next();\n\n            // this function runs only once\n            this.onContextMenuOpened = () => {}\n        }\n    }\n\n    /**\n     * _tutorial step_: add input box, output box and a NOT gate\n     */\n    stepAddBoxes() {\n        this.windowContent(\n            `Great job! Now you know, how to open the editor menu.\n            Now try to add an <em>Input box</em>, <em>Output box</em> and a <em>NOT gate</em>\n            to the editing area.`)\n\n        let elementsAdded = {\n            inputBox: false,\n            outputBox: false,\n            notGate: false\n        }\n\n        this.onElementAdded = (name) => {\n            switch (name) {\n                case \"input\":\n                    elementsAdded.inputBox = true;\n                    break;\n                case \"output\":\n                    elementsAdded.outputBox = true;\n                    break;\n                case \"not\":\n                    elementsAdded.notGate = true;\n                    break;\n                default:\n                    // no action on default\n                    break;\n            }\n\n            if(elementsAdded.inputBox && elementsAdded.outputBox && elementsAdded.notGate) {\n                // remove the action\n                this.onElementAdded = () => {}\n\n                // proceed to the next step of the tutorial\n                this.next();\n            }\n        };\n    }\n\n    /**\n     * _tutorial step_: move the canvas\n     */\n    stepMoveCanvas() {\n        this.windowContent(\n            `You can move the editing area (sometimes called canvas) by dragging\n            with the middle mouse button or by holding the <code>Ctrl</code> key\n            and dragging with the left mouse button. Check it out.`)\n\n        this.onCanvasMoved = () => {\n            this.next();\n            this.onCanvasMoved = () => {}\n        }\n    }\n\n    /**\n     * _tutorial step_: zoom the canvas\n     */\n    stepZoomCanvas() {\n        this.windowContent(\n            `You can also zoom in and out using <code>Ctrl</code> and the mouse wheel.`\n        )\n\n        this.onCanvasZoomed = () => {\n            this.next();\n            this.onCanvasZoomed = () => {};\n        }\n    }\n\n    /**\n     * _tutorial step_: move the boxes\n     */\n    stepMoveBoxes() {\n        this.windowContent(`You can move the elements on the editing canvas by dragging them\n            using the left mouse button. You can also rotate them using middle click. Try it out.`)\n\n        let boxMoved = false;\n        let boxRotated = false;\n\n        let moveRotateCallback = () => {\n            if(boxMoved && boxRotated) {\n                this.next();\n            }\n        }\n\n        this.onBoxMoved = () => {\n            boxMoved = true;\n\n            this.onBoxMoved = () => {}\n\n            moveRotateCallback()\n        }\n\n        this.onBoxRotated = () => {\n            boxRotated = true;\n\n            this.onBoxRotated = () => {}\n\n            moveRotateCallback()\n        }\n    }\n\n    /**\n     * _tutorial step_: create an invertor\n     */\n    stepWiring() {\n        this.windowContent(`Essential part of logic networks is the wiring. Create a very simple\n            inverter by connecting the <em>Input box</em> to the input of the <em>NOT gate</em>\n            and the output of the <em>NOT gate</em> to the input of the <em>Output box</em>.`,\n            `To connect two elemnts, simply click on a connector of the first element,\n            than click on a conector of the second element.`)\n\n        this.onOutputBoxTrue = () => {\n            this.next();\n\n            this.onOutputBoxTrue = () => {};\n        };\n    }\n\n    /**\n     * _tutorial step_: change the state of an input box\n     */\n    switchInputBox() {\n        this.windowContent(`\n            The input boxes can be in two states: <em>ON</em> and <em>OFF</em>, signalled\n            by the green and red colors respectively. You can left click on an Input box to\n            switch its state. Try it out!\n        `)\n\n        this.onChangeInputBoxState = () => {\n            this.next();\n\n            this.onChangeInputBoxState = () => {};\n        };\n    }\n\n    /**\n     * _tutorial step_: remove a box\n     */\n    stepRemoveBox() {\n        this.windowContent(\n            `When you right click on an element, you can find a new item in the menu,\n            that allows you to remove the element. This works for wires as well as for gates and other types of boxes.\n            Try to remove an element!`\n        )\n\n        this.onElementRemoved = () => {\n            this.next();\n\n            this.onElementRemoved = () => {};\n        }\n    }\n\n    /**\n     * _tutorial step_: ask the user if they want to clean the canvas before closing the tutorial\n     */\n    stepFinish() {\n        this.windowContent(`You're all set, enjoy your stay!`,\n                           `Do you wish to start with empty canvas?`)\n        this.windowChoice(\n            {\n                text: 'yes, clean the canvas',\n                func: () => {\n                    this.parentSVG.cleanCanvas();\n                    this.stop();\n                }\n            },\n            {\n                text: 'no, keep the canvas as it is',\n                func: () => {\n                    this.stop();\n                }\n            }\n        )\n    }\n\n    /**\n     * display the tutorial window\n     */\n    displayWindow() {\n        this.parentSVG.$svg.after(this.$tutorialWindow)\n    }\n\n    /**\n     * close the tutorial window\n     * @param  {Function} [onTutorialClosed] callback function that is called when the tutorial is closed\n     */\n    closeWindow(onTutorialClosed) {\n        this.$tutorialWindow.remove();\n\n        if(onTutorialClosed!==undefined) {\n            onTutorialClosed();\n        }\n    }\n\n    /**\n     * set the tutorial window text content\n     * @param  {...string} text each string is a separate paragraph\n     */\n    windowContent(...text) {\n        if(!this.$tutorialWindow) {\n            this.$tutorialWindow = $(\"<div>\").attr(\"id\", \"tutorial\");\n            this.$tutorialWindow.append(\n                $(\"<div>\").addClass(\"topButtons\").append(\n                    $(\"<a>\").attr(\"href\", \"#\").addClass(\"button close\")\n                    .click(() => {\n                        this.stop();\n                    })\n                )\n            )\n\n            this.$tutorialContent = $(\"<div>\").addClass(\"content\");\n            this.$tutorialWindow.append(this.$tutorialContent);\n        }\n\n        this.$tutorialContent.html(\"\");\n        for (const paragraph of text) {\n            this.$tutorialContent.append(\n                $(\"<p>\").html(paragraph)\n            );\n        }\n    }\n\n    /**\n     * add buttons with choices to the tutorial window\n     * @param  {...object} choices each choice is an object in with a `string` property _text_ and a `function` property _func_\n     */\n    windowChoice(...choices) {\n        let $choices = $(\"<ol>\").addClass(\"choices\");\n        for (const choice of choices) {\n            $choices.append(\n                $(\"<li>\").append(\n                    $(\"<a>\").attr(\"href\", \"#\").click(() => {\n                        choice.func()\n                    }).html(choice.text)\n                )\n            )\n        }\n        this.$tutorialContent.append($choices);\n    }\n\n    /**\n     * start the tutorial\n     */\n    start() { this.step = 1; }\n\n    /**\n     * go to the next step of the tutorial\n     */\n    next() { this.step++; }\n\n    /**\n     * stop the tutorial\n     */\n    stop() { this.step = 0 }\n}\n","/** @module ViewBox */\n/**\n * ViewBox provides an api for oprerating with the viewBox argument of the <svg> DOM element.\n */\nexport default class ViewBox {\n    /**\n     * Initialize viewBox\n     * @param {number} left   distance of the left edge of the viewbox from document's y axis in SVG pixels\n     * @param {number} top    distance of the top edge of the viewbox from the document's x axis in SVG pixels\n     * @param {number} width  width of the viewbox in SVG pixels\n     * @param {number} height height of the viewbox in SVG pixels\n     */\n    constructor(left, top, width, height) {\n        /**\n         * ViewBox attributes before applying zoom and shift\n         * @type {object}\n         */\n        this.real = { left, top, width, height }\n\n        /**\n         * The maximum amount of zoom on the viewbox\n         * @type {number}\n         */\n        this.maxZoom = 8;\n        /**\n         * The minimum amount of zoom on the viewbox\n         * @type {number}\n         */\n        this.minZoom = 0.1;\n\n        /**\n         * Amount of zoom on the viewbox, always between this.minZoom and this.maxZoom\n         * @type {number}\n         */\n        this.realZoom = 1\n\n        /**\n         * amount of horizontal shift of the document\n         * @type {number}\n         */\n        this.leftShift = 0\n        /**\n         * amount of vertical shift of the document\n         * @type {number}\n         */\n        this.topShift = 0\n    }\n\n    /**\n     * update the dimensions of the viewbox (used on window resize)\n     * @param  {Number} width  new width of the viewbox in SVG pixels\n     * @param  {Number} height new height of the viewbox in SVG pixels\n     */\n    newDimensions(width, height) {\n        // keep the viewbox centered\n        this.real.left += (this.real.width - width)/2\n        this.real.top += (this.real.height - height)/2\n\n        // update the dimensions\n        this.real.width = width;\n        this.real.height = height;\n    }\n\n    /**\n     * get the amount of zoom on the viewbox\n     * @return {number}\n     */\n    get zoom() {\n        return this.realZoom;\n    }\n\n    /**\n     * set the amount of zoom on the viewbox\n     * @param {number} value the new amount of zoom\n     */\n    set zoom(value) {\n        // fit this.realZoom to fit between this.minZoom and this.maxZoom\n        this.realZoom = Math.max(Math.min(value, this.maxZoom), this.minZoom);\n    }\n\n    /**\n     * get the width of the viewbox with the current zoom applied\n     * @return {number} the final width of the viewbox\n     */\n    get width() {\n        return this.real.width / this.zoom\n    }\n\n    /**\n     * get the height of the viewbox with the current zoom applied\n     * @return {number} the final height of the viewbox\n     */\n    get height() {\n        return this.real.height / this.zoom\n    }\n\n    /**\n     * get the horizontal distance from the y axis of the document with zoom and shift value applied\n     * @return {number}\n     */\n    get left() {\n        return this.real.left - (this.leftShift / this.zoom) + ((this.real.width - this.width) / 2)\n    }\n\n    /**\n     * get the vertical distance from the x axis of the document with zoom and shift value applied\n     * @return {number}\n     */\n    get top() {\n        return this.real.top - (this.topShift / this.zoom) + ((this.real.height - this.height) / 2)\n    }\n\n    /**\n     * get the computed viewbox values as a string in the correct format that can be used in the viewBox attribute of the SVG element\n     * @return {string} string in format \"left top width height\"\n     */\n    get str() {\n        return `${this.left} ${this.top} ${this.width} ${this.height}`\n    }\n\n    /**\n     * transform horizontal units to the scale and shift of the editor\n     * @param  {number} x original horizontal value\n     * @return {number}   transformed horizontal value\n     */\n    transformX(x) {\n        return this.left + (x / this.zoom)\n    }\n\n    /**\n     * transform vertical units to the scale and shift of the editor\n     * @param  {number} y original vertical value\n     * @return {number}   transformed vertical value\n     */\n    transformY(y) {\n        return this.top + (y / this.zoom)\n    }\n\n    /**\n     * transform pageX and pageY parameters of the jquery event to match the zoom and shift of the viewbox\n     * @param  {jquery.MouseEvent} event original event\n     * @return {jquery.MouseEvent}       the same event but with transformed pageX and pageY members\n     */\n    transformEvent(event) {\n        event.pageX = this.transformX(event.pageX)\n        event.pageY = this.transformY(event.pageY)\n\n        return event\n    }\n}\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvanNvbi1zdHJpbmdpZnktcHJldHR5LWNvbXBhY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL0RvdWJseUxpbmtlZExpc3QuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL0hlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL01heEhlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL01pbkhlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL1ByaW9yaXR5UXVldWUuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL1F1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL2xpYnN0bC9EYXRhc3RydWN0dXJlcy9TdGFjay5qcyIsIm5vZGVfbW9kdWxlcy9saWJzdGwvbm9kZS1tb2R1bGUuanMiLCJzcmMvZXM2L2NhbnZhcy5qcyIsInNyYy9lczYvY29udGV4dE1lbnUuanMiLCJzcmMvZXM2L2VkaXRvckVsZW1lbnRzLmpzIiwic3JjL2VzNi9maW5kUGF0aC5qcyIsInNyYy9lczYvZmxvYXRpbmdNZW51LmpzIiwic3JjL2VzNi9oZWxwZXJGdW5jdGlvbnMuanMiLCJzcmMvZXM2L2lkLmpzIiwic3JjL2VzNi9sb2dpYy5qcyIsInNyYy9lczYvbWFpbi5qcyIsInNyYy9lczYvbWFwV2l0aERlZmF1bHRWYWx1ZS5qcyIsInNyYy9lczYvbWVzc2FnZXMuanMiLCJzcmMvZXM2L25ldHdvcmtMaWJyYXJ5LmpzIiwic3JjL2VzNi9zaW11bGF0aW9uLmpzIiwic3JjL2VzNi9zdmdPYmplY3RzLmpzIiwic3JjL2VzNi90dXRvcmlhbC5qcyIsInNyYy9lczYvdmlld2JveC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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S0FBTixHQUFjLEtBQUssVUFBTCxDQUFnQixNQUFNLEtBQXRCLENBQWQ7QUFDQSxZQUFNLEtBQU4sR0FBYyxLQUFLLFVBQUwsQ0FBZ0IsTUFBTSxLQUF0QixDQUFkOztBQUVBLGFBQU8sS0FBUDtBQUNIOzs7d0JBakZVO0FBQ1AsYUFBTyxLQUFLLFFBQVo7QUFDSDs7QUFFRDs7Ozs7c0JBSVMsSyxFQUFPO0FBQ1o7QUFDQSxXQUFLLFFBQUwsR0FBZ0IsS0FBSyxHQUFMLENBQVMsS0FBSyxHQUFMLENBQVMsS0FBVCxFQUFnQixLQUFLLE9BQXJCLENBQVQsRUFBd0MsS0FBSyxPQUE3QyxDQUFoQjtBQUNIOztBQUVEOzs7Ozs7O3dCQUlZO0FBQ1IsYUFBTyxLQUFLLElBQUwsQ0FBVSxLQUFWLEdBQWtCLEtBQUssSUFBOUI7QUFDSDs7QUFFRDs7Ozs7Ozt3QkFJYTtBQUNULGFBQU8sS0FBSyxJQUFMLENBQVUsTUFBVixHQUFtQixLQUFLLElBQS9CO0FBQ0g7O0FBRUQ7Ozs7Ozs7d0JBSVc7QUFDUCxhQUFPLEtBQUssSUFBTCxDQUFVLElBQVYsR0FBa0IsS0FBSyxTQUFMLEdBQWlCLEtBQUssSUFBeEMsR0FBaUQsQ0FBQyxLQUFLLElBQUwsQ0FBVSxLQUFWLEdBQWtCLEtBQUssS0FBeEIsSUFBaUMsQ0FBekY7QUFDSDs7QUFFRDs7Ozs7Ozt3QkFJVTtBQUNOLGFBQU8sS0FBSyxJQUFMLENBQVUsR0FBVixHQUFpQixLQUFLLFFBQUwsR0FBZ0IsS0FBSyxJQUF0QyxHQUErQyxDQUFDLEtBQUssSUFBTCxDQUFVLE1BQVYsR0FBbUIsS0FBSyxNQUF6QixJQUFtQyxDQUF6RjtBQUNIOztBQUVEOzs7Ozs7O3dCQUlVO0FBQ04sYUFBVSxLQUFLLElBQWYsU0FBdUIsS0FBSyxHQUE1QixTQUFtQyxLQUFLLEtBQXhDLFNBQWlELEtBQUssTUFBdEQ7QUFDSDs7Ozs7O2tCQWxIZ0IsTyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9cmV0dXJuIGV9KSgpIiwiZnVuY3Rpb24gc3RyaW5naWZ5IChvYmosIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGluZGVudCA9IEpTT04uc3RyaW5naWZ5KFsxXSwgbnVsbCwgZ2V0KG9wdGlvbnMsICdpbmRlbnQnLCAyKSkuc2xpY2UoMiwgLTMpXG4gIHZhciBhZGRNYXJnaW4gPSBnZXQob3B0aW9ucywgJ21hcmdpbnMnLCBmYWxzZSlcbiAgdmFyIG1heExlbmd0aCA9IChpbmRlbnQgPT09ICcnID8gSW5maW5pdHkgOiBnZXQob3B0aW9ucywgJ21heExlbmd0aCcsIDgwKSlcblxuICByZXR1cm4gKGZ1bmN0aW9uIF9zdHJpbmdpZnkgKG9iaiwgY3VycmVudEluZGVudCwgcmVzZXJ2ZWQpIHtcbiAgICBpZiAob2JqICYmIHR5cGVvZiBvYmoudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvYmogPSBvYmoudG9KU09OKClcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkob2JqKVxuXG4gICAgaWYgKHN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gc3RyaW5nXG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IG1heExlbmd0aCAtIGN1cnJlbnRJbmRlbnQubGVuZ3RoIC0gcmVzZXJ2ZWRcblxuICAgIGlmIChzdHJpbmcubGVuZ3RoIDw9IGxlbmd0aCkge1xuICAgICAgdmFyIHByZXR0aWZpZWQgPSBwcmV0dGlmeShzdHJpbmcsIGFkZE1hcmdpbilcbiAgICAgIGlmIChwcmV0dGlmaWVkLmxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHByZXR0aWZpZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV4dEluZGVudCA9IGN1cnJlbnRJbmRlbnQgKyBpbmRlbnRcbiAgICAgIHZhciBpdGVtcyA9IFtdXG4gICAgICB2YXIgZGVsaW1pdGVyc1xuICAgICAgdmFyIGNvbW1hID0gZnVuY3Rpb24gKGFycmF5LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gKGluZGV4ID09PSBhcnJheS5sZW5ndGggLSAxID8gMCA6IDEpXG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IG9iai5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKFxuICAgICAgICAgICAgX3N0cmluZ2lmeShvYmpbaW5kZXhdLCBuZXh0SW5kZW50LCBjb21tYShvYmosIGluZGV4KSkgfHwgJ251bGwnXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGRlbGltaXRlcnMgPSAnW10nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgdmFyIGtleVBhcnQgPSBKU09OLnN0cmluZ2lmeShrZXkpICsgJzogJ1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9zdHJpbmdpZnkob2JqW2tleV0sIG5leHRJbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXJ0Lmxlbmd0aCArIGNvbW1hKGFycmF5LCBpbmRleCkpXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goa2V5UGFydCArIHZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgZGVsaW1pdGVycyA9ICd7fSdcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBkZWxpbWl0ZXJzWzBdLFxuICAgICAgICAgIGluZGVudCArIGl0ZW1zLmpvaW4oJyxcXG4nICsgbmV4dEluZGVudCksXG4gICAgICAgICAgZGVsaW1pdGVyc1sxXVxuICAgICAgICBdLmpvaW4oJ1xcbicgKyBjdXJyZW50SW5kZW50KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdcbiAgfShvYmosICcnLCAwKSlcbn1cblxuLy8gTm90ZTogVGhpcyByZWdleCBtYXRjaGVzIGV2ZW4gaW52YWxpZCBKU09OIHN0cmluZ3MsIGJ1dCBzaW5jZSB3ZeKAmXJlXG4vLyB3b3JraW5nIG9uIHRoZSBvdXRwdXQgb2YgYEpTT04uc3RyaW5naWZ5YCB3ZSBrbm93IHRoYXQgb25seSB2YWxpZCBzdHJpbmdzXG4vLyBhcmUgcHJlc2VudCAodW5sZXNzIHRoZSB1c2VyIHN1cHBsaWVkIGEgd2VpcmQgYG9wdGlvbnMuaW5kZW50YCBidXQgaW5cbi8vIHRoYXQgY2FzZSB3ZSBkb27igJl0IGNhcmUgc2luY2UgdGhlIG91dHB1dCB3b3VsZCBiZSBpbnZhbGlkIGFueXdheSkuXG52YXIgc3RyaW5nT3JDaGFyID0gLyhcIig/OlteXFxcXFwiXXxcXFxcLikqXCIpfFs6LFxcXVt9e10vZ1xuXG5mdW5jdGlvbiBwcmV0dGlmeSAoc3RyaW5nLCBhZGRNYXJnaW4pIHtcbiAgdmFyIG0gPSBhZGRNYXJnaW4gPyAnICcgOiAnJ1xuICB2YXIgdG9rZW5zID0ge1xuICAgICd7JzogJ3snICsgbSxcbiAgICAnWyc6ICdbJyArIG0sXG4gICAgJ30nOiBtICsgJ30nLFxuICAgICddJzogbSArICddJyxcbiAgICAnLCc6ICcsICcsXG4gICAgJzonOiAnOiAnXG4gIH1cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHN0cmluZ09yQ2hhciwgZnVuY3Rpb24gKG1hdGNoLCBzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nID8gbWF0Y2ggOiB0b2tlbnNbbWF0Y2hdXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldCAob3B0aW9ucywgbmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiAobmFtZSBpbiBvcHRpb25zID8gb3B0aW9uc1tuYW1lXSA6IGRlZmF1bHRWYWx1ZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZnlcbiIsIi8qKlxuICogVGhlIERvdWJseUxpbmtlZExpc3QgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIGRvdWJseSBsaW5rZWQgbGlzdC5cbiAqXG4gKiBAY2xhc3MgRG91Ymx5TGlua2VkTGlzdFxuICovXG52YXIgRG91Ymx5TGlua2VkTGlzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG91Ymx5TGlua2VkTGlzdCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvdW50IG9mIGVsZW1lbnRzIGluIGxpc3RcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IF9sZW5ndGhcbiAgICAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogSXRlcmF0aW9uIHBvaW50ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IF9rZXlcbiAgICAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9rZXkgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGhlYWQoZmlyc3QpIGVsZW1lbnQgaW4gbGlzdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX2hlYWRcbiAgICAgICAgICogQHR5cGUgRG91Ymx5TGlua2VkTGlzdE5vZGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRhaWwobGFzdCkgZWxlbWVudCBpbiBsaXN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfdGFpbFxuICAgICAgICAgKiBAdHlwZSBEb3VibHlMaW5rZWRMaXN0Tm9kZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGFpbCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gaXRlcmF0ZWQgZWxlbWVudCBpbiBsaXN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfY3VycmVudFxuICAgICAgICAgKiBAdHlwZSBEb3VibHlMaW5rZWRMaXN0Tm9kZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG5ldyB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZFxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggd2hlcmUgdGhlIG5ldyB2YWx1ZSBpcyB0byBiZSBpbnNlcnRlZC5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIGluZGV4LlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk91dCBvZiBib3VuZHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHdoaWxlIChpIDwgaW5kZXgpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudC52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUG9wcyBhIG5vZGUgZnJvbSB0aGUgZW5kIG9mIHRoZSBkb3VibHkgbGlua2VkIGxpc3RcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcG9wXG4gICAgICogQHJldHVybiBhbnkgIFRoZSB2YWx1ZSBvZiB0aGUgcG9wcGVkIG5vZGUuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwb3AgZnJvbSBhbiBlbXB0eSBkYXRhIHN0cnVjdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl90YWlsLnZhbHVlO1xuICAgICAgICB0aGlzLl90YWlsID0gdGhpcy5fdGFpbC5wcmV2O1xuICAgICAgICBpZiAodGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3RhaWwubmV4dDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwubmV4dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGVuZ3RoLS07XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2hpZnRzIGEgbm9kZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRvdWJseSBsaW5rZWQgbGlzdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBzaGlmdFxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIHNoaWZ0ZWQgbm9kZS5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc2hpZnQgZnJvbSBhbiBlbXB0eSBkYXRhIHN0cnVjdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9oZWFkLnZhbHVlO1xuICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5faGVhZC5uZXh0O1xuICAgICAgICBpZiAodGhpcy5faGVhZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWQucHJldjtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGVuZ3RoLS07XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhbiBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGRvdWJseSBsaW5rZWQgbGlzdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBwdXNoXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBwdXNoLlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gYWxsb2NhdGUgbmV3IG5vZGVcbiAgICAgICAgdmFyIG5vZGUgPSB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBwcmV2OiB0aGlzLl90YWlsLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5fdGFpbCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90YWlsLm5leHQgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHRoaXMuX3RhaWwubmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sZW5ndGgrKztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByZXBlbmRzIHRoZSBkb3VibHkgbGlua2VkIGxpc3Qgd2l0aCBhbiBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHVuc2hpZnRcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHVuc2hpZnQuXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBhbGxvY2F0ZSBuZXcgbm9kZVxuICAgICAgICB2YXIgbm9kZSA9IHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHByZXY6IG51bGwsXG4gICAgICAgICAgICBuZXh0OiB0aGlzLl9oZWFkXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB0aGlzLl90YWlsID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldiA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5faGVhZC5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xlbmd0aCsrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVla3MgYXQgdGhlIG5vZGUgZnJvbSB0aGUgZW5kIG9mIHRoZSBkb3VibHkgbGlua2VkIGxpc3RcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9wXG4gICAgICogQHJldHVybiBhbnkgIFRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBub2RlLlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhaWwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFpbC52YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlZWtzIGF0IHRoZSBub2RlIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZG91Ymx5IGxpbmtlZCBsaXN0XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGJvdHRvbVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IG5vZGUuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUuYm90dG9tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faGVhZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkLnZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ291bnRzIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGRvdWJseSBsaW5rZWQgbGlzdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBjb3VudFxuICAgICAqIEByZXR1cm4gbnVtYmVyIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGRvdWJseSBsaW5rZWQgbGlzdC5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBkb3VibHkgbGlua2VkIGxpc3QgaXMgZW1wdHlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNFbXB0eVxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB3aGV0aGVyIHRoZSBkb3VibHkgbGlua2VkIGxpc3QgaXMgZW1wdHkuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9sZW5ndGggPT09IDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV3aW5kIGl0ZXJhdG9yIGJhY2sgdG8gdGhlIHN0YXJ0XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJld2luZFxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnJld2luZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fa2V5ID0gMDtcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gY3VycmVudCBsaXN0IGVudHJ5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGN1cnJlbnRcbiAgICAgKiBAcmV0dXJuIGFueSAgVGhlIGN1cnJlbnQgbm9kZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gY3VycmVudCBub2RlIGluZGV4XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGtleVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgY3VycmVudCBub2RlIGluZGV4LlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmUgdG8gbmV4dCBlbnRyeVxuICAgICAqXG4gICAgICogQG1ldGhvZCBuZXh0XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2N1cnJlbnQubmV4dDtcbiAgICAgICAgdGhpcy5fa2V5Kys7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIHByZXZpb3VzIGVudHJ5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHByZXZcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudC5wcmV2O1xuICAgICAgICB0aGlzLl9rZXktLTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGRvdWJseSBsaW5rZWQgbGlzdCBjb250YWlucyBtb3JlIG5vZGVzXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHZhbGlkXG4gICAgICogQHJldHVybiBib29sZWFuIHRydWUgaWYgdGhlIGRvdWJseSBsaW5rZWQgbGlzdCBjb250YWlucyBhbnkgbW9yZSBub2RlcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnZhbGlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2tleSA+PSAwICYmIHRoaXMuX2tleSA8IHRoaXMuX2xlbmd0aCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeHBvcnQgdGhlIGxpc3QgdG8gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9BcnJheVxuICAgICAqIEByZXR1cm4gQXJyYXkgICBUaGUgZXhwb3J0ZWQgYXJyYXlcbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goY3VycmVudC52YWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgbGlzdCB0byBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9TdHJpbmdcbiAgICAgKiBAcmV0dXJuIHN0cmluZyAgIFRoZSBzZXJpYWxpemVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgdGhpcy50b0FycmF5KCkuam9pbihcIi0+XCIpICsgXCJ9XCI7XG4gICAgfTtcbiAgICByZXR1cm4gRG91Ymx5TGlua2VkTGlzdDtcbn0pKCk7XG5tb2R1bGUuZXhwb3J0cyA9IERvdWJseUxpbmtlZExpc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Eb3VibHlMaW5rZWRMaXN0LmpzLm1hcCIsIi8qKlxuICogVGhlIEhlYXAgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIEhlYXAuXG4gKlxuICogQGNsYXNzIEhlYXBcbiAqL1xudmFyIEhlYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhlYXAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5hcnkgdHJlZSBzdG9yYWdlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfdHJlZVxuICAgICAgICAgKiBAdHlwZSBBcnJheVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHJlZSA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGVhcCB0eXBlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfdHlwZVxuICAgICAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3R5cGUgPSBIZWFwLk1BWDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGlvbiBwb2ludGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfa2V5XG4gICAgICAgICAqIEB0eXBlIG51bWJlclxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fa2V5ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGluZGV4IG9mIGxlZnQgY2hpbGQgZWxlbWVudCBpbiBiaW5hcnkgdHJlZSBzdG9yZWQgaW4gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2NoaWxkXG4gICAgICogQHBhcmFtIG5cbiAgICAgKiBAcmV0dXJuIG51bWJlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuX2NoaWxkID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIDIgKiBuICsgMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBpbmRleCBvZiBwYXJlbnQgZWxlbWVudCBpbiBiaW5hcnkgdHJlZSBzdG9yZWQgaW4gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3BhcmVudFxuICAgICAqIEBwYXJhbSBuXG4gICAgICogQHJldHVybiBudW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9wYXJlbnQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCduPScsIG4sIE1hdGguZmxvb3IobiAvIDIpKTtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobiAvIDIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3dhcCAyIGVsZW1lbnRzIGluIGJpbmFyeSB0cmVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9zd2FwXG4gICAgICogQHBhcmFtIGZpcnN0XG4gICAgICogQHBhcmFtIHNlY29uZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuX3N3YXAgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICB2YXIgc3dhcCA9IHRoaXMuX3RyZWVbZmlyc3RdO1xuICAgICAgICB0aGlzLl90cmVlW2ZpcnN0XSA9IHRoaXMuX3RyZWVbc2Vjb25kXTtcbiAgICAgICAgdGhpcy5fdHJlZVtzZWNvbmRdID0gc3dhcDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNpZnQgZWxlbWVudHMgaW4gYmluYXJ5IHRyZWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3NpZnRVcFxuICAgICAqIEBwYXJhbSBpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5fc2lmdFVwID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50KGkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZSh0aGlzLl90cmVlW2ldLCB0aGlzLl90cmVlW3BhcmVudF0pICogdGhpcy5fdHlwZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zd2FwKGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgaSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaWZ0IGRvd24gZWxlbWVudHMgaW4gYmluYXJ5IHRyZWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3NpZnREb3duXG4gICAgICogQHBhcmFtIGlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9zaWZ0RG93biA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5fdHJlZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5fY2hpbGQoaSk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIGlmICgobGVmdCA8IHRoaXMuX3RyZWUubGVuZ3RoKSAmJiAocmlnaHQgPCB0aGlzLl90cmVlLmxlbmd0aCkgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5jb21wYXJlKHRoaXMuX3RyZWVbaV0sIHRoaXMuX3RyZWVbbGVmdF0pICogdGhpcy5fdHlwZSA8IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wYXJlKHRoaXMuX3RyZWVbaV0sIHRoaXMuX3RyZWVbcmlnaHRdKSAqIHRoaXMuX3R5cGUgPCAwKSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIDIgY2hpbGRyZW4gYW5kIG9uZSBvZiB0aGVtIG11c3QgYmUgc3dhcHBlZFxuICAgICAgICAgICAgICAgIC8vIGdldCBjb3JyZWN0IGVsZW1lbnQgdG8gc2lmdCBkb3duXG4gICAgICAgICAgICAgICAgdmFyIHNpZnQgPSBsZWZ0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmUodGhpcy5fdHJlZVtsZWZ0XSwgdGhpcy5fdHJlZVtyaWdodF0pICogdGhpcy5fdHlwZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2lmdCA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zd2FwKGksIHNpZnQpO1xuICAgICAgICAgICAgICAgIGkgPSBzaWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVmdCA8IHRoaXMuX3RyZWUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wYXJlKHRoaXMuX3RyZWVbaV0sIHRoaXMuX3RyZWVbbGVmdF0pICogdGhpcy5fdHlwZSA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IG9uZSBjaGlsZCBleGlzdHNcbiAgICAgICAgICAgICAgICB0aGlzLl9zd2FwKGksIGxlZnQpO1xuICAgICAgICAgICAgICAgIGkgPSBsZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIGEgbm9kZSBmcm9tIHRvcCBvZiB0aGUgaGVhcCBhbmQgc2lmdCB1cFxuICAgICAqXG4gICAgICogQG1ldGhvZCBleHRyYWN0XG4gICAgICogQHJldHVybiBhbnkgVGhlIHZhbHVlIG9mIHRoZSBleHRyYWN0ZWQgbm9kZS5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJlZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGV4dHJhY3QgZnJvbSBhbiBlbXB0eSBkYXRhIHN0cnVjdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXh0cmFjdGVkID0gdGhpcy5fdHJlZVswXTtcbiAgICAgICAgaWYgKHRoaXMuX3RyZWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl90cmVlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmVlWzBdID0gdGhpcy5fdHJlZS5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX3NpZnREb3duKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRyYWN0ZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIGVsZW1lbnQgaW4gdGhlIGhlYXAgYnkgc2lmdGluZyBpdCB1cFxuICAgICAqXG4gICAgICogQG1ldGhvZCBpbnNlcnRcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdHJlZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fc2lmdFVwKHRoaXMuX3RyZWUubGVuZ3RoIC0gMSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQZWVrcyBhdCB0aGUgbm9kZSBmcm9tIHRoZSB0b3Agb2YgdGhlIGhlYXBcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9wXG4gICAgICogQHJldHVybiBhbnkgVGhlIHZhbHVlIG9mIHRoZSBub2RlIG9uIHRoZSB0b3AuXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUudG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJlZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlZWsgYXQgYW4gZW1wdHkgaGVhcFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdHJlZVswXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNvdW50XG4gICAgICogQHJldHVybiBudW1iZXIgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcC5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWUubGVuZ3RoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGhlYXAgaXMgZW1wdHlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNFbXB0eVxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB3aGV0aGVyIHRoZSBoZWFwIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fdHJlZS5sZW5ndGggPT09IDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV3aW5kIGl0ZXJhdG9yIGJhY2sgdG8gdGhlIHN0YXJ0IChuby1vcClcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmV3aW5kXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUucmV3aW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9rZXkgPSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGN1cnJlbnQgbm9kZSBwb2ludGVkIGJ5IHRoZSBpdGVyYXRvclxuICAgICAqXG4gICAgICogQG1ldGhvZCBjdXJyZW50XG4gICAgICogQHJldHVybiBhbnkgVGhlIGN1cnJlbnQgbm9kZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJlZVt0aGlzLl9rZXldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGN1cnJlbnQgbm9kZSBpbmRleFxuICAgICAqXG4gICAgICogQG1ldGhvZCBrZXlcbiAgICAgKiBAcmV0dXJuIGFueSBUaGUgY3VycmVudCBub2RlIGluZGV4LlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmUgdG8gdGhlIG5leHQgbm9kZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBuZXh0XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fa2V5Kys7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIHByZXZpb3VzIGVudHJ5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHByZXZcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9rZXktLTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGhlYXAgY29udGFpbnMgbW9yZSBub2Rlc1xuICAgICAqXG4gICAgICogQG1ldGhvZCB2YWxpZFxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB0cnVlIGlmIHRoZSBoZWFwIGNvbnRhaW5zIGFueSBtb3JlIG5vZGVzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUudmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fa2V5ID49IDAgJiYgdGhpcy5fa2V5IDwgdGhpcy5fdHJlZS5sZW5ndGgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSBlbGVtZW50cyBpbiBvcmRlciB0byBwbGFjZSB0aGVtIGNvcnJlY3RseSBpbiB0aGUgaGVhcCB3aGlsZSBzaWZ0aW5nIHVwLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjb21wYXJlXG4gICAgICogQHBhcmFtIGZpcnN0IFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3Qgbm9kZSBiZWluZyBjb21wYXJlZC5cbiAgICAgKiBAcGFyYW0gc2Vjb25kIFRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIG5vZGUgYmVpbmcgY29tcGFyZWQuXG4gICAgICogQHJldHVybiBudW1iZXIgUmVzdWx0IG9mIHRoZSBjb21wYXJpc29uLCBwb3NpdGl2ZSBpbnRlZ2VyIGlmIGZpcnN0IGlzIGdyZWF0ZXIgdGhhbiBzZWNvbmQsIDAgaWYgdGhleSBhcmUgZXF1YWwsIG5lZ2F0aXZlIGludGVnZXIgb3RoZXJ3aXNlLlxuICAgICAqIEhhdmluZyBtdWx0aXBsZSBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIHZhbHVlIGluIGEgSGVhcCBpcyBub3QgcmVjb21tZW5kZWQuIFRoZXkgd2lsbCBlbmQgdXAgaW4gYW4gYXJiaXRyYXJ5IHJlbGF0aXZlIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICBpZiAoZmlyc3QgPiBzZWNvbmQpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpcnN0ID09IHNlY29uZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFZpc3VhbGx5IGRpc3BsYXkgaGVhcCB0cmVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9kaXNwbGF5Tm9kZVxuICAgICAqIEBwYXJhbSBub2RlXG4gICAgICogQHBhcmFtIHByZWZpeFxuICAgICAqIEBwYXJhbSBsYXN0XG4gICAgICogQHJldHVybiBTdHJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9kaXNwbGF5Tm9kZSA9IGZ1bmN0aW9uIChub2RlLCBwcmVmaXgsIGxhc3QpIHtcbiAgICAgICAgaWYgKHByZWZpeCA9PT0gdm9pZCAwKSB7IHByZWZpeCA9ICcnOyB9XG4gICAgICAgIGlmIChsYXN0ID09PSB2b2lkIDApIHsgbGFzdCA9IHRydWU7IH1cbiAgICAgICAgdmFyIGxpbmUgPSBwcmVmaXg7XG4gICAgICAgIC8vIGdldCBjaGlsZCBpbmRleGVzXG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5fY2hpbGQobm9kZSk7XG4gICAgICAgIHZhciByaWdodCA9IGxlZnQgKyAxO1xuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgbGluZSArPSAocHJlZml4ID8gJ+KUlOKUgCcgOiAnICAnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpbmUgKz0gJ+KUnOKUgCc7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSArPSB0aGlzLl90cmVlW25vZGVdO1xuICAgICAgICBwcmVmaXggKz0gKGxhc3QgPyAnICAnIDogJ+KUgiAnKTtcbiAgICAgICAgaWYgKGxlZnQgPCB0aGlzLl90cmVlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGluZSArPSAnXFxuJyArIHRoaXMuX2Rpc3BsYXlOb2RlKGxlZnQsIHByZWZpeCwgKHRoaXMuX3RyZWVbcmlnaHRdID09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodCA8IHRoaXMuX3RyZWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsaW5lICs9ICdcXG4nICsgdGhpcy5fZGlzcGxheU5vZGUocmlnaHQsIHByZWZpeCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBoZWFwIHRvIHN0cmluZ1xuICAgICAqXG4gICAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgICAqIEByZXR1cm4gc3RyaW5nICAgVGhlIHNlcmlhbGl6ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBzdGFydCB3aXRoIHJvb3QgYW5kIHJlY3Vyc2l2ZWx5IGdvZXMgdG8gZWFjaCBub2RlXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5Tm9kZSgwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGhlYXAgdG8gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9BcnJheVxuICAgICAqIEByZXR1cm4gQXJyYXkgICBUaGUgc2VyaWFsaXplZCBhcnJheS5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1heCBoZWFwIGZsYWdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBNQVhcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgSGVhcC5NQVggPSAxO1xuICAgIC8qKlxuICAgICAqIE1pbiBoZWFwIGZsYWdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBNSU5cbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgSGVhcC5NSU4gPSAtMTtcbiAgICByZXR1cm4gSGVhcDtcbn0pKCk7XG5tb2R1bGUuZXhwb3J0cyA9IEhlYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IZWFwLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSB0aGlzLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICAgIGQucHJvdG90eXBlID0gbmV3IF9fKCk7XG59O1xudmFyIEhlYXAgPSByZXF1aXJlKCcuL0hlYXAnKTtcbi8qKlxuICogVGhlIE1heEhlYXAgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIGhlYXAsIGtlZXBpbmcgdGhlIG1heGltdW0gb24gdGhlIHRvcC5cbiAqXG4gKiBAY2xhc3MgTWF4SGVhcFxuICogQGV4dGVuZHMgSGVhcFxuICovXG52YXIgTWF4SGVhcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1heEhlYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF4SGVhcCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSBIZWFwLk1BWDtcbiAgICB9XG4gICAgcmV0dXJuIE1heEhlYXA7XG59KShIZWFwKTtcbm1vZHVsZS5leHBvcnRzID0gTWF4SGVhcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1heEhlYXAuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9IHRoaXMuX19leHRlbmRzIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGU7XG4gICAgZC5wcm90b3R5cGUgPSBuZXcgX18oKTtcbn07XG52YXIgSGVhcCA9IHJlcXVpcmUoJy4vSGVhcCcpO1xuLyoqXG4gKiBUaGUgTWluSGVhcCBjbGFzcyBwcm92aWRlcyB0aGUgbWFpbiBmdW5jdGlvbmFsaXR5IG9mIGEgaGVhcCwga2VlcGluZyB0aGUgbWluaW11bSBvbiB0aGUgdG9wLlxuICpcbiAqIEBjbGFzcyBNaW5IZWFwXG4gKiBAZXh0ZW5kcyBIZWFwXG4gKi9cbnZhciBNaW5IZWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWluSGVhcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNaW5IZWFwKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9IEhlYXAuTUlOO1xuICAgIH1cbiAgICByZXR1cm4gTWluSGVhcDtcbn0pKEhlYXApO1xubW9kdWxlLmV4cG9ydHMgPSBNaW5IZWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWluSGVhcC5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBIZWFwID0gcmVxdWlyZSgnLi9IZWFwJyk7XG4vKipcbiAqIFRoZSBQcmlvcml0eVF1ZXVlIGNsYXNzIHByb3ZpZGVzIHRoZSBtYWluIGZ1bmN0aW9uYWxpdHkgb2YgYW4gcHJpb3JpdGl6ZWQgcXVldWUsIGltcGxlbWVudGVkIHVzaW5nIGEgbWF4IGhlYXAuXG4gKlxuICogQGNsYXNzIFByaW9yaXR5UXVldWVcbiAqIEBleHRlbmRzIEhlYXBcbiAqL1xudmFyIFByaW9yaXR5UXVldWUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcmlvcml0eVF1ZXVlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByaW9yaXR5UXVldWUoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl90eXBlID0gSGVhcC5NQVg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZWxlbWVudCB0byB0aGUgcXVldWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZW5xdWV1ZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gZW5xdWV1ZS5cbiAgICAgKiBAcGFyYW0gcHJpb3JpdHkgVGhlIHByaW9yaXR5IG9mIHZhbHVlLlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAodmFsdWUsIHByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydChuZXcgUHJpb3JpdHlRdWV1ZU5vZGUodmFsdWUsIHByaW9yaXR5KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXF1ZXVlcyBhIG5vZGUgZnJvbSB0aGUgcXVldWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVxdWV1ZVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIGRlcXVldWVkIG5vZGUuXG4gICAgICovXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZGVxdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdCgpLnZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVla3MgYXQgdGhlIG5vZGUgZnJvbSB0aGUgdG9wIG9mIHRoZSBoZWFwXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvcFxuICAgICAqIEByZXR1cm4gYW55IFRoZSB2YWx1ZSBvZiB0aGUgbm9kZSBvbiB0aGUgdG9wLlxuICAgICAqL1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudG9wLmNhbGwodGhpcykudmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wYXJlIGVsZW1lbnRzIGluIG9yZGVyIHRvIHBsYWNlIHRoZW0gY29ycmVjdGx5IGluIHRoZSBoZWFwIHdoaWxlIHNpZnRpbmcgdXAuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNvbXBhcmVcbiAgICAgKiBAcGFyYW0gZmlyc3QgVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBub2RlIGJlaW5nIGNvbXBhcmVkLlxuICAgICAqIEBwYXJhbSBzZWNvbmQgVGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgbm9kZSBiZWluZyBjb21wYXJlZC5cbiAgICAgKiBAcmV0dXJuIG51bWJlciBSZXN1bHQgb2YgdGhlIGNvbXBhcmlzb24sIHBvc2l0aXZlIGludGVnZXIgaWYgZmlyc3QgaXMgZ3JlYXRlciB0aGFuIHNlY29uZCwgMCBpZiB0aGV5IGFyZSBlcXVhbCwgbmVnYXRpdmUgaW50ZWdlciBvdGhlcndpc2UuXG4gICAgICogSGF2aW5nIG11bHRpcGxlIGVsZW1lbnRzIHdpdGggdGhlIHNhbWUgdmFsdWUgaW4gYSBIZWFwIGlzIG5vdCByZWNvbW1lbmRlZC4gVGhleSB3aWxsIGVuZCB1cCBpbiBhbiBhcmJpdHJhcnkgcmVsYXRpdmUgcG9zaXRpb24uXG4gICAgICovXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIGlmIChmaXJzdC5wcmlvcml0eSA+IHNlY29uZC5wcmlvcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmlyc3QucHJpb3JpdHkgPT0gc2Vjb25kLnByaW9yaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFByaW9yaXR5UXVldWU7XG59KShIZWFwKTtcbi8qKlxuICogUHJpb3JpdHlRdWV1ZSBOb2RlXG4gKlxuICogQGNsYXNzIFByaW9yaXR5UXVldWVOb2RlXG4gKi9cbnZhciBQcmlvcml0eVF1ZXVlTm9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gcHJpb3JpdHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcmlvcml0eVF1ZXVlTm9kZSh2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIG5vZGUgdG8gc3RyaW5nXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvU3RyaW5nXG4gICAgICogQHJldHVybiBzdHJpbmcgICBUaGUgc2VyaWFsaXplZCBzdHJpbmcuXG4gICAgICovXG4gICAgUHJpb3JpdHlRdWV1ZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSArIFwiIFtcIiArIHRoaXMucHJpb3JpdHkgKyBcIl1cIjtcbiAgICB9O1xuICAgIHJldHVybiBQcmlvcml0eVF1ZXVlTm9kZTtcbn0pKCk7XG5tb2R1bGUuZXhwb3J0cyA9IFByaW9yaXR5UXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcmlvcml0eVF1ZXVlLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIERvdWJseUxpbmtlZExpc3QgPSByZXF1aXJlKCcuL0RvdWJseUxpbmtlZExpc3QnKTtcbi8qKlxuICogVGhlIFF1ZXVlIGNsYXNzIHByb3ZpZGVzIHRoZSBtYWluIGZ1bmN0aW9uYWxpdHkgb2YgYSBxdWV1ZSBpbXBsZW1lbnRlZCB1c2luZyBhIGRvdWJseSBsaW5rZWQgbGlzdC5cbiAqXG4gKiBAY2xhc3MgUXVldWVcbiAqIEBleHRlbmRzIERvdWJseUxpbmtlZExpc3RcbiAqL1xudmFyIFF1ZXVlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUXVldWUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUXVldWUoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGVsZW1lbnQgdG8gdGhlIHF1ZXVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGVucXVldWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGVucXVldWUuXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaCh2YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXF1ZXVlcyBhIG5vZGUgZnJvbSB0aGUgcXVldWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVxdWV1ZVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIGRlcXVldWVkIG5vZGUuXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoaWZ0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gUXVldWU7XG59KShEb3VibHlMaW5rZWRMaXN0KTtcbm1vZHVsZS5leHBvcnRzID0gUXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWV1ZS5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBEb3VibHlMaW5rZWRMaXN0ID0gcmVxdWlyZSgnLi9Eb3VibHlMaW5rZWRMaXN0Jyk7XG4vKipcbiAqIFRoZSBTdGFjayBjbGFzcyBwcm92aWRlcyB0aGUgbWFpbiBmdW5jdGlvbmFsaXR5IG9mIGEgc3RhY2sgaW1wbGVtZW50ZWQgdXNpbmcgYSBkb3VibHkgbGlua2VkIGxpc3QuXG4gKlxuICogQGNsYXNzIFN0YWNrXG4gKiBAZXh0ZW5kcyBEb3VibHlMaW5rZWRMaXN0XG4gKi9cbnZhciBTdGFjayA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YWNrLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0YWNrKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0YWNrO1xufSkoRG91Ymx5TGlua2VkTGlzdCk7XG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhY2suanMubWFwIiwiLyoqXG4gKiBTVExcbiAqIEB0eXBlIHt7RG91Ymx5TGlua2VkTGlzdDogZXhwb3J0cywgU3RhY2s6IGV4cG9ydHMsIFF1ZXVlOiBleHBvcnRzLCBIZWFwOiBleHBvcnRzLCBNYXhIZWFwOiBleHBvcnRzLCBNaW5IZWFwOiBleHBvcnRzLCBQcmlvcml0eVF1ZXVlOiBleHBvcnRzfX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cdERvdWJseUxpbmtlZExpc3Q6IHJlcXVpcmUoJy4vRGF0YXN0cnVjdHVyZXMvRG91Ymx5TGlua2VkTGlzdCcpLFxuXHRTdGFjazogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9TdGFjaycpLFxuXHRRdWV1ZTogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9RdWV1ZScpLFxuXHRIZWFwOiByZXF1aXJlKCcuL0RhdGFzdHJ1Y3R1cmVzL0hlYXAnKSxcblx0TWF4SGVhcDogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9NYXhIZWFwJyksXG5cdE1pbkhlYXA6IHJlcXVpcmUoJy4vRGF0YXN0cnVjdHVyZXMvTWluSGVhcCcpLFxuXHRQcmlvcml0eVF1ZXVlOiByZXF1aXJlKCcuL0RhdGFzdHJ1Y3R1cmVzL1ByaW9yaXR5UXVldWUnKVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0ICogYXMgc3ZnT2JqIGZyb20gJy4vc3ZnT2JqZWN0cydcbmltcG9ydCAqIGFzIGVkaXRvckVsZW1lbnRzIGZyb20gJy4vZWRpdG9yRWxlbWVudHMnXG5pbXBvcnQgTG9naWMgZnJvbSAnLi9sb2dpYydcbmltcG9ydCBDb250ZXh0TWVudSBmcm9tICcuL2NvbnRleHRNZW51J1xuaW1wb3J0IEZsb2F0aW5nTWVudSBmcm9tICcuL2Zsb2F0aW5nTWVudSdcbmltcG9ydCBTaW11bGF0aW9uIGZyb20gJy4vc2ltdWxhdGlvbidcbmltcG9ydCB7IGFkZE1vdXNlU2Nyb2xsRXZlbnRMaXN0ZW5lciwgbWFuaGF0dGFuRGlzdGFuY2UgfSBmcm9tICcuL2hlbHBlckZ1bmN0aW9ucydcbmltcG9ydCBUdXRvcmlhbCBmcm9tICcuL3R1dG9yaWFsJztcbmltcG9ydCBWaWV3Qm94IGZyb20gJy4vdmlld2JveCdcbmltcG9ydCBNZXNzYWdlcyBmcm9tICcuL21lc3NhZ2VzJ1xuXG5pbXBvcnQgeyBQcmlvcml0eVF1ZXVlIH0gZnJvbSAnbGlic3RsJzsgLy8gbm90ZTogaW1wb3J0ZWQgZnJvbSBhIG5vZGUgbW9kdWxlXG5cbmNvbnN0XG4gICAgY3RybEtleSA9IDE3LFxuICAgIGNtZEtleSA9IDkxO1xuXG4vKiogQG1vZHVsZSBDYW52YXMgKi9cbi8qKlxuICogTWFpbiBjbGFzcyBvZiB0aGUgYXBwbGljYXRpb24uIEl0IHJlcHJlc2VudHMgYW4gaW5zdGFuY2Ugb2YgdGhlIHdob2xlIGVkaXRvciBhbmQgaG9sZHNcbiAqIHJlZmVyZW5jZXMgdG8gYWxsIGl0cyBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FudmFzIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBTdmcgY2xhc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2FudmFzICAgcXVlcnkgc2VsZWN0b3Igb2YgdGhlIFNWRyBlbGVtZW50LCB0aGF0IHdpbGwgY29udGFpbiBhbGwgU1ZHIGNvbnRlbnQgb2YgdGhlIGFwcGxpY2F0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyaWRTaXplIGluaXRpYWwgc2l6ZSBvZiB0aGUgZ3JpZCBpbiBTVkcgcGl4ZWxzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2FudmFzLCBncmlkU2l6ZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogalF1ZXJ5IGVsZW1lbnQgZm9yIHRoZSBTVkcgZG9jdW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJHN2ZyA9ICQoY2FudmFzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogc3BhY2UgYmV0d2VlbiBncmlkIGxpbmVzIGluIFNWRyBwaXhlbHNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JpZFNpemUgPSBncmlkU2l6ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXJyYXkgb2YgYWxsIGJveGVzIChpbnN0YW5jZXMgb2Ygb2JqZWN0cyBkZXJpdmVkIGZyb20gZWRpdG9yRWxlbWVudHMuQm94KSB1c2VkIG9uIENhbnZhc1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJveGVzID0gW107IC8vIHN0b3JlcyBhbGwgYm94ZXNcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXJyYXkgb2YgYWxsIHdpcmVzIChpbnN0YW5jZXMgb2YgZWRpdG9yRWxlbWVudHMuV2lyZSkgdXNlZCBvbiBDYW52YXNcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aXJlcyA9IFtdOyAvLyBzdG9yZXMgYWxsIHdpcmVzXG5cbiAgICAgICAgLy8gVE9ETyBkb2N1bWVudCB0aGlzXG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBuZXcgTWVzc2FnZXMoKTtcblxuICAgICAgICB0aGlzLnNpbXVsYXRpb25FbmFibGVkID0gdHJ1ZVxuICAgICAgICB0aGlzLnNpbXVsYXRpb24gPSBuZXcgU2ltdWxhdGlvbih0aGlzKTsgLy8gZHVtbXksIHdpbGwgYmUgb3ZlcndyaXR0ZW4gb24gc3RhcnROZXdTaW11bGF0aW9uXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRpc3RhbmNlIGZyb20gdGhlIGxlZnQgdG9wIGNvcm5lciB0byB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgaW1wb3J0ZWQgbmV0d29ya1xuICAgICAgICAgKiBhbmQgZGlzdGFuY2UgZnJvbSB0aGUgbGVmdCB0b3AgY29ybmVyIHRvIHRoZSBpbXBvcnRlZCBibGFjayBib3ggX2luIGdyaWQgcGl4ZWxzX1xuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sZWZ0VG9wUGFkZGluZyA9IDQ7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBkZWZzIGVsZW1lbnQsIHVzZWQgZm9yIHBhdHRlcm5zXG4gICAgICAgIHRoaXMuJGRlZnMgPSAkKFwiPGRlZnM+XCIpO1xuICAgICAgICB0aGlzLiRzdmcucHJlcGVuZCh0aGlzLiRkZWZzKTtcblxuICAgICAgICAvLyBCQUNLR1JPVU5EIFBBVFRFUk5cbiAgICAgICAgbGV0IHBhdHRlcm4gPSBuZXcgc3ZnT2JqLlBhdHRlcm4oXCJncmlkXCIsIHRoaXMuZ3JpZFNpemUsIHRoaXMuZ3JpZFNpemUpO1xuXG4gICAgICAgIGxldCBwYXR0ZXJuUG9pbnRzID0gbmV3IHN2Z09iai5Qb2x5bGluZVBvaW50cygpXG4gICAgICAgICAgICAuYXBwZW5kKG5ldyBzdmdPYmouUG9seWxpbmVQb2ludCgwLCAwKSlcbiAgICAgICAgICAgIC5hcHBlbmQobmV3IHN2Z09iai5Qb2x5bGluZVBvaW50KHRoaXMuZ3JpZFNpemUsIDApKVxuICAgICAgICAgICAgLmFwcGVuZChuZXcgc3ZnT2JqLlBvbHlsaW5lUG9pbnQodGhpcy5ncmlkU2l6ZSwgdGhpcy5ncmlkU2l6ZSkpO1xuXG4gICAgICAgIHBhdHRlcm4uYWRkQ2hpbGQobmV3IHN2Z09iai5Qb2x5TGluZShwYXR0ZXJuUG9pbnRzLCAyLCBcIiNhM2E0ZDJcIikpO1xuICAgICAgICB0aGlzLmFkZFBhdHRlcm4ocGF0dGVybi5nZXQoKSk7XG5cbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3IHN2Z09iai5SZWN0YW5nbGUoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIFwidXJsKCNncmlkKVwiLCBcIm5vbmVcIik7XG4gICAgICAgIHRoaXMuYXBwZW5kSlF1ZXJ5T2JqZWN0KHRoaXMuYmFja2dyb3VuZC5nZXQoKSk7XG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuXG4gICAgICAgIC8vIHNldCB0aGUgdmlld2JveCBmb3IgZnV0dXJlIHpvb21pbmcgYW5kIG1vdmluZyBvZiB0aGUgY2FudmFzXG4gICAgICAgIHRoaXMuJHN2Zy5hdHRyKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgJ3hNaW5ZTWluIHNsaWNlJylcbiAgICAgICAgdGhpcy52aWV3Ym94ID0gbmV3IFZpZXdCb3goMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG4gICAgICAgIHRoaXMuYXBwbHlWaWV3Ym94KClcblxuICAgICAgICAvLyBDT05TVFJVQ1QgQ09OVEVYVCBNRU5VXG4gICAgICAgIHRoaXMuY29udGV4dE1lbnUgPSBuZXcgQ29udGV4dE1lbnUodGhpcyk7XG5cbiAgICAgICAgLy8gQ09OU1RSVUNUIEZMT0FUSU5HIE1FTlVcbiAgICAgICAgdGhpcy5mbG9hdGluZ01lbnUgPSBuZXcgRmxvYXRpbmdNZW51KHRoaXMpO1xuXG4gICAgICAgIGxldCB0YXJnZXQ7XG5cbiAgICAgICAgLy8gQUxMIEVWRU5UIENBTExCQUNLU1xuICAgICAgICB0aGlzLiRzdmcub24oJ21vdXNlZG93bicsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuZ2V0UmVhbFRhcmdldChldmVudC50YXJnZXQpO1xuXG4gICAgICAgICAgICBpZih0YXJnZXQhPT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBwcm9wYWdhdGUgbW91c2Vkb3duIHRvIHRoZSByZWFsIHRhcmdldFxuICAgICAgICAgICAgICAgIHRhcmdldC5vbk1vdXNlRG93bihldmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG1vdXNlZG93biBoYXBwZW5lZCBkaXJlY3RseSBvbiB0aGUgc3ZnXG4gICAgICAgICAgICAgICAgdGhpcy5vbk1vdXNlRG93bihldmVudClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5oaWRlQ29udGV4dE1lbnUoKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pLm9uKCdtb3VzZW1vdmUnLCBldmVudCA9PiB7XG4gICAgICAgICAgICBpZih0YXJnZXQhPT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQub25Nb3VzZU1vdmUoZXZlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBtb3VzZW1vdmUgaGFwcGVuZWQgZGlyZWN0bHkgb24gdGhlIHN2Z1xuICAgICAgICAgICAgICAgIHRoaXMub25Nb3VzZU1vdmUoZXZlbnQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pLm9uKCdtb3VzZXVwJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgaWYodGFyZ2V0IT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Lm9uTW91c2VVcChldmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG1vdXNldXAgaGFwcGVuZWQgZGlyZWN0bHkgb24gdGhlIHN2Z1xuICAgICAgICAgICAgICAgIHRoaXMub25Nb3VzZVVwKGV2ZW50KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pLm9uKFwiY29udGV4dG1lbnVcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5Q29udGV4dE1lbnUoZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZLCB0aGlzLmdldFJlYWxKUXVlcnlUYXJnZXQoZXZlbnQudGFyZ2V0KSk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KVxuXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdrZXlkb3duJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbktleURvd24oZXZlbnQpO1xuICAgICAgICB9KS5vbihcImtleXVwXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHRoaXMub25LZXlVcChldmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdmlld2JveCBvbiB3aW5kb3cgcmVzaXplXG4gICAgICAgICQod2luZG93KS5vbigncmVzaXplJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3Ym94Lm5ld0RpbWVuc2lvbnModGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5hcHBseVZpZXdib3goKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYWRkTW91c2VTY3JvbGxFdmVudExpc3RlbmVyKGNhbnZhcywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgLy8gem9vbSBvbmx5IGlmIHRoZSBjdHJsIGtleSBpcyBwcmVzc2VkXG4gICAgICAgICAgICBpZihldmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC5kZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnpvb20gKz0gMC4xXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56b29tIC09IDAuMVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgfSlcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvcGVydHkgY29udGFpbmluZyBhbiBpbnN0YW5jZSBvZiBbVHV0b3JpYWxdKC4vbW9kdWxlLVR1dG9yaWFsLmh0bWwpLCBpZiB0aGVyZSBpcyBhbnlcbiAgICAgICAgICogQHR5cGUge1R1dG9yaWFsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50dXRvcmlhbDtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgdXNlciB2aXNpdHMgZm9yIHRoZSBmaXJzdCB0aW1lLCBpZiBzbywgc3RhcnQgdGhlIHR1dG9yaWFsXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZighbG9jYWxTdG9yYWdlLnVzZXJIYXNWaXNpdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFR1dG9yaWFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgd2lkdGggb2YgdGhlIG1haW4gU1ZHIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHdpZHRoIG9mIHRoZSBTVkcgZWxlbWVudCBpbiBwaXhlbHNcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzdmcud2lkdGgoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaGVpZ2h0IG9mIHRoZSBtYWluIFNWRyBlbGVtZW50XG4gICAgICogQHJldHVybiB7bnVtYmVyfSBoZWlnaHQgb2YgdGhlIFNWRyBlbGVtZW50IGluIHBpeGVsc1xuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzdmcuaGVpZ2h0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGFsbCBrZXlkb3duIGV2ZW50cyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gQ2FudmFzXG4gICAgICogQHBhcmFtICB7anF1ZXJ5LktleWJvYXJkRXZlbnR9IGV2ZW50IEtleWJvYXJkRXZlbnQgZ2VuZXJhdGVkIGJ5IGEgbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvbktleURvd24oZXZlbnQpIHtcbiAgICAgICAgaWYoZXZlbnQua2V5Q29kZSA9PT0gY3RybEtleSB8fCBldmVudC5rZXlDb2RlID09PSBjbWRLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuJHN2Zy5hZGRDbGFzcygnZ3JhYmJhYmxlJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGFsbCBrZXl1cCBldmVudHMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIENhbnZhc1xuICAgICAqIEBwYXJhbSAge2pxdWVyeS5LZXlib2FyZEV2ZW50fSBldmVudCBLZXlib2FyZEV2ZW50IGdlbmVyYXRlZCBieSBhIGxpc3RlbmVyXG4gICAgICovXG4gICAgb25LZXlVcChldmVudCkge1xuICAgICAgICBpZihldmVudC5rZXlDb2RlID09PSBjdHJsS2V5IHx8IGV2ZW50LmtleUNvZGUgPT09IGNtZEtleSkge1xuICAgICAgICAgICAgdGhpcy4kc3ZnLnJlbW92ZUNsYXNzKCdncmFiYmFibGUnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYWxsIG1vdXNlZG93biBldmVudHMgdGhhdCBhcmUgaGFwcGVuaW5nIGRpcmVjdGx5IG9uIHRoZSBDYW52YXNcbiAgICAgKiBAcGFyYW0gIHtqcXVlcnkuTW91c2VFdmVudH0gZXZlbnQgTW91c2VFdmVudCBnZW5lcmF0ZWQgYnkgYSBsaXN0ZW5lclxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIC8vIG1pZGRsZSBtb3VzZSBvciBsZWZ0IG1vdXNlICsgY3RybCBtb3ZlcyB0aGUgY2FudmFzXG4gICAgICAgIGlmKGV2ZW50LndoaWNoID09PSAyIHx8IChldmVudC53aGljaCA9PT0gMSAmJiBldmVudC5jdHJsS2V5KSkge1xuICAgICAgICAgICAgdGhpcy4kc3ZnLmFkZENsYXNzKCdncmFiYmVkJyk7XG4gICAgICAgICAgICB0aGlzLm1vdmVDYW52YXMgPSB7XG4gICAgICAgICAgICAgICAgbGVmdDogZXZlbnQucGFnZVgsXG4gICAgICAgICAgICAgICAgdG9wOiBldmVudC5wYWdlWVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhbGwgbW91c2Vtb3ZlIGV2ZW50cyB0aGF0IGFyZSBoYXBwZW5pbmcgZGlyZWN0bHkgb24gdGhlIENhbnZhc1xuICAgICAqIEBwYXJhbSAge2pxdWVyeS5Nb3VzZUV2ZW50fSBldmVudCBNb3VzZUV2ZW50IGdlbmVyYXRlZCBieSBhIGxpc3RlbmVyXG4gICAgICovXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgaWYodGhpcy5tb3ZlQ2FudmFzKSB7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IGV2ZW50LnBhZ2VYIC0gdGhpcy5tb3ZlQ2FudmFzLmxlZnRcbiAgICAgICAgICAgIGxldCB0b3AgPSBldmVudC5wYWdlWSAtIHRoaXMubW92ZUNhbnZhcy50b3BcblxuICAgICAgICAgICAgdGhpcy52aWV3Ym94LmxlZnRTaGlmdCArPSBsZWZ0XG4gICAgICAgICAgICB0aGlzLnZpZXdib3gudG9wU2hpZnQgKz0gdG9wXG4gICAgICAgICAgICB0aGlzLmFwcGx5Vmlld2JveCgpXG5cbiAgICAgICAgICAgIHRoaXMubW92ZUNhbnZhcyA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBldmVudC5wYWdlWCxcbiAgICAgICAgICAgICAgICB0b3A6IGV2ZW50LnBhZ2VZXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGFsbCBtb3VzZXVwIGV2ZW50cyB0aGF0IGFyZSBoYXBwZW5pbmcgZGlyZWN0bHkgb24gdGhlIENhbnZhc1xuICAgICAqL1xuICAgIG9uTW91c2VVcCgpIHtcbiAgICAgICAgaWYodGhpcy5tb3ZlQ2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLiRzdmcucmVtb3ZlQ2xhc3MoJ2dyYWJiZWQnKTtcbiAgICAgICAgICAgIHRoaXMubW92ZUNhbnZhcyA9IHVuZGVmaW5lZFxuXG4gICAgICAgICAgICAvLyBpZiB0dXRvcmlhbCBleGlzdHMsIGNhbGwgdHV0b3JpYWwgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmKHRoaXMudHV0b3JpYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnR1dG9yaWFsLm9uQ2FudmFzTW92ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmlld0JveCBhdHRyaWJ1dGUgb2YgdGhlIFNWRyBlbGVtZW50IGFuZCBzaXplIGFuZCBwb3NpdGlvbiBhdHRyaWJ1dGVzXG4gICAgICogb2YgdGhlIHJlY3RhbmdsZSB3aXRoIHRoZSBiYWNrZ3JvdW5kIGdyaWQgdG8gbWF0Y2ggdGhlIHZhbHVlcyBpbiB0aGlzLnZpZXdib3hcbiAgICAgKi9cbiAgICBhcHBseVZpZXdib3goKSB7XG4gICAgICAgIC8vIGFkanVzdCBiYWNrZ3JvdW5kXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZC5hZGRBdHRyKHtcbiAgICAgICAgICAgIHg6IHRoaXMudmlld2JveC5sZWZ0LFxuICAgICAgICAgICAgeTogdGhpcy52aWV3Ym94LnRvcCxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLnZpZXdib3gud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMudmlld2JveC5oZWlnaHRcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBzZXQgdGhlIHZpZXdCb3ggYXR0cmlidXRlXG4gICAgICAgIHRoaXMuJHN2Zy5hdHRyKCd2aWV3Qm94JywgdGhpcy52aWV3Ym94LnN0cilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgem9vbSBtdWx0aXBsaWVyIG9mIHRoZSBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHpvb20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdib3guem9vbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgem9vbSBtdWx0aXBsaWVyIG9mIHRoZSBjYW52YXMuXG4gICAgICogSSBzZXRzIHRoZSB2aWV3Ym94IHpvb20gYW5kIHRoZW4gYXBwbGllcyB0aGUgbmV3IHZhbHVlIGJ5IGNhbGxpbmcgdGhpcy5hcHBseVZpZXdib3goKVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdmFsdWUgc2V0IHRoZSB6b29tIHRvIHRoaXMgdmFsdWVcbiAgICAgKi9cbiAgICBzZXQgem9vbSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZpZXdib3guem9vbSA9IHZhbHVlXG4gICAgICAgIHRoaXMuYXBwbHlWaWV3Ym94KClcblxuICAgICAgICAvLyBpZiB0dXRvcmlhbCBleGlzdHMsIGNhbGwgdHV0b3JpYWwgY2FsbGJhY2tcbiAgICAgICAgaWYodGhpcy50dXRvcmlhbCkge1xuICAgICAgICAgICAgdGhpcy50dXRvcmlhbC5vbkNhbnZhc1pvb21lZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc3RhcnQgdGhlIHR1dG9yaWFsXG4gICAgICovXG4gICAgc3RhcnRUdXRvcmlhbCgpIHtcbiAgICAgICAgLy8gaW5zdGFudGlhdGUgdGhlIHR1dG9yaWFsXG4gICAgICAgIHRoaXMudHV0b3JpYWwgPSBuZXcgVHV0b3JpYWwodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gc2V0IHVzZXJIYXNWaXNpdGVkIHRvIHRydWUgd2hlbiB1c2VyIGNsb3NlcyAob3IgZmluaXNoZXMpIHRoZSB0dXRvcmlhbFxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnVzZXJIYXNWaXNpdGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gdW5zZXQgdGhlIHRoaXMudHV0b3JpYWwgcHJvcGVydHlcbiAgICAgICAgICAgIHRoaXMudHV0b3JpYWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHN0YXJ0IHRoZSB0dXRvcmlhbFxuICAgICAgICB0aGlzLnR1dG9yaWFsLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gb2JqZWN0IGNvbnRhaW5pbmcgZXhwb3J0IGRhdGEgZm9yIHRoZSBDYW52YXMgYW5kIGFsbCBlbGVtZW50cy5cbiAgICAgKiBEYXRhIGZyb20gdGhpcyBmdW5jdGlvbiBzaG91bGQgY292ZXIgYWxsIGltcG9ydGFudCBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gaW1wb3J0IHRoZVxuICAgICAqIG5ldHdvcmsgaW4gYSBkaWZmZXJlbnQgc2Vzc2lvbi5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IG9iamVjdCBjb250YWluaW5nIGluZm9tcmF0aW9uIGFib3V0IHRoZSBuZXR3b3JrXG4gICAgICovXG4gICAgZ2V0IGV4cG9ydERhdGEoKSB7XG4gICAgICAgIHRoaXMuZXhwb3J0V2lyZUlkTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmV4cG9ydFdpcmVJZCA9IDA7XG5cbiAgICAgICAgbGV0IGRhdGEgPSB7XG4gICAgICAgICAgICBib3hlczogW11cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGNvbnN0IGJveCBvZiB0aGlzLmJveGVzKSB7XG4gICAgICAgICAgICBkYXRhLmJveGVzLnB1c2goYm94LmV4cG9ydERhdGEpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNyZWF0ZSBhIGxvZ2ljIG5ldHdvcmsgZnJvbSB0aGUgZGF0YSBwcm92aWRlZFxuICAgICAqIEBwYXJhbSAge29iamVjdH0gZGF0YSBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW1wb3J0ZWQgbmV0d29ya1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gW3hdICBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBsZWZ0IHRvcCBjb3JuZXIgb2YgdGhlIG5ldHdvcmsgaW4gZ3JpZCBwaXhlbHNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFt5XSAgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIGxlZnQgdG9wIGNvcm5lciBvZiB0aGUgbmV0d29yayBpbiBncmlkIHBpeGVsc1xuICAgICAqL1xuICAgIGltcG9ydERhdGEoZGF0YSwgeCwgeSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBsZXQgd2FybmluZ3MgPSBbXTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIHggb3IgeSBpcyB1bmRlZmluZWQsIHNldCBpdCB0byBsZWZ0VG9wUGFkZGluZyBpbnN0ZWFkXG4gICAgICAgICAgICAvLyAoY2Fubm90IHVzZSB4IHx8IGxlZnRUb3BQYWRkaW5nIGJlY2F1c2Ugb2YgMClcbiAgICAgICAgICAgIHggPSB4IT09dW5kZWZpbmVkID8geCA6IHRoaXMubGVmdFRvcFBhZGRpbmdcbiAgICAgICAgICAgIHkgPSB5IT09dW5kZWZpbmVkID8geSA6IHRoaXMubGVmdFRvcFBhZGRpbmdcblxuICAgICAgICAgICAgdGhpcy5zaW11bGF0aW9uRW5hYmxlZCA9IGZhbHNlXG5cbiAgICAgICAgICAgIC8vIGxpc3Qgb2Ygd2lyZXMgdG8gYmUgYWRkZWRcbiAgICAgICAgICAgIGxldCBuZXdXaXJlcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAgICAgLy8gZmluZCB0aGUgbGVmdG1vc3QgYW5kIHRvcG1vc3QgY29vcmRpbmF0ZSBvZiBhbnkgYm94LCBzYXZlIHRoZW0gdG8gbGVmdFRvcENvcm5lclxuICAgICAgICAgICAgbGV0IGxlZnRUb3BDb3JuZXIgPSB7eDogMCwgeTogMH07XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgYm94RGF0YSBvZiBkYXRhLmJveGVzKSB7XG4gICAgICAgICAgICAgICAgaWYoYm94RGF0YS50cmFuc2Zvcm0gJiYgYm94RGF0YS50cmFuc2Zvcm0uaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGNvbnN0IHRyYW5zZm9ybUluZm8gb2YgYm94RGF0YS50cmFuc2Zvcm0uaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRyYW5zZm9ybUluZm8ubmFtZSA9PT0gXCJ0cmFuc2xhdGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxlZnRUb3BDb3JuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFRvcENvcm5lciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IE1hdGgubWluKGxlZnRUb3BDb3JuZXIueCwgdHJhbnNmb3JtSW5mby5hcmdzWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IE1hdGgubWluKGxlZnRUb3BDb3JuZXIueSwgdHJhbnNmb3JtSW5mby5hcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFRvcENvcm5lciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRyYW5zZm9ybUluZm8uYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRyYW5zZm9ybUluZm8uYXJnc1sxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IobGV0IGJveERhdGEgb2YgZGF0YS5ib3hlcykge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBib3hcbiAgICAgICAgICAgICAgICBsZXQgYm94O1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYm94RGF0YS5jYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2F0ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIG5ldyBnYXRlICh3aXRob3V0IHJlbG9hZGluZyB0aGUgU1ZHLCB3ZSB3aWxsIHJlbG9hZCBpdCBvbmNlIGFmdGVyIHRoZSBpbXBvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBib3ggPSB0aGlzLm5ld0dhdGUoYm94RGF0YS5uYW1lLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm90aGVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJveERhdGEubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgbmV3IGlucHV0ICh3aXRob3V0IHJlbG9hZGluZyB0aGUgU1ZHLCB3ZSB3aWxsIHJlbG9hZCBpdCBvbmNlIGFmdGVyIHRoZSBpbXBvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveCA9IHRoaXMubmV3SW5wdXQoMCwgMCwgYm94RGF0YS5pc09uLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvdXRwdXRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIG5ldyBvdXRwdXQgKHdpdGhvdXQgcmVsb2FkaW5nIHRoZSBTVkcsIHdlIHdpbGwgcmVsb2FkIGl0IG9uY2UgYWZ0ZXIgdGhlIGltcG9ydClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm94ID0gdGhpcy5uZXdPdXRwdXQoMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3MucHVzaChgVGhpcyBuZXR3b3JrIGNvbnRhaW5zIGEgYm94IHdpdGhvdXQgYSBuYW1lLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5ncy5wdXNoKGBUaGlzIG5ldHdvcmsgY29udGFpbnMgdW5rbm93biBib3ggbmFtZXMuICgke2JveERhdGEubmFtZX0pYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJsYWNrYm94XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBib3ggPSB0aGlzLm5ld0JsYWNrYm94KGJveERhdGEuaW5wdXRzLCBib3hEYXRhLm91dHB1dHMsIGJveERhdGEudGFibGUsIGJveERhdGEubmFtZSwgMCwgMCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5ncy5wdXNoKGBUaGlzIG5ldHdvcmsgYSBib3ggd2l0aG91dCBhIGNhdGVnb3J5LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5ncy5wdXNoKGBUaGlzIG5ldHdvcmsgY29udGFpbnMgdW5rbm93biBib3ggY2F0ZWdvcmllcy4gKCR7Ym94RGF0YS5jYXRlZ29yeX0pYCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJveCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9jY2VzcyBib3ggdHJhbnNmb3JtcyAodHJhbnNsYXRpb24gYW5kIHJvdGF0aW9uKVxuICAgICAgICAgICAgICAgICAgICBsZXQgdHJhbnNmb3JtID0gbmV3IGVkaXRvckVsZW1lbnRzLlRyYW5zZm9ybSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKGJveERhdGEudHJhbnNmb3JtICYmIGJveERhdGEudHJhbnNmb3JtLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IoY29uc3QgdHJhbnNmb3JtSXRlbSBvZiBib3hEYXRhLnRyYW5zZm9ybS5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodHJhbnNmb3JtSXRlbS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2xhdGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5zZXRUcmFuc2xhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtSXRlbS5hcmdzWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbGVmdFRvcENvcm5lci54IC8vIG1ha2UgaXQgdGhlIHJlbGF0aXZlIGRpc3RhbmNlIGZyb20gdGhlIGxlZnRtb3N0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyB4IC8vIGFwcGx5IHRoZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1JdGVtLmFyZ3NbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBsZWZ0VG9wQ29ybmVyLnkgLy8gbWFrZSBpdCB0aGUgcmVsYXRpdmUgZGlzdGFuY2UgZnJvbSB0aGUgdG9wbW9zdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgeSAvLyBhcHBseSB0aGUgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJvdGF0ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhwZWN0ZWQgMyBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5zZXRSb3RhdGUoLi4udHJhbnNmb3JtSXRlbS5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzLnB1c2goYFRoaXMgbmV0d29yayBjb250YWlucyB1bm5hbWVkIHRyYW5zZm9ybSBwcm9wZXJ0aWVzLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5ncy5wdXNoKGBUaGlzIG5ldHdvcmsgY29udGFpbnMgdW5rbm93biB0cmFuc2Zvcm0gcHJvcGVydGllcy4gKCR7dHJhbnNmb3JtSXRlbS5uYW1lfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0udG9TVkdQaXhlbHModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGJveC5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgYWxsIHdpcmVzIHRvIHRoZSBsaXN0IG9mIHdpcmVzIHRvIGJlIGFkZGVkXG4gICAgICAgICAgICAgICAgICAgIGlmKGJveERhdGEuY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihjb25zdCBjb25uZWN0aW9uIG9mIGJveERhdGEuY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGFydGlmaWNpYWwgd2lyZSBpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3aXJlSWQgPSBjb25uZWN0aW9uLndpcmVJZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhc3MgdGhlIHZhbHVlcyBnb3QgZnJvbSBqc29uIGludG8gYSB2YXJpYWJsZSB0aGF0IHdpbGwgYmUgYWRkZWQgaW50byB0aGUgbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogY29ubmVjdGlvbi5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm94SWQ6IGJveC5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHZhbHVlIHRvIHRoZSBtYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihuZXdXaXJlcy5oYXMod2lyZUlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBhbHJlYWR5IGlzIGEgd2lyZSB3aXRoIHRoaXMgaWQgaW4gdGhlIG1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSB2YWx1ZSB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSBvZiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1hcFZhbHVlID0gbmV3V2lyZXMuZ2V0KHdpcmVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcFZhbHVlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdXaXJlcy5zZXQod2lyZUlkLCBtYXBWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gd2lyZSB3aXRoIHRoaXMgaWQgaW4gdGhlIG1hcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHdpcmUgYW5kIHNldCB0aGUgdmFsdWUgdG8gYmUgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1dpcmVzLnNldCh3aXJlSWQsIFt2YWx1ZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVmcmVzaCB0aGUgU1ZHIGRvY3VtZW50IChuZWVkZWQgZm9yIHdpcmluZylcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuXG4gICAgICAgICAgICAvLyB3aXRoIGFsbCBib3hlcyBhZGRlZCwgd2UgY2FuIG5vdyBjb25uZWN0IHRoZW0gd2l0aCB3aXJlc1xuXG4gICAgICAgICAgICAvLyBwcmlvcml0eSBxdWV1ZSBmb3IgdGhlIG5ldyB3aXJlcywgcHJpb3JpdHkgYmVpbmcgKDEgLyBtYW5oYXR0YW5EaXN0YW5jZSkgYmV0d2VlbiB0aGUgY29uZW5jdG9ycywgaGlnaGVyIGlzIGJldHRlclxuICAgICAgICAgICAgbGV0IHdpcmVRdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XG5cbiAgICAgICAgICAgIC8vIGdldCBhbGwgaWRzIGZvciBsYWwgdGhlXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHdpcmVJbmZvIG9mIG5ld1dpcmVzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbm5lY3RvcklkcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGFuIGFycmF5IFtjb25uZWN0b3IxSWQsIGNvbm5lY3RvcjJJZF1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHtib3hJZCwgaW5kZXh9IG9mIHdpcmVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rvcklkcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRCb3hCeUlkKGJveElkKS5jb25uZWN0b3JzW2luZGV4XS5pZFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGFuZCBhcnJheSBbe3gsIHl9LCB7eCwgeX1dIGNvbnRhaW5pbmcgcG9zaXRpb25zIGZvciBjb25uZWN0b3JzIDEgYW5kIDJcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0b3JzUG9zaXRpb25zID0gY29ubmVjdG9ySWRzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9ySWQgPT4gdGhpcy5nZXRDb25uZWN0b3JQb3NpdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29ubmVjdG9yQnlJZChjb25uZWN0b3JJZCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlKVxuICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICBpZihjb25uZWN0b3JzUG9zaXRpb25zLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2lyZSA9IHRoaXMubmV3V2lyZSguLi5jb25uZWN0b3JJZHMsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBtYW5oYXR0YW4gZGlzdGFuY2UgYmV0d2VlbiB0aGVzZSB0d28gY29ubmVjdG9yc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IG1hbmhhdHRhbkRpc3RhbmNlKC4uLmNvbm5lY3RvcnNQb3NpdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBjb25uZWN0b3JpZHMgdG8gdGhlIHByaW9yaXR5IHF1ZXVlXG4gICAgICAgICAgICAgICAgICAgIHdpcmVRdWV1ZS5lbnF1ZXVlKHdpcmUsIDEgLyBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ3MucHVzaChgRm91bmQgYSB3aXJlIHRoYXQgZG9lcyBub3QgaGF2ZSB0d28gZW5kaW5ncy4gKEl0IGhhZCAke2Nvbm5lY3RvcnNQb3NpdGlvbnMubGVuZ3RofSBpbnN0ZWFkLilgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdpbmRvdy5Xb3JrZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgd2lyZVBvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCB3aXJlUmVmZXJlbmNlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCB0aGUgcXVldWUgdG8gYW4gYXJyYXkgKHRoaXMgaXMgbmVlZGVkIGJ5IHRoZSB3ZWIgd29ya2VyKVxuICAgICAgICAgICAgICAgIHdoaWxlKCF3aXJlUXVldWUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpcmUgPSB3aXJlUXVldWUuZGVxdWV1ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCB3aXJlU3RhcnQgPSB0aGlzLmdldENvbm5lY3RvclBvc2l0aW9uKHdpcmUuc3RhcnRDb25uZWN0b3IsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2lyZUVuZCA9IHRoaXMuZ2V0Q29ubmVjdG9yUG9zaXRpb24od2lyZS5lbmRDb25uZWN0b3IsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHdpcmVQb2ludHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogd2lyZVN0YXJ0LnggLyB0aGlzLmdyaWRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHdpcmVTdGFydC55IC8gdGhpcy5ncmlkU2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB3aXJlRW5kLnggLyB0aGlzLmdyaWRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHdpcmVFbmQueSAvIHRoaXMuZ3JpZFNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSlcblxuICAgICAgICAgICAgICAgICAgICB3aXJlUmVmZXJlbmNlcy5wdXNoKHdpcmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFtyb3V0ZVdvcmtlckZpbGVOYW1lXSByZXBsYWNlZCBpbiB0aGUgYnVpbGQgcHJvY2VzcyAoZGVmaW5lZCBpbiBndWxwZmlsZSkgZGVwZW5kaW5nIG9uIGRldmVsIC8gcHJvZCBidWlsZFxuICAgICAgICAgICAgICAgIGxldCBteVdvcmtlciA9IG5ldyBXb3JrZXIoXCJqcy9bcm91dGVXb3JrZXJGaWxlTmFtZV1cIik7XG5cbiAgICAgICAgICAgICAgICBsZXQgbG9hZGluZ01lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzLm5ld0xvYWRpbmdNZXNzYWdlKFwibG9va2luZyBmb3IgdGhlIGJlc3Qgd2lyaW5n4oCmXCIpO1xuXG4gICAgICAgICAgICAgICAgbXlXb3JrZXIub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHtwYXRoc30gPSBldmVudC5kYXRhXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgd2lyZVJlZmVyZW5jZXMgYW5kIHBhdGhzIHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgICAgICAgICAgd2lyZVJlZmVyZW5jZXMuZm9yRWFjaCgod2lyZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aXJlLnNldFdpcmVQYXRoKHdpcmUucGF0aFRvUG9seWxpbmUocGF0aHNba2V5XSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB3aXJlLnVwZGF0ZVdpcmVTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmdNZXNzYWdlLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICB3aXJlczogd2lyZVBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgbm9uUm91dGFibGVOb2RlczogdGhpcy5nZXROb25Sb3V0YWJsZU5vZGVzKCksXG4gICAgICAgICAgICAgICAgICAgIGluY29udmVuaWVudE5vZGVzOiB0aGlzLmdldEluY29udmVuaWVudE5vZGVzKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBteVdvcmtlci5wb3N0TWVzc2FnZShtZXNzYWdlKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdlYiB3b3JrZXIgaXMgbm90IHN1cHBvcnRlZDogdXNlIGFuIGludGVydmFsIHRvIG1ha2UgdGhlIGltcG9ydCBhIGJpdCBzbG93ZXJcbiAgICAgICAgICAgICAgICAvLyBieSBkaXZpZGluZyBpdCBpbnRvIGNodW5rcywgc28gdGhlIGJyb3dzZXIgd2luZG93IGlzIG5vdCBlbnRpcmVseSBmcm96ZW4gd2hlbiB0aGUgd2lyaW5nIGlzIGhhcHBlbmluZ1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lyZXNUb0JlUm91dGVkQXRPbmNlID0gMTA7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsYXlCZXR3ZWVuSXRlcmF0aW9ucyA9IDIwMDtcblxuICAgICAgICAgICAgICAgIC8vIGFkZCB3aXJlcyBpbiB0aGUgb3JkZXIgZnJvbSBzaG9ydCB0byBsb25nXG4gICAgICAgICAgICAgICAgbGV0IHdpcmVQbGFjaW5nSW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZighd2lyZVF1ZXVlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHdpcmVzVG9CZVJvdXRlZEF0T25jZTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYod2lyZVF1ZXVlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aXJlID0gd2lyZVF1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXJlLnJvdXRlV2lyZSh0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lyZS51cGRhdGVXaXJlU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZmluaXNoZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHdpcmVQbGFjaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZGVsYXlCZXR3ZWVuSXRlcmF0aW9ucylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVmcmVzaCB0aGUgU1ZHIGRvY3VtZW50XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcblxuICAgICAgICAgICAgdGhpcy5zaW11bGF0aW9uRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBib3ggb2YgdGhpcy5ib3hlcykge1xuICAgICAgICAgICAgICAgIGlmIChib3ggaW5zdGFuY2VvZiBlZGl0b3JFbGVtZW50cy5JbnB1dEJveCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggdGhlIGlucHV0IGJveCBzdGF0ZSB0byB0aGUgb3Bwb3NpdGUgYW5kIGJhY2s6XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBjYWxsaW5nIGJveC5yZWZyZXNoU3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHRzIGluIHdlaXJkIHVuZmluaXNoZWQgc2ltdWxhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNhdXNlcyB1cGRhdGUgb2YgdGhlIG91dHB1dCBjb25uZWN0b3IgYW5kIHRodXMgYSBzdGFydCBvZiBhIG5ldyBzaW11bGF0aW9uXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBmaW5kIGJldHRlciBzb2x1dGlvbiBpbnN0ZWFkIG9mIHRoaXMgd29ya2Fyb3VuZCwgaWYgdGhlcmUgaXMgYW55XG4gICAgICAgICAgICAgICAgICAgIGJveC5vbiA9ICFib3gub25cbiAgICAgICAgICAgICAgICAgICAgYm94Lm9uID0gIWJveC5vblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZSh3YXJuaW5ncylcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHVzZXIgY2xpY2tzIG9uIGEgY29ubmVjdG9yLCByZW1lbWJlciBpdCB1bnRpbCB0aGV5IGNsaWNrIG9uIHNvbWUgb3RoZXIgY29ubmVjdG9yLlxuICAgICAqIFRoYW4gY2FsbCBuZXdXaXJlIHdpdGggdGhlIGxhc3QgdHdvIGNvbm5lY3RvcnMgaWRzIGFzIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbm5lY3RvcklkIGlkIG9mIHRoZSBjb25uZWN0b3IgdGhhdCB0aGUgdXNlciBjbGlja2VkIG9uXG4gICAgICovXG4gICAgd2lyZUNyZWF0aW9uSGVscGVyKGNvbm5lY3RvcklkKSB7XG4gICAgICAgIGlmKCF0aGlzLmZpcnN0Q29ubmVjdG9ySWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RDb25uZWN0b3JJZCA9IGNvbm5lY3RvcklkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXdXaXJlKHRoaXMuZmlyc3RDb25uZWN0b3JJZCwgY29ubmVjdG9ySWQpO1xuICAgICAgICAgICAgdGhpcy5maXJzdENvbm5lY3RvcklkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVuIGEgbG9naWMgc2ltdWxhdGlvbiBmcm9tIHRoZSBzdGFydGluZ0Nvbm5lY3Rvci5cbiAgICAgKiBUaGlzIHJlZnJlc2hlcyB0aGUgc3RhdGVzIG9mIGFsbCBlbGVtZW50cyBpbiB0aGUgbmV0d29yayB3aG9zZSBpbnB1dHMgYXJlXG4gICAgICogZGlyZWN0bHkgKG9yIGJ5IHRyYW5zaXRpb24pIGNvbm5lY3RlZCB0byBzdGFydGluZ0Nvbm5lY3RvcidzIG91dHB1dFxuICAgICAqIEBwYXJhbSAge091dHB1dENvbm5lY3Rvcn0gc3RhcnRpbmdDb25uZWN0b3IgcnVuIHNpbXVsYXRpb24gZnJvbSB0aGlzIG91dHB1dCBjb25uZWN0b3JcbiAgICAgKiBAcGFyYW0gIHtMb2dpYy5zdGF0ZX0gc3RhdGUgbmV3IHN0YXRlIG9mIHRoZSBzdGFydGluZ0Nvbm5lY3RvclxuICAgICAqL1xuICAgIHN0YXJ0TmV3U2ltdWxhdGlvbihzdGFydGluZ0Nvbm5lY3Rvciwgc3RhdGUpIHtcbiAgICAgICAgaWYodGhpcy5zaW11bGF0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5zaW11bGF0aW9uID0gbmV3IFNpbXVsYXRpb24odGhpcylcbiAgICAgICAgICAgIHRoaXMuc2ltdWxhdGlvbi5ub3RpZnlDaGFuZ2Uoc3RhcnRpbmdDb25uZWN0b3IuaWQsIHN0YXRlKVxuICAgICAgICAgICAgdGhpcy5zaW11bGF0aW9uLnJ1bigpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgZ2F0ZSBvbiB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgbmFtZSAgICAgICAgICAgdHlwZSBvZiB0aGUgZ2F0ZSAoYW5kLCBvciAuLi4pXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSAgeCAgICAgICAgICAgICAgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgZ2F0ZSBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSAgeSAgICAgICAgICAgICAgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIGdhdGUgaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IFtyZWZyZXNoPXRydWVdIGlmIHRydWUsIHRoaXMucmVmcmVzaCgpIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGFkZGluZyB0aGUgZ2F0ZVxuICAgICAqIEByZXR1cm4ge2VkaXRvckVsZW1lbnRzLkdhdGV9ICAgIGluc3RhbmNlIG9mIEdhdGUgdGhhdCBoYXMgYmVlbiBuZXdseSBhZGRlZFxuICAgICAqL1xuICAgIG5ld0dhdGUobmFtZSwgeCwgeSwgcmVmcmVzaCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3Qm94KHgsIHksIG5ldyBlZGl0b3JFbGVtZW50cy5HYXRlKHRoaXMsIG5hbWUsIHgsIHkpLCByZWZyZXNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW5wdXQgYm94IG9uIHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4ICAgICAgICAgICAgICBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBnYXRlIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5ICAgICAgICAgICAgICB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgZ2F0ZSBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gW2lzT249ZmFsc2VdICAgc3RhdGUgb2YgdGhlIGlucHV0IGJveCAoZGVmYXVsdCBpcyBmYWxzZSAob2ZmKSlcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBbcmVmcmVzaD10cnVlXSBpZiB0cnVlLCB0aGlzLnJlZnJlc2goKSB3aWxsIGJlIGNhbGxlZCBhZnRlciBhZGRpbmcgdGhlIGlucHV0IGJveFxuICAgICAqIEByZXR1cm4ge2VkaXRvckVsZW1lbnRzLklucHV0Qm94fSAgICBpbnN0YW5jZSBvZiB0aGUgSW5wdXRCb3ggdGhhdCBoYXMgYmVlbiBuZXdseSBhZGRlZFxuICAgICAqL1xuICAgIG5ld0lucHV0KHgsIHksIGlzT24gPSBmYWxzZSwgcmVmcmVzaCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3Qm94KHgsIHksIG5ldyBlZGl0b3JFbGVtZW50cy5JbnB1dEJveCh0aGlzLCBpc09uKSwgcmVmcmVzaCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIG91dHB1dCBib3ggb24gdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSAge251bWJlcn0gIHggICAgICAgICAgICAgIGhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGdhdGUgaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkgICAgICAgICAgICAgIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBnYXRlIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBbcmVmcmVzaD10cnVlXSBpZiB0cnVlLCB0aGlzLnJlZnJlc2goKSB3aWxsIGJlIGNhbGxlZCBhZnRlciBhZGRpbmcgdGhlIG91dHB1dCBib3hcbiAgICAgKiBAcmV0dXJuIHtlZGl0b3JFbGVtZW50cy5JbnB1dEJveH0gICAgaW5zdGFuY2Ugb2YgdGhlIE91dHB1dEJveCB0aGF0IGhhcyBiZWVuIG5ld2x5IGFkZGVkXG4gICAgICovXG4gICAgbmV3T3V0cHV0KHgsIHksIHJlZnJlc2ggPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld0JveCh4LCB5LCBuZXcgZWRpdG9yRWxlbWVudHMuT3V0cHV0Qm94KHRoaXMpLCByZWZyZXNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBuZXcgQm94IHRvIHRoZSBDYW52YXNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4ICAgICAgICAgICAgICBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBib3ggaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkgICAgICAgICAgICAgIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBib3ggaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge2VkaXRvckVsZW1lbnRzLkJveH0gIG9iamVjdCAgICAgICAgIGluc3RhbmNlIG9mIGFuIG9iamVjdCBkZXJpdmVkIGZyb20gdGhlIGVkaXRvckVsZW1lbnRzLkJveCBjbGFzc1xuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtyZWZyZXNoPXRydWVdIGlmIHRydWUsIHRoaXMucmVmcmVzaCgpIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGFkZGluZyB0aGUgYm94XG4gICAgICogQHJldHVybiB7ZWRpdG9yRWxlbWVudHMuQm94fSAgICAgICAgICAgICAgICAgcmV0dXJuIHRoZSBpbnN0YW5jZSBvZiB0aGUgbmV3bHkgYWRkZWQgb2JqZWN0XG4gICAgICovXG4gICAgbmV3Qm94KHgsIHksIG9iamVjdCwgcmVmcmVzaCA9IHRydWUpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5ib3hlcy5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5ib3hlc1tpbmRleF0gPSBvYmplY3Q7XG5cbiAgICAgICAgLy8gdHJhbnNsYXRlIHRoZSBnYXRlIGlmIHggYW5kIHkgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAgICAgIGlmKHggJiYgeSkge1xuICAgICAgICAgICAgbGV0IHRyID0gbmV3IGVkaXRvckVsZW1lbnRzLlRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgdHIuc2V0VHJhbnNsYXRlKHgsIHkpO1xuXG4gICAgICAgICAgICB0aGlzLmJveGVzW2luZGV4XS5zdmdPYmouYWRkQXR0cih7XCJ0cmFuc2Zvcm1cIjogdHIuZ2V0KCl9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYXBwZW5kRWxlbWVudCh0aGlzLmJveGVzW2luZGV4XSwgcmVmcmVzaCk7XG5cbiAgICAgICAgLy8gaWYgdHV0b3JpYWwgZXhpc3RzLCBjYWxsIHR1dG9yaWFsIGNhbGxiYWNrXG4gICAgICAgIGlmKHRoaXMudHV0b3JpYWwpIHtcbiAgICAgICAgICAgIHRoaXMudHV0b3JpYWwub25FbGVtZW50QWRkZWQodGhpcy5ib3hlc1tpbmRleF0ubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5ib3hlc1tpbmRleF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgYm94IGZyb20gQ2FudmFzIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBJRFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBib3hJZCBpZCBvZiB0aGUgYm94IHRoYXQgc2hvdWxkIGJlIHJlbW92ZWRcbiAgICAgKi9cbiAgICByZW1vdmVCb3goYm94SWQpIHtcbiAgICAgICAgbGV0ICRnYXRlID0gJChcIiNcIitib3hJZCk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgZ2F0ZSBpbiBzdmcncyBsaXN0IG9mIGdhdGVzXG4gICAgICAgIGxldCBnYXRlSW5kZXggPSAtMTtcbiAgICAgICAgZm9yKGxldCBpID0gMCA7IGkgPCB0aGlzLmJveGVzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgaWYodGhpcy5ib3hlc1tpXS5zdmdPYmouaWQ9PT1ib3hJZCkge1xuICAgICAgICAgICAgICAgIGdhdGVJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihnYXRlSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCB3aXJlcyBjb25uZWN0ZWQgdG8gdGhpcyBnYXRlXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5ib3hlc1tnYXRlSW5kZXhdLmNvbm5lY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVdpcmVzQnlDb25uZWN0b3JJZCh0aGlzLmJveGVzW2dhdGVJbmRleF0uY29ubmVjdG9yc1tpXS5zdmdPYmouaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIGdhdGVcbiAgICAgICAgICAgIHRoaXMuYm94ZXMuc3BsaWNlKGdhdGVJbmRleCwgMSk7XG4gICAgICAgICAgICAkZ2F0ZS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgLy8gaWYgdHV0b3JpYWwgZXhpc3RzLCBjYWxsIHR1dG9yaWFsIGNhbGxiYWNrXG4gICAgICAgICAgICBpZih0aGlzLnR1dG9yaWFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50dXRvcmlhbC5vbkVsZW1lbnRSZW1vdmVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVHJ5aW5nIHRvIHJlbW92ZSBhbiBub25leGlzdGluZyBib3guIEJveCBpZDpcIiwgYm94SWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBib3hlcyBmcm9tIHRoZSBjYW52YXNcbiAgICAgKi9cbiAgICBjbGVhbkNhbnZhcygpIHtcbiAgICAgICAgLy8gY2Fubm90IHNpbXBseSBpdGVyYXRlIHRocm91Z2ggdGhlIGFycmF5IGJlY2F1c2UgcmVtb3ZlQm94IHdvcmtzIHdpdGggaXRcblxuICAgICAgICAvLyBjcmVhdGUgYW4gYXJyYXkgb2YgaWRzXG4gICAgICAgIGNvbnN0IGlkcyA9IHRoaXMuYm94ZXMubWFwKGJveCA9PiBib3guaWQpO1xuXG4gICAgICAgIC8vIHJlbW92ZSBhbGwgYm94ZXMgYnkgdGhlaXIgaWRzXG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgaWRzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUJveChpZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgd2lyZSBjb25uZWN0aW5nIHRoZSBwcm92aWRlZCBjb25uZWN0b3JzXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgZnJvbUlkICAgICAgICAgaWQgb2YgdGhlIGNvbm5lY3RvciB0aGF0IHRoZSB3aXJlIGlzIGF0dGFjaGVkIHRvXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgdG9JZCAgICAgICAgICAgaWQgb2YgdGhlIGNvbm5lY3RvciB0aGF0IHRoZSB3aXJlIGlzIGF0dGFjaGVkIHRvXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW3JlZnJlc2g9dHJ1ZV0gaWYgcmVmcmVzaCBpcyBzZXQgdG8gdHJ1ZSwgdGhlIFNWRyBkb2N1bWVudCB3aWxsIGJlIHJlbG9hZGVkIGFmdGVyIGFkZGluZyB0aGUgd2lyZVxuICAgICAqIEByZXR1cm4ge2VkaXRvckVsZW1lbnRzLldpcmV9ICAgIGluc3RhbmNlIG9mIGVkaXRvckVsZW1lbnRzLldpcmUgdGhhdCBoYXMgYmVlbiBhZGRlZCB0byB0aGUgQ2FudmFzXG4gICAgICovXG4gICAgbmV3V2lyZShmcm9tSWQsIHRvSWQsIHJlZnJlc2ggPSB0cnVlLCByb3V0ZSA9IHRydWUpIHtcbiAgICAgICAgLy8gd2lyZSBtdXN0IGNvbm5lY3QgdHdvIGRpc3RpbmN0IGNvbm5lY3RvcnNcbiAgICAgICAgaWYgKGZyb21JZD09PXRvSWQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgICBsZXQgY29ubmVjdG9ycyA9IFt0aGlzLmdldENvbm5lY3RvckJ5SWQoZnJvbUlkKSwgdGhpcy5nZXRDb25uZWN0b3JCeUlkKHRvSWQpXVxuXG4gICAgICAgIC8vIGlucHV0IGNvbm5lY3RvcnMgY2FuIGJlIGNvbm5lY3RlZCB0byBvbmUgd2lyZSBtYXhcbiAgICAgICAgY29ubmVjdG9ycy5mb3JFYWNoKGNvbm4gPT4ge1xuICAgICAgICAgICAgaWYoY29ubi5pc0lucHV0Q29ubmVjdG9yKVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlV2lyZXNCeUNvbm5lY3RvcklkKGNvbm4uaWQpXG4gICAgICAgIH0pXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMud2lyZXMubGVuZ3RoO1xuICAgICAgICB0aGlzLndpcmVzW2luZGV4XSA9IG5ldyBlZGl0b3JFbGVtZW50cy5XaXJlKHRoaXMsIGZyb21JZCwgdG9JZCwgcmVmcmVzaCwgcm91dGUpO1xuXG4gICAgICAgIGNvbm5lY3RvcnMuZm9yRWFjaChjb25uID0+IHtcbiAgICAgICAgICAgIGNvbm4uYWRkV2lyZUlkKHRoaXMud2lyZXNbaW5kZXhdLnN2Z09iai5pZCk7XG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5hcHBlbmRFbGVtZW50KHRoaXMud2lyZXNbaW5kZXhdLCByZWZyZXNoKTtcbiAgICAgICAgdGhpcy5tb3ZlVG9CYWNrQnlJZCh0aGlzLndpcmVzW2luZGV4XS5zdmdPYmouaWQpO1xuXG4gICAgICAgIGlmKHJlZnJlc2gpXG4gICAgICAgICAgICB0aGlzLndpcmVzW2luZGV4XS51cGRhdGVXaXJlU3RhdGUoKVxuXG4gICAgICAgIHJldHVybiB0aGlzLndpcmVzW2luZGV4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBzcGVjaWZpZWQgY29ubmVjdG9yXG4gICAgICogQHBhcmFtICB7Q29ubmVjdG9yfSAgY29ubmVjdG9yICAgICAgaW5zdGFuY2Ugb2Yge0BsaW5rIENvbm5lY3Rvcn1cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbc25hcFRvR3JpZD10cnVlXSBpZiB0cnVlLCB0aGUgY29ubmVjdG9yIHBvc2l0aW9uIHdpbGwgYmUgc25hcHBlZCB0byB0aGUgZ3JpZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgIHBvaW50IC0gb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgXG4gICAgICovXG4gICAgZ2V0Q29ubmVjdG9yUG9zaXRpb24oY29ubmVjdG9yLCBzbmFwVG9HcmlkID0gdHJ1ZSkge1xuICAgICAgICAvLyBjb25uZWN0b3Iuc3ZnT2JqLmlkIGhhcyB0byBiZSBjYWxsZWQsIGVsc2UgdGhlIGdldENvb3JkaW5hdGVzIGRvZXMgbm90IHdvcmsgb24gdGhlIGZpcnN0IGNhbGwgaW4gRmlyZWZveCA1NVxuICAgICAgICBjb25zdCBkdW1teSA9IGNvbm5lY3Rvci5zdmdPYmouaWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgICAgICBsZXQgJGNvbm5lY3RvciA9IGNvbm5lY3Rvci5zdmdPYmouJGVsO1xuXG4gICAgICAgIGxldCBwb3NpdGlvbiA9ICRjb25uZWN0b3IucG9zaXRpb24oKTtcblxuICAgICAgICBwb3NpdGlvbi5sZWZ0ID0gdGhpcy52aWV3Ym94LnRyYW5zZm9ybVgocG9zaXRpb24ubGVmdClcbiAgICAgICAgcG9zaXRpb24udG9wID0gdGhpcy52aWV3Ym94LnRyYW5zZm9ybVkocG9zaXRpb24udG9wKVxuXG4gICAgICAgIGxldCB3aWR0aCA9ICRjb25uZWN0b3IuYXR0cihcIndpZHRoXCIpO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gJGNvbm5lY3Rvci5hdHRyKFwiaGVpZ2h0XCIpO1xuXG4gICAgICAgIGxldCB4ID0gcG9zaXRpb24ubGVmdCArIHdpZHRoIC8gMjtcbiAgICAgICAgbGV0IHkgPSBwb3NpdGlvbi50b3AgKyBoZWlnaHQgLyAyO1xuICAgICAgICBpZihzbmFwVG9HcmlkKSB7XG4gICAgICAgICAgICB4ID0gdGhpcy5zbmFwVG9HcmlkKHgpO1xuICAgICAgICAgICAgeSA9IHRoaXMuc25hcFRvR3JpZCh5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZXMgYSBuZXcgYmxhY2tib3hcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggICAgICAgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmxhY2tib3ggaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge251bWJlcn0geSAgICAgICB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgZ2F0ZSBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBpbnB1dHMgIG51bWJlciBvZiBpbnB1dCBwaW5zIG9mIHRoaXMgYmxhY2tib3hcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IG91dHB1dHMgbnVtYmVyIG9mIG91dHB1dCBwaW5zIG9mIHRoaXMgYmxhY2tib3hcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gdGFibGUgICBBcnJheSBvZiBhcnJheXMsIGVhY2ggaW5uZXIgYXJyYXkgY29udGFpbnMgbGlzdCBvZiBbTG9naWMuc3RhdGVdKC4vbW9kdWxlLUxvZ2ljLmh0bWwjLnN0YXRlKXMsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgZGVzY3JpYmUgdGhlIGNvbWJpbmF0aW9uIG9mIGlucHV0IHBpbiBhbmQgb3V0cHV0IHBpbiBzdGF0ZXMgaW4gdGhlIG9yZGVyIGZyb20gdGhlIHRvcCB0byBib3R0b20gZm9yIGJvdGggaW5wdXQgYW5kIG91dHB1dCBjb25uZWN0b3JzLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB3ZSBoYWQgYW4gQU5EIGFycmF5IGFzIGEgYmxhY2tib3gsIG9uZSBvZiB0aGUgc3RhdGVzIGNvdWxkIGJlIGBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub2ZmXWBcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggbWVhbnMgdGhhdCBpZiB0aGUgZmlyc3QgaW5wdXQgY29ubmVjdG9yIGlzIGluIHRoZSBgb25gIHN0YXRlIGFuZCB0aGUgc2Vjb25kIGNvbm5lY3RvciBpcyBpbiB0aGUgYG9mZmAgc3RhdGUsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBzdGF0ZSBvZiB0aGUgb3V0cHV0IGNvbm5lY3RvciB3aWxsIGJlIGBvZmZgLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgYXJyYXkgY2FuIGJlIGRlc2NyaWJlZCBhcyBgW3N0YXRlIGZvciBpbnB1dCBjb25uIDEsIHN0YXRlIGZvciBpbnB1dCBjb25uIDIsIC4uLiwgc3RhdGUgZm9yIG91dHB1dCBjb25uIDEsIHN0YXRlIGZvciBvdXRwdXQgY29ubiAyIC4uLl1gLlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWUgICBhIG5hbWUgdGhhdCB3aWxsIGJlIGRpc3BsYXllZCBvbiB0aGUgYmxhY2tib3hcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBbcmVmcmVzaD10cnVlXSBpZiB0cnVlLCB0aGlzLnJlZnJlc2goKSB3aWxsIGJlIGNhbGxlZCBhZnRlciBhZGRpbmcgdGhlIGdhdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2VkaXRvckVsZW1lbnRzLkJsYWNrYm94fSBpbnN0YW5jZSBvZiB7QGxpbmsgQmxhY2tib3h9IHRoYXQgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIFtDYW52YXNdKC4vbW9kdWxlLUNhbnZhcy5odG1sKVxuICAgICAqL1xuICAgIG5ld0JsYWNrYm94KGlucHV0cywgb3V0cHV0cywgdGFibGUsIG5hbWUsIHgsIHksIHJlZnJlc2g9dHJ1ZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuYm94ZXMubGVuZ3RoO1xuXG4gICAgICAgIHRoaXMuYm94ZXNbaW5kZXhdID0gbmV3IGVkaXRvckVsZW1lbnRzLkJsYWNrYm94KFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dHMsXG4gICAgICAgICAgICAoLi4uaW5wdXRTdGF0ZXMpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZUlucHV0U3RhdGVzID0gbGluZS5zbGljZSgwLCBpbnB1dHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGV2ZXJ5IGlucHV0IHN0YXRlIG1hdGNoZXMgdGhlIGNvcnJlc3BvbmRpbmcgaW5wdXQgc3RhdGUgaW4gdGhpcyBsaW5lIG9mIHRoZSB0cnV0aCB0YWJsZVxuICAgICAgICAgICAgICAgICAgICBpZihpbnB1dFN0YXRlcy5ldmVyeSgodmFsdWUsIGluZGV4KSA9PiB2YWx1ZSA9PT0gbGluZUlucHV0U3RhdGVzW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgcmVzdCBvZiB0aGUgbGluZSBhcyBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lLnNsaWNlKGlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgbm90aGluZyBtYXRjaGVzLCBzZXQgYWxsIG91dHB1dHMgdG8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IEFycmF5KG91dHB1dHMpLCAoKSA9PiBMb2dpYy5zdGF0ZS51bmtub3duKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgKTtcblxuICAgICAgICBpZih4ICYmIHkpIHtcbiAgICAgICAgICAgIGxldCB0ciA9IG5ldyBlZGl0b3JFbGVtZW50cy5UcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHRyLnNldFRyYW5zbGF0ZSh4LCB5KTtcblxuICAgICAgICAgICAgdGhpcy5ib3hlc1tpbmRleF0uc3ZnT2JqLmFkZEF0dHIoe1widHJhbnNmb3JtXCI6IHRyLmdldCgpfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFwcGVuZEVsZW1lbnQodGhpcy5ib3hlc1tpbmRleF0sIHJlZnJlc2gpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmJveGVzW2luZGV4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBjb3JyZWN0IGluc3RhbmNlIG9mIGVkaXRvckVsZW1lbnRzLldpcmUgaW4gdGhlIENhbnZhcycgd2lyZXMgYnkgdGhlIHByb3ZpZGVkIGlkXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB3aXJlSWQgaWQgb2YgdGhlIHdpcmVcbiAgICAgKiBAcmV0dXJuIHtlZGl0b3JFbGVtZW50cy5XaXJlfSBpbnN0YW5jZSBvZiB0aGUgd2lyZVxuICAgICAqL1xuICAgIGdldFdpcmVCeUlkKHdpcmVJZCkge1xuICAgICAgICBmb3IgKGNvbnN0IHdpcmUgb2YgdGhpcy53aXJlcykge1xuICAgICAgICAgICAgaWYod2lyZS5zdmdPYmouaWQgPT09IHdpcmVJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aXJlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhbGwgd2lyZXMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIHRoZSBzcGVjaWZpZWQgY29ubmVjdG9yXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBjb25uZWN0b3JJZCBpZCBvZiB0aGUgY29ubmVjdG9yXG4gICAgICogQHJldHVybiB7U2V0fSBzZXQgb2YgSUQncyBvZiB0aGUgd2lyZXMgY29ubmVjdGVkIHRvIHRoaXMgY29ubmVjdG9yXG4gICAgICovXG4gICAgZ2V0V2lyZXNCeUNvbm5lY3RvcklkKGNvbm5lY3RvcklkKSB7XG4gICAgICAgIGxldCBjb25uZWN0b3IgPSB0aGlzLmdldENvbm5lY3RvckJ5SWQoY29ubmVjdG9ySWQpO1xuICAgICAgICByZXR1cm4gY29ubmVjdG9yLndpcmVJZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHdpcmUgdGhhdCBoYXMgdGhlIHByb3ZpZGVkIElEXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB3aXJlSWQgSUQgb2YgdGhlIHdpcmUgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIHJlbW92ZVdpcmVCeUlkKHdpcmVJZCkge1xuICAgICAgICBmb3IobGV0IGkgPSAwIDsgaSA8IHRoaXMud2lyZXMubGVuZ3RoIDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53aXJlc1tpXS5zdmdPYmouaWQgPT09IHdpcmVJZCkge1xuXG4gICAgICAgICAgICAgICAgbGV0IGNvbm5lY3RvcjEgPSB0aGlzLndpcmVzW2ldLnN0YXJ0Q29ubmVjdG9yO1xuICAgICAgICAgICAgICAgIGxldCBjb25uZWN0b3IyID0gdGhpcy53aXJlc1tpXS5lbmRDb25uZWN0b3I7XG5cbiAgICAgICAgICAgICAgICBjb25uZWN0b3IxLnJlbW92ZVdpcmVJZEFuZFVwZGF0ZSh3aXJlSWQpO1xuICAgICAgICAgICAgICAgIGNvbm5lY3RvcjIucmVtb3ZlV2lyZUlkQW5kVXBkYXRlKHdpcmVJZCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLndpcmVzW2ldLnN2Z09iai4kZWwucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy53aXJlcy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgd2lyZXMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIHRoZSBjb25uZWN0b3IgcHJvdmlkZWQgYnkgaXRzIElEXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBjb25uZWN0b3JJZCBJRCBvZiB0aGUgY29ubmVjdG9yXG4gICAgICovXG4gICAgcmVtb3ZlV2lyZXNCeUNvbm5lY3RvcklkKGNvbm5lY3RvcklkKSB7XG4gICAgICAgIGxldCBjb25uZWN0b3IgPSB0aGlzLmdldENvbm5lY3RvckJ5SWQoY29ubmVjdG9ySWQpO1xuXG4gICAgICAgIGNvbm5lY3Rvci53aXJlSWRzLmZvckVhY2god2lyZUlkID0+IHtcbiAgICAgICAgICAgIGxldCB3aXJlID0gdGhpcy5nZXRXaXJlQnlJZCh3aXJlSWQpO1xuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIG90aGVyIGNvbm5lY3RvciB0aGF0IGlzIHRoZSB3aXJlIGNvbm5lY3RlZCB0b1xuICAgICAgICAgICAgbGV0IG90aGVyQ29ubmVjdG9yID0gdGhpcy5nZXRDb25uZWN0b3JCeUlkKHdpcmUuZnJvbUlkLCB3aXJlKTtcbiAgICAgICAgICAgIGlmKG90aGVyQ29ubmVjdG9yLnN2Z09iai5pZD09PWNvbm5lY3RvcklkKSB7XG4gICAgICAgICAgICAgICAgb3RoZXJDb25uZWN0b3IgPSB0aGlzLmdldENvbm5lY3RvckJ5SWQod2lyZS50b0lkLCB3aXJlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSB3aXJlIHJlY29yZCBmcm9tIHRoZSBvdGhlciBjb25uZWN0b3JcbiAgICAgICAgICAgIG90aGVyQ29ubmVjdG9yLndpcmVJZHMuZGVsZXRlKHdpcmVJZCk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgd2lyZSByZXByZXNlbnRhdGlvbiB1c2luZyBqUXVlcnlcbiAgICAgICAgICAgICQoXCIjXCIgKyB3aXJlSWQpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAvLyBpZiBvdGhlckNvbm5lY3RvciBpcyBhbiBpbnB1dCBjb25uZWN0b3IsIHNldCBpdHMgc3RhdGUgdG8gdW5rbm93blxuICAgICAgICAgICAgaWYob3RoZXJDb25uZWN0b3IuaXNJbnB1dENvbm5lY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnROZXdTaW11bGF0aW9uKG90aGVyQ29ubmVjdG9yLCBMb2dpYy5zdGF0ZS51bmtub3duKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjbGVhciB0aGUgbGlzdCBvZiB3aXJlIElkc1xuICAgICAgICBjb25uZWN0b3Iud2lyZUlkcy5jbGVhcigpO1xuICAgICAgICAvLyBpZiBjb25uZWN0b3IgaXMgYW4gaW5wdXQgY29ubmVjdG9yLCBzZXQgaXRzIHN0YXRlIHRvIHVua25vd25cbiAgICAgICAgaWYoY29ubmVjdG9yLmlzSW5wdXRDb25uZWN0b3IpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rvci5zZXRTdGF0ZShMb2dpYy5zdGF0ZS51bmtub3duKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGNvcnJlY3QgaW5zdGFuY2Ugb2YgZWRpdG9yRWxlbWVudHMuQm94IGluIHRoZSBDYW52YXMnIGJveGVzIGJ5IHRoZSBwcm92aWRlZCBpZFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gYm94SWQgaWQgb2YgdGhlIGJveFxuICAgICAqIEByZXR1cm4ge2VkaXRvckVsZW1lbnRzLkJveH0gaW5zdGFuY2Ugb2YgdGhlIGJveFxuICAgICAqL1xuICAgIGdldEJveEJ5SWQoYm94SWQpIHtcbiAgICAgICAgZm9yKGxldCBpID0gMCA7IGkgPCB0aGlzLmJveGVzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgaWYodGhpcy5ib3hlc1tpXS5zdmdPYmouaWQ9PT1ib3hJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJveGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgY29ycmVjdCBpbnN0YW5jZSBvZiBlZGl0b3JFbGVtZW50cy5Cb3ggaW4gdGhlIENhbnZhcycgYm94ZXMgYnkgSUQgb2YgYSBjb25uZWN0b3IgdGhhdCBiZWxvbmdzIHRvIHRoaXMgYm94XG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBib3hJZCBpZCBvZiB0aGUgY29ubmVjdG9yXG4gICAgICogQHJldHVybiB7ZWRpdG9yRWxlbWVudHMuQm94fSBpbnN0YW5jZSBvZiB0aGUgYm94XG4gICAgICovXG4gICAgZ2V0Qm94QnlDb25uZWN0b3JJZChjb25uZWN0b3JJZCkge1xuICAgICAgICBmb3IobGV0IGkgPSAwIDsgaSA8IHRoaXMuYm94ZXMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib3hlc1tpXS5nZXRDb25uZWN0b3JCeUlkKGNvbm5lY3RvcklkKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm94ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBpbnN0YW5jZSBvZiBhIGNvbm5lY3RvciBiYXNlZCBvbiBpdCdzIElEIChhbmQgYWxzbyBvbiBhbiBpbnN0YW5jZSBvZiBlZGl0b3JFbGVtZW50cy5XaXJlIGlmIHByb3ZpZGVkKVxuICAgICAqXG4gICAgICogVGhlIHdpcmUgdmFyaWFibGUgaXMgdXNlZCBhcyBoZXVyaXN0aWM6IFdoZW4gd2Uga25vdyB0aGUgd2lyZSwgd2UgaGF2ZSB0byBjaGVjayBvbmx5XG4gICAgICogdHdvIGdhdGVzIGluc3RlYWQgb2YgYWxsIG9mIHRoZW1cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbm5lY3RvcklkIGlkIG9mIHRoZSBjb25uZWN0b3JcbiAgICAgKiBAcGFyYW0gIHtlZGl0b3JFbGVtZW50cy5XaXJlfSBbd2lyZV0gICAgICBpbnN0YW5jZSBvZiB0aGUgV2lyZSB0aGF0IGlzIGNvbm5lY3RlZCB0byB0aGlzIGNvbm5lY3RvclxuICAgICAqIEByZXR1cm4ge2VkaXRvckVsZW1lbnRzLkNvbm5lY3Rvcn0gICAgICAgIGluc3RhbmNlIG9mIHRoZSBjb25uZWN0b3JcbiAgICAgKi9cbiAgICBnZXRDb25uZWN0b3JCeUlkKGNvbm5lY3RvcklkLCB3aXJlPXVuZGVmaW5lZCkge1xuXG4gICAgICAgIGlmKHdpcmUhPT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHdlIGtub3cgdGhlIHdpcmUgLS0gd2UgY2FuIGNoZWNrIG9ubHkgZ2F0ZXMgYXQgdGhlIGVuZHMgb2YgdGhpcyB3aXJlXG4gICAgICAgICAgICBsZXQgY29ubmVjdG9yID0gd2lyZS5zdGFydEJveC5nZXRDb25uZWN0b3JCeUlkKGNvbm5lY3RvcklkKVxuICAgICAgICAgICAgaWYgKCFjb25uZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0b3IgPSB3aXJlLmVuZEJveC5nZXRDb25uZWN0b3JCeUlkKGNvbm5lY3RvcklkKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RvclxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBkbyBub3Qga25vdyB0aGUgd2lyZSAtLSB3ZSBoYXZlIHRvIGNoZWNrIGFsbCBnYXRlc1xuICAgICAgICAgICAgZm9yIChjb25zdCBib3ggb2YgdGhpcy5ib3hlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RvciA9IGJveC5nZXRDb25uZWN0b3JCeUlkKGNvbm5lY3RvcklkKVxuICAgICAgICAgICAgICAgIGlmKGNvbm5lY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdG9yXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsb2dpY2FsIGpRdWVyeSB0YXJnZXQgYmFzZWQgb24gdGhlIGZhY3R1YWwgalF1ZXJ5IHRhcmdldC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBvYmplY3QsIHRoYXQgdXNlciBpbnRlcmFjdGVkIHdpdGgsIGlzIG5vdCBhIGNvbm5lY3RvciBhbmQgaXMgaW4gYSBncm91cCxcbiAgICAgKiByZXR1cm4gdGhlIGdyb3VwIGpRdWVyeSBvYmplY3QgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgalF1ZXJ5IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHt0YXJnZXR9IHRhcmdldCBqUXVlcnkgdGFyZ2V0IG9mIHRoZSBvYmplY3QgdXNlciBpbnRlcmFjdGVkIHdpdGhcbiAgICAgKiBAcmV0dXJuIHt0YXJnZXR9ICAgICAgICBqUXVlcnkgdGFyZ2V0IG9mIHRoZSBvYmplY3QgdXNlciB3YW50ZWQgdG8gaW50ZXJhY3Qgd2l0aFxuICAgICAqL1xuICAgIGdldFJlYWxKUXVlcnlUYXJnZXQodGFyZ2V0KSB7XG4gICAgICAgIGxldCAkdGFyZ2V0ID0gJCh0YXJnZXQpO1xuICAgICAgICBpZighJHRhcmdldC5oYXNDbGFzcyhcImNvbm5lY3RvclwiKSAmJiAkdGFyZ2V0LnBhcmVudHMoJ2cnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAkdGFyZ2V0ID0gJHRhcmdldC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHdoaWxlICgkdGFyZ2V0LnByb3AoXCJ0YWdOYW1lXCIpICE9PSBcIkdcIiAmJiAkdGFyZ2V0LnByb3AoXCJ0YWdOYW1lXCIpICE9PSBcImdcIikge1xuICAgICAgICAgICAgICAgICR0YXJnZXQgPSAkdGFyZ2V0LnBhcmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkdGFyZ2V0O1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgdGhlIGVkaXRvckVsZW1lbnQgdGhhdCB1c2VyIGludGVyYWN0ZWQgd2l0aCwgdGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgaXMgYSBqUXVlcnkgZWxlbWVudFxuICAgIC8qKlxuICAgICAqIEdldCBpbnN0YW5jZSBvZiBzb21lIG9iamVjdCBmcm9tIGVkaXRvckVsZW1lbnQgYmFzZWQgb24gdGhlIGpRdWVyeSB0YXJnZXRcbiAgICAgKiBAcGFyYW0gIHt0YXJnZXR9IHRhcmdldCBqUXVlcnkgdGFyZ2V0IHRoYXQgdXNlciBpbnRlcmFjdGVkIHdpdGhcbiAgICAgKiBAcmV0dXJuIHtlZGl0b3JFbGVtZW50cy5OZXR3b3JrRWxlbWVudH0gaW5zdGFuY2Ugb2YgYW4gb2JqZWN0IGRlcml2ZWQgZnJvbSBlZGl0b3JFbGVtZW50cy5OZXR3b3JrRWxlbWVudCB0aGF0IHRoZSB1c2VyIGludGVyYWN0ZWQgd2l0aFxuICAgICAqL1xuICAgIGdldFJlYWxUYXJnZXQodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQ9PT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBldmVudHkgc2UgbXVzZWppIHpwcmFjb3ZhdCB0YWR5LCBwcm90b3plIHYgU1ZHIHNlIGV2ZW50eSBuZXByb3BhZ3VqaVxuICAgICAgICBsZXQgJHRhcmdldCA9ICQodGFyZ2V0KTtcblxuICAgICAgICBpZigkdGFyZ2V0Lmhhc0NsYXNzKFwiY29ubmVjdG9yXCIpKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgY29ubmVjdG9yLCBkb24ndCB0cmF2ZXJzZSBncm91cHNcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbm5lY3RvckJ5SWQoJHRhcmdldC5hdHRyKCdpZCcpKTtcbiAgICAgICAgfSBlbHNlIGlmKCR0YXJnZXQucGFyZW50cygnZycpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIHRoaXMgZWxlbWVudCBpcyBpbiBhIGdyb3VwIGFuZCBpdCBpcyBub3QgYSBjb25uZWN0b3JcblxuICAgICAgICAgICAgLy8gdHJhdmVyc2luZyB1cCB0aGUgRE9NIHRyZWUgdW50aWwgd2UgZmluZCB0aGUgY2xvc2VzdCBncm91cFxuICAgICAgICAgICAgbGV0ICRwYXJlbnRHcm91cCA9ICR0YXJnZXQucGFyZW50KCk7XG4gICAgICAgICAgICB3aGlsZSAoJHBhcmVudEdyb3VwLnByb3AoXCJ0YWdOYW1lXCIpICE9PSBcIkdcIiAmJiAkcGFyZW50R3JvdXAucHJvcChcInRhZ05hbWVcIikgIT09IFwiZ1wiKSB7XG4gICAgICAgICAgICAgICAgJHBhcmVudEdyb3VwID0gJHBhcmVudEdyb3VwLnBhcmVudCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0cnkgdG8gbWF0Y2ggdGhlIGpRdWVyeSBlbGVtZW50IHRvIHRoZSBsb2dpY2FsIGVsZW1lbnQgdXNpbmcgRE9NIGNsYXNzZXNcblxuICAgICAgICAgICAgaWYoJHBhcmVudEdyb3VwLmhhc0NsYXNzKFwiYm94XCIpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIGJveFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJveEJ5SWQoJHBhcmVudEdyb3VwLmF0dHIoJ2lkJykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKCRwYXJlbnRHcm91cC5oYXNDbGFzcyhcIndpcmVcIikpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgd2lyZVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFdpcmVCeUlkKCRwYXJlbnRHcm91cC5hdHRyKCdpZCcpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZm91bmQgYSBncm91cCB0aGF0IGNvbnRhaW5zIHRoZSB0YXJnZXQsIGJ1dCB0aGlzIGdyb3VwIGRvZXMgbm90IG1hdGNoIGFueSBrbm93biBlbGVtZW50IHR5cGVzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgZG9lcyBub3QgbWF0Y2ggYW55IGtub3duIGVsZW1lbnQgdHlwZXNcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZWxlbWVudCB0byB0aGUgQ2FudmFzXG4gICAgICogQHBhcmFtICB7ZWRpdG9yRWxlbWVudHMuTmV0d29ya0VsZW1lbnR9ICBlbGVtZW50IEVsZW1lbnQgdGhhdCB3aWxsIGJlIGFkZGVkIG9uIHRoZSBDYW52YXNcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbcmVmcmVzaD10cnVlXSBpZiB0cnVlLCB0aGUgU1ZHIGRvY3VtZW50IHdpbGwgYmUgcmVsb2FkZWQgYWZ0ZXIgYWRkaW5nIHRoaXMgZWxlbWVudFxuICAgICAqL1xuICAgIGFwcGVuZEVsZW1lbnQoZWxlbWVudCwgcmVmcmVzaCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRKUXVlcnlPYmplY3QoZWxlbWVudC5nZXQoKSwgcmVmcmVzaCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kIGEgalF1ZXJ5IGVsZW1lbnQgdG8gdGhlIFNWRyBkb2N1bWVudCAoaGVscGVyIGZvciB0aGlzLmFwcGVuZEVsZW1lbnQpXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgb2JqZWN0ICAgICAgICAgalF1ZXJ5IGVsZW1lbnQgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTVkcgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbcmVmcmVzaD10cnVlXSBpZiB0cnVlLCB0aGUgU1ZHIGRvY3VtZW50IHdpbGwgYmUgcmVsb2FkZWQgYWZ0ZXIgYWRkaW5nIHRoaXMgZWxlbWVudFxuICAgICAqL1xuICAgIGFwcGVuZEpRdWVyeU9iamVjdChvYmplY3QsIHJlZnJlc2ggPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuJHN2Zy5hcHBlbmQob2JqZWN0KTtcbiAgICAgICAgaWYocmVmcmVzaClcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBwYXR0ZXJuIHRvIHRoZSBkZWZpbml0aW9ucyBlbGVtZW50IGluIHRoZSBTVkcgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0ge3N2Z09iai5QYXR0ZXJufSBwYXR0ZXJuIHBhdHRlcm4gdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSA8ZGV2cz4gZWxlbWVudCBpbiB0aGUgU1ZHIGRvY3VtZW50XG4gICAgICovXG4gICAgYWRkUGF0dGVybihwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMuJGRlZnMuYXBwZW5kKHBhdHRlcm4pO1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWxvYWQgdGhlIFNWRyBkb2N1bWVudCAobmVlZGVkIHRvIGRpc3BsYXkgYSBuZXdseSBhcHBlbmRlZCBqUXVlcnkgb2JqZWN0KVxuICAgICAqL1xuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuJHN2Zy5odG1sKHRoaXMuJHN2Zy5odG1sKCkpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNWRyBkb2N1bWVudCBoYXMgYmVlbiByZWxvYWRlZC5cIilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IHRoZSBjb250ZXh0IG1lbnUgb24gdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSAge251bWJlcn0geCAgICAgICBob3Jpem9udGFsIHBvc2l0aW9uIGluIENTUyBwaXhlbHNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgICAgICAgdmVydGljYWwgcG9zaXRpb24gaW4gQ1NTIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge2pRdWVyeS5lbGVtZW50fSAkdGFyZ2V0IHRoZSBpdGVtIHVzZXIgY2xpY2tlZCBvbiAodXNlZCB0byBkaXNwbGF5IFwicmVtb3ZlIHRoaXMgZWxlbWVudFwiLXR5cGUgaXRlbXMgaW4gdGhlIG1lbnUpXG4gICAgICovXG4gICAgZGlzcGxheUNvbnRleHRNZW51KHgsIHksICR0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudS5kaXNwbGF5KHgsIHksICR0YXJnZXQpO1xuXG4gICAgICAgIC8vIGlmIHR1dG9yaWFsIGV4aXN0cywgY2FsbCB0dXRvcmlhbCBjYWxsYmFja1xuICAgICAgICBpZih0aGlzLnR1dG9yaWFsKSB7XG4gICAgICAgICAgICB0aGlzLnR1dG9yaWFsLm9uQ29udGV4dE1lbnVPcGVuZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhpZGUgdGhlIGNvbnRleHQgbWVudVxuICAgICAqL1xuICAgIGhpZGVDb250ZXh0TWVudSgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudS5oaWRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc25hcCBhIHZhbHVlIHRvIGEgZ3JpZFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdmFsdWUgdmFsdWUgaW4gU1ZHIHBpeGVsc1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgdGhlIHZhbHVlIHJvdW5kZWQgdG8gdGhlIGNsb3Nlc3QgbnVtYmVyIGRpdmlzaWJsZSBieSB0aGUgZ3JpZCBzaXplXG4gICAgICovXG4gICAgc25hcFRvR3JpZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAvIHRoaXMuZ3JpZFNpemUpICogdGhpcy5ncmlkU2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGdyaWQgcGl4ZWxzIHRvIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlIGRpc3RhbmNlIGluIGdyaWQgcGl4ZWxzXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICBkaXN0YW5jZSBpbiBTVkcgcGl4ZWxzXG4gICAgICovXG4gICAgZ3JpZFRvU1ZHKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAqIHRoaXMuZ3JpZFNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBTVkcgcGl4ZWxzIHRvIGdyaWQgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIGRpc3RhbmNlIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgZGlzdGFuY2UgaW4gZ3J1ZCBwaXhlbHNcbiAgICAgKi9cbiAgICBTVkdUb0dyaWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIC8gdGhpcy5ncmlkU2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdGF0aWMgZnVuY3Rpb24gZm9yIHNuYXBwaW5nIGEgdmFsdWUgdG8gYSBncmlkXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWx1ZSB2YWx1ZSBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBncmlkU2l6ZSBzaXplIG9mIHRoZSBncmlkIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIHRoZSB2YWx1ZSByb3VuZGVkIHRvIHRoZSBjbG9zZXN0IG51bWJlciBkaXZpc2libGUgYnkgdGhlIGdyaWQgc2l6ZVxuICAgICAqL1xuICAgIHN0YXRpYyBzbmFwVG9HcmlkKHZhbHVlLCBncmlkU2l6ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAvIGdyaWRTaXplKSAqIGdyaWRTaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1vdmUgYW4gZWxlbWVudCB0byB0aGUgZnJvbnQgaW4gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gb2JqSWQgaWQgb2YgdGhlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBtb3ZlVG9Gcm9udEJ5SWQob2JqSWQpIHtcbiAgICAgICAgdGhpcy4kc3ZnLmFwcGVuZCgkKFwiI1wiICsgb2JqSWQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtb3ZlIGFuIGVsZW1lbnQgdG8gdGhlIGJhY2sgaW4gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gb2JqSWQgaWQgb2YgdGhlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBtb3ZlVG9CYWNrQnlJZChvYmpJZCkge1xuICAgICAgICAkKFwiI1wiICsgdGhpcy5iYWNrZ3JvdW5kLmlkKVxuICAgICAgICAgICAgLmFmdGVyKCQoXCIjXCIgKyBvYmpJZCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBzZXQgb2Ygbm9kZXMsIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIHdpcmluZyBhdCBhbnkgY2lyY3Vtc3RhbmNlc1xuICAgICAqIEByZXR1cm4ge1NldH0gc2V0IG9mIG5vZGVzIChvYmplY3RzIGNvbnRhaW5pbmcgeCBhbmQgeSBjb29yZGluYXRlcykgdGhhdCBhcmUgbm90IHN1aXRhYmxlIGZvciB3aXJpbmdcbiAgICAgKi9cbiAgICBnZXROb25Sb3V0YWJsZU5vZGVzKCkge1xuICAgICAgICBsZXQgYmxvY2tlZE5vZGVzID0gbmV3IFNldCgpO1xuICAgICAgICAvLyBmb3IgZWFjaCBib3hcbiAgICAgICAgZm9yKGNvbnN0IGJveCBvZiB0aGlzLmJveGVzKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2xhdGUgPSBib3guZ2V0R3JpZFBpeGVsVHJhbnNmb3JtKCkuZ2V0VHJhbnNsYXRlKCk7XG5cbiAgICAgICAgICAgIC8vIGZvciBlYWNoIGl0ZW0gaW4gYmxvY2tlZE5vZGVzIChzZXQgb2YgYmxvY2tlZCBub2RlcyB3aXRoIGNvb3JkaW5hdGVzIHJlbGF0aXZlXG4gICAgICAgICAgICAvLyB0byB0aGUgbGVmdCB1cHBlciBjb3JuZXIgb2YgcmVjdDsgdW5pdCB1c2VkIGlzIFwib25lIGdyaWRTaXplXCIpIGNvbnZlcnQgdGhlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAvLyB0byBhYnNvbHV0ZSAobXVsdGlwbGUgd2l0aCBncmlkU2l6ZSBhbmQgYWRkIHBvc2l0aW9uIG9mIHJlY3QpIGFuZCBhZGQgdGhlIHJlc3VsdCB0byB0aGUgc2V0XG4gICAgICAgICAgICBmb3IoY29uc3Qgbm9kZSBvZiBib3guYmxvY2tlZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tlZE5vZGVzLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IHRyYW5zbGF0ZS54ICsgbm9kZS54LFxuICAgICAgICAgICAgICAgICAgICB5OiB0cmFuc2xhdGUueSArIG5vZGUueVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRk9SIERFQlVHIE9OTFk6IGRpc3BsYXkgdGhlIG5vbiByb3V0YWJsZSBub2Rlc1xuICAgICAgICAvKlxuXG4gICAgICAgIGlmKHRoaXMubm9kZURpc3BsYXkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVjdGFuZ2xlSWQgb2YgdGhpcy5ub2RlRGlzcGxheSkge1xuICAgICAgICAgICAgICAgICQoYCMke3JlY3RhbmdsZUlkfWApLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ub2RlRGlzcGxheSA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBibG9ja2VkTm9kZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmdyaWRUb1NWRyhub2RlLngpO1xuICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMuZ3JpZFRvU1ZHKG5vZGUueSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHcgPSA0O1xuICAgICAgICAgICAgY29uc3QgcCA9IHcgLyAyO1xuXG4gICAgICAgICAgICBjb25zdCBub2RlUmVjdGFuZ2xlID0gbmV3IHN2Z09iai5SZWN0YW5nbGUoeCAtIHAsIHkgLSBwLCB3LCB3LCBcInJlZFwiLCBcIm5vbmVcIilcbiAgICAgICAgICAgIHRoaXMubm9kZURpc3BsYXkucHVzaChub2RlUmVjdGFuZ2xlLmlkKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kRWxlbWVudChub2RlUmVjdGFuZ2xlLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcblxuICAgICAgICAqL1xuICAgICAgICAvLyBFTkQgRk9SIERFQlVHIE9OTFlcblxuICAgICAgICAvLyByZXR1cm4gdGhlIHNldFxuICAgICAgICByZXR1cm4gYmxvY2tlZE5vZGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBzZXQgb2Ygbm9kZXMsIHRoYXQgYXJlIGluY29udmVuaWVudCBmb3Igd2lyaW5nLCBidXQgY2FuIGJlIHVzZWQsIGp1c3QgYXJlIG5vdCBwcmVmZXJyZWRcbiAgICAgKiBAcmV0dXJuIHtTZXR9IHNldCBvZiBub2RlcyAob2JqZWN0cyBjb250YWluaW5nIHggYW5kIHkgY29vcmRpbmF0ZXMpIHRoYXQgYXJlIG5vdCBwcmVmZXJyZWQgZm9yIHdpcmluZ1xuICAgICAqL1xuICAgIGdldEluY29udmVuaWVudE5vZGVzKGlnbm9yZVdpcmVJZCkge1xuICAgICAgICBsZXQgaW5jb252ZW5pZW50Tm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8vIGZvciBlYWNoIHdpcmVcblxuICAgICAgICBmb3IoY29uc3Qgd2lyZSBvZiB0aGlzLndpcmVzKSB7XG4gICAgICAgICAgICBpZihpZ25vcmVXaXJlSWQ9PT11bmRlZmluZWQgfHwgaWdub3JlV2lyZUlkIT09d2lyZS5pZCkge1xuICAgICAgICAgICAgICAgIGlmKHdpcmUuaW5jb252ZW5pZW50Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHdpcmUuaW5jb252ZW5pZW50Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY29udmVuaWVudE5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZPUiBERUJVRyBPTkxZOiBkaXNwbGF5IHRoZSBpbmNvbnZlbmllbnQgbm9kZXNcbiAgICAgICAgLypcblxuICAgICAgICBpZih0aGlzLmluY29udmVuaWVudE5vZGVEaXNwbGF5KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlY3RhbmdsZUlkIG9mIHRoaXMuaW5jb252ZW5pZW50Tm9kZURpc3BsYXkpIHtcbiAgICAgICAgICAgICAgICAkKGAjJHtyZWN0YW5nbGVJZH1gKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5jb252ZW5pZW50Tm9kZURpc3BsYXkgPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgaW5jb252ZW5pZW50Tm9kZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmdyaWRUb1NWRyhub2RlLngpO1xuICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMuZ3JpZFRvU1ZHKG5vZGUueSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHcgPSA0O1xuICAgICAgICAgICAgY29uc3QgcCA9IHcgLyAyO1xuXG4gICAgICAgICAgICBjb25zdCBub2RlUmVjdGFuZ2xlID0gbmV3IHN2Z09iai5SZWN0YW5nbGUoeCAtIHAsIHkgLSBwLCB3LCB3LCBcIm9yYW5nZVwiLCBcIm5vbmVcIilcbiAgICAgICAgICAgIHRoaXMuaW5jb252ZW5pZW50Tm9kZURpc3BsYXkucHVzaChub2RlUmVjdGFuZ2xlLmlkKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kRWxlbWVudChub2RlUmVjdGFuZ2xlLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcblxuICAgICAgICAqL1xuICAgICAgICAvLyBFTkQgRk9SIERFQlVHIE9OTFlcblxuICAgICAgICAvLyByZXR1cm4gdGhlIHNldFxuICAgICAgICByZXR1cm4gaW5jb252ZW5pZW50Tm9kZXM7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7XG4gICAgZ2V0TGlicmFyeSxcbiAgICBnZXROZXR3b3JrRnJvbUxpYnJhcnlcbn0gZnJvbSAnLi9uZXR3b3JrTGlicmFyeSc7XG5cbmltcG9ydCB7R2F0ZX0gZnJvbSAnLi9lZGl0b3JFbGVtZW50cydcblxuLyoqXG4gKiBJdGVtIGluIHRoZSBbQ29udGV4dE1lbnVdKC4vbW9kdWxlLUNvbnRleHRNZW51Lmh0bWwpLiBDb250ZXh0TWVudUl0ZW1zIGNhbiBiZSBuZXN0ZWQgdXNpbmcgdGhlIGFwcGVuZEl0ZW0gZnVuY3Rpb24uXG4gKi9cbmNsYXNzIENvbnRleHRNZW51SXRlbSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgICAgICAgICAgdGV4dCBvbiB0aGUgYnV0dG9uXG4gICAgICogQHBhcmFtIHtDb250ZXh0TWVudX0gY29udGV4dE1lbnUgaW5zdGFuY2Ugb2YgdGhlIFtDb250ZXh0TWVudV0oLi9tb2R1bGUtQ29udGV4dE1lbnUuaHRtbCkgdGhpcyBpdGVtIGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbGlja0Z1bmN0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB1c2VyIGNsaWNrcyB0aGlzIGl0ZW1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBjb250ZXh0TWVudSwgY2xpY2tGdW5jdGlvbikge1xuICAgICAgICAvKipcbiAgICAgICAgICogdGV4dCBvbiB0aGUgYnV0dG9uXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpbnN0YW5jZSBvZiB0aGUgW0NvbnRleHRNZW51XSguL21vZHVsZS1Db250ZXh0TWVudS5odG1sKSB0aGlzIGl0ZW0gYmVsb25ncyB0b1xuICAgICAgICAgKiBAdHlwZSB7Q29udGV4dE1lbnV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRleHRNZW51ID0gY29udGV4dE1lbnU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGpRdWVyeSBlbGVtZW50IHJlcHJlc2VudGluZyBET00gY29udGVudCBvZiB0aGlzIG1lbnUgaXRlbVxuICAgICAgICAgKiBAdHlwZSB7alF1ZXJ5LmVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbCA9ICQoXCI8bGk+XCIpLnRleHQodGV4dCk7XG5cbiAgICAgICAgLy8gc2V0IHVwIGNsaWNrIGNhbGxiYWNrIGlmIGNsaWNrRnVuY3Rpb24gaXMgZGVmaW5lZFxuICAgICAgICBpZihjbGlja0Z1bmN0aW9uIT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAkKHRoaXMuJGVsKS5jbGljayhcbiAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tGdW5jdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0TWVudS5oaWRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBqUXVlcnkgZWxlbWVudCBjb250YWluaW5nIHRoZSBzdWJtZW51IChvciB1bmRlZmluZWQsIGlmIGl0ZW0gaGFzIG5vIHN1Yml0ZW1zKVxuICAgICAgICAgKiBAdHlwZSB7alF1ZXJ5LmVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRzdWJtZW51ID0gdW5kZWZpbmVkXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN1Ym1lbnUgaXRlbSBjb3VudGVyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLml0ZW1Db3VudCA9IDBcblxuICAgICAgICAvLyBzZXQgaG92ZXIgY2FsbGJhY2tcbiAgICAgICAgJCh0aGlzLiRlbCkuaG92ZXIoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvLyBtb3VzZSBvblxuXG4gICAgICAgICAgICBpZih0aGlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRzdWJtZW51LmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB0aGlzLiRlbC5vZmZzZXQoKS50b3AsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuJGVsLnBhcmVudCgpLm9mZnNldCgpLmxlZnQgKyB0aGlzLiRlbC5wYXJlbnQoKS53aWR0aCgpLFxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRNZW51LiRlbC5hZnRlcih0aGlzLiRzdWJtZW51KTtcblxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgIC8vIG1vdXNlIG91dFxuICAgICAgICAgICAgaWYodGhpcy4kc3VibWVudSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHN1Ym1lbnUuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJub25lXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkbyBub3Qgc3RvcCBldmVudCBwcm9wYWdhdGlvbiwgaGVyZSBpdCBpcyB3YW50ZWRcbiAgICAgICAgICAgIC8vIChiZWNhdXNlIHN1Ym1lbnUgb3ZlcnJpZGVzIGRpc3BsYXk6IG5vbmUgd2hlbiB1c2VyIG1vdmVzIGZyb20gdGhpcyBtZW51IGl0ZW0gdG8gdGhlIHN1Ym1lbnUpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5zdGFuY2Ugb2YgW0NhbnZhc10oLi9tb2R1bGUtQ2FudmFzLmh0bWwpIHRoaXMgbWVudSBiZWxvbmdzIHRvXG4gICAgICogQHR5cGUge0NhbnZhc31cbiAgICAgKi9cbiAgICBnZXQgcGFyZW50U1ZHKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0TWVudS5wYXJlbnRTVkc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBzdWJtZW51XG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1Db3VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSBDU1MgY2xhc3MgdG8gdGhpcyBpdGVtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNscyBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgYWRkQ2xhc3MoY2xzKSB7XG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKGNscyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFwcGVuZCBhIG5lc3RlZCB7QGxpbmsgQ29udGV4dE1lbnVJdGVtfSB0byB0aGlzIGl0ZW1cbiAgICAgKiBAcGFyYW0gIHtDb250ZXh0TWVudUl0ZW19IGl0ZW0gaXRlbSB0aGF0IHdpbGwgYmUgYXBwZW5kZWRcbiAgICAgKi9cbiAgICBhcHBlbmRJdGVtKGl0ZW0pIHtcbiAgICAgICAgaWYoIXRoaXMuJHN1Ym1lbnUpIHtcbiAgICAgICAgICAgIHRoaXMuJHN1Ym1lbnUgPSAkKFwiPHVsPlwiKS5hZGRDbGFzcyhcInN1Ykxpc3RcIik7XG4gICAgICAgICAgICB0aGlzLiRzdWJtZW51LmhvdmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiRzdWJtZW51LmNzcyhcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcbiAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiRzdWJtZW51LmNzcyhcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRzdWJtZW51LmFwcGVuZChpdGVtLiRlbCk7XG5cbiAgICAgICAgdGhpcy5pdGVtQ291bnQrKztcblxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgalF1ZXJ5IGVsZW1lbnQgb2YgdGhpcyBtZW51IGl0ZW1cbiAgICAgKiBAcmV0dXJuIHtqUXVlcnkuZWxlbWVudH0galF1ZXJ5IGVsZW1lbnQgY29udGFpbmluZyBhbGwgRE9NIGNvbnRlbnQgZm9yIHRoaXMgbWVudSBpdGVtXG4gICAgICovXG4gICAgZ2V0IGpRdWVyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsO1xuICAgIH1cblxuICAgIGdldCBqUXVlcnlTdWJtZW51KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc3VibWVudTtcbiAgICB9XG59XG5cbi8qKlxuICogTWVudSBpdGVtIHRoYXQgaGFzIGEgY3VzdG9tIGNsaWNrIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgYWRkcyBhIHtAbGluayBHYXRlfSBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgdG8gdGhlIFtDYW52YXNdKC4vbW9kdWxlLUNhbnZhcy5odG1sKVxuICogQGV4dGVuZHMgQ29udGV4dE1lbnVJdGVtXG4gKi9cbmNsYXNzIEdhdGVNZW51SXRlbSBleHRlbmRzIENvbnRleHRNZW51SXRlbSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgICAgICAgIHR5cGUgb2YgdGhlIGdhdGUge0BsaW5rIEdhdGV9IChhbmQsIG9yLCAuLi4pXG4gICAgICogQHBhcmFtIHtDb250ZXh0TWVudX0gY29udGV4dE1lbnUgaW5zdGFuY2Ugb2YgdGhlIFtDb250ZXh0TWVudV0oLi9tb2R1bGUtQ29udGV4dE1lbnUuaHRtbCkgdGhhdCB0aGlzIGl0ZW0gYmVsb25ncyB0b1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGNvbnRleHRNZW51KSB7XG4gICAgICAgIHN1cGVyKFxuICAgICAgICAgICAgYCR7dHlwZS50b1VwcGVyQ2FzZSgpfSBnYXRlYCxcbiAgICAgICAgICAgIGNvbnRleHRNZW51LFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U1ZHLm5ld0dhdGUoXG4gICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U1ZHLnNuYXBUb0dyaWQodGhpcy5wYXJlbnRTVkcudmlld2JveC50cmFuc2Zvcm1YKGNvbnRleHRNZW51LnBvc2l0aW9uLngpKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTVkcuc25hcFRvR3JpZCh0aGlzLnBhcmVudFNWRy52aWV3Ym94LnRyYW5zZm9ybVkoY29udGV4dE1lbnUucG9zaXRpb24ueSkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogTWVudSBpdGVtIHRoYXQgaGFzIGEgY3VzdG9tIGNsaWNrIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgYWRkcyBhIHNwZWNpZmllZCB7QGxpbmsgQmxhY2tib3h9IHRvIHRoZSBbQ2FudmFzXSguL21vZHVsZS1DYW52YXMuaHRtbClcbiAqIEBleHRlbmRzIENvbnRleHRNZW51SXRlbVxuICovXG5jbGFzcyBCbGFja2JveE1lbnVJdGVtIGV4dGVuZHMgQ29udGV4dE1lbnVJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBmaWxlLCBjb250ZXh0TWVudSkge1xuICAgICAgICBzdXBlcihcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBjb250ZXh0TWVudSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICBnZXROZXR3b3JrRnJvbUxpYnJhcnkoZmlsZSkudGhlbigoe2JsYWNrYm94LCBuYW1lfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7aW5wdXRzLCBvdXRwdXRzLCB0YWJsZX0gPSBibGFja2JveDtcblxuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIG5hbWUgc3BlY2lmaWVkIGluIHRoZSBibGFja2JveCBpdGVtLCBpZiBpdCBkb2VzIG5vdCBleGlzdCwgdXNlIHRoZSBuYW1lIGZvciB0aGUgbmV0d29ya1xuICAgICAgICAgICAgICAgICAgICBsZXQgdXNlZE5hbWUgPSBibGFja2JveC5uYW1lIHx8IG5hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTVkcubmV3QmxhY2tib3goXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VkTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U1ZHLnNuYXBUb0dyaWQodGhpcy5wYXJlbnRTVkcudmlld2JveC50cmFuc2Zvcm1YKGNvbnRleHRNZW51LnBvc2l0aW9uLngpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U1ZHLnNuYXBUb0dyaWQodGhpcy5wYXJlbnRTVkcudmlld2JveC50cmFuc2Zvcm1ZKGNvbnRleHRNZW51LnBvc2l0aW9uLnkpKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgIH1cbn1cblxuY2xhc3MgTmV0d29ya01lbnVJdGVtIGV4dGVuZHMgQ29udGV4dE1lbnVJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBmaWxlLCBjb250ZXh0TWVudSkge1xuICAgICAgICBzdXBlcihcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBjb250ZXh0TWVudSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICBnZXROZXR3b3JrRnJvbUxpYnJhcnkoZmlsZSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTVkcuaW1wb3J0RGF0YShcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHRoaXMucGFyZW50U1ZHLnZpZXdib3gudHJhbnNmb3JtWChjb250ZXh0TWVudS5wb3NpdGlvbi54KSAvIHRoaXMucGFyZW50U1ZHLmdyaWRTaXplKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQodGhpcy5wYXJlbnRTVkcudmlld2JveC50cmFuc2Zvcm1ZKGNvbnRleHRNZW51LnBvc2l0aW9uLnkpIC8gdGhpcy5wYXJlbnRTVkcuZ3JpZFNpemUpXG4gICAgICAgICAgICAgICAgICAgICkudGhlbih3YXJuaW5ncyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHdhcm5pbmcgb2Ygd2FybmluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNWRy5tZXNzYWdlcy5uZXdXYXJuaW5nTWVzc2FnZSh3YXJuaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTVkcubWVzc2FnZXMubmV3RXJyb3JNZXNzYWdlKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICApXG4gICAgfVxufVxuXG4vKiogQG1vZHVsZSBDb250ZXh0TWVudSAqL1xuLyoqXG4gKiBDb250ZXh0TWVudSByZXByZXNlbnRzIHRoZSBtZW51IHRoYXQgaXMgZGlzcGxheWVkIHRvIHRoZSB1c2VyIHdoZW4gdGhleSByaWdodCBjbGljayBvbiBhIGNhbnZhcy5cbiAqIFRoaXMgbWVudSBhbGxvd3MgdXNlciB0byBhZGQgZWxlbWVudHMgdG8gdGhlIENhbnZhcyBhbmQgaW4gdGhlIGNhc2UgdGhhdCB1c2VyIHJpZ2h0Y2xpY2tlZFxuICogb24gYSBzcGVjaWZpYyBlbGVtZW50LCB0aGlzIG1lbnUgYWxsb3dzIHRoZW0gdG8gcmVtb3ZlIHRoaXMgZWxlbWVudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udGV4dE1lbnUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzfSBwYXJlbnRTVkcgaW5zdGFuY2Ugb2YgW0NhbnZhc10oLi9tb2R1bGUtQ2FudmFzLmh0bWwpIHRoaXMgbWVudSBiZWxvbmdzIHRvXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyZW50U1ZHKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpbnN0YW5jZSBvZiBbQ2FudmFzXSguL21vZHVsZS1DYW52YXMuaHRtbCkgdGhpcyBtZW51IGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHR5cGUge0NhbnZhc31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyZW50U1ZHID0gcGFyZW50U1ZHO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb3NpdGlvbiBvZiB0aGUgY29udGV4dCBtZW51LiBJdCBpcyB1c2VkIHRvIGFkZCB0aGUgbmV3IGVsZW1lbnRzIHRvIHRoZSBjb3JyZWN0IHBvc2l0aW9uIG9uIHRoZSBDYW52YXMuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0ge1xuICAgICAgICAgICAgeDogMCwgeTogMFxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBqUXVlcnkgZWxlbWVudCBjb250YWluaW5nIHRoZSBjb250ZXh0IG1lbnVcbiAgICAgICAgICogQHR5cGUge2pRdWVyeS5lbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kZWwgPSAkKFwiPHVsPlwiKTtcbiAgICAgICAgdGhpcy4kZWwuYXR0cignaWQnLCAnY29udGV4dE1lbnUnKTtcblxuICAgICAgICBsZXQgc3BlY2lhbCA9IG5ldyBDb250ZXh0TWVudUl0ZW0oXCJTcGVjaWFsIGVsZW1lbnRzXCIsIHRoaXMpO1xuXG4gICAgICAgIC8vIGFkZCBpbnB1dCBib3hcbiAgICAgICAgc3BlY2lhbC5hcHBlbmRJdGVtKFxuICAgICAgICAgICAgbmV3IENvbnRleHRNZW51SXRlbShcIklucHV0IGJveFwiLCB0aGlzLFxuICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogdGhpcy5wYXJlbnRTVkcuc25hcFRvR3JpZChwYXJlbnRTVkcudmlld2JveC50cmFuc2Zvcm1YKHRoaXMucG9zaXRpb24ueCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB0aGlzLnBhcmVudFNWRy5zbmFwVG9HcmlkKHBhcmVudFNWRy52aWV3Ym94LnRyYW5zZm9ybVkodGhpcy5wb3NpdGlvbi55KSlcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRTVkcubmV3SW5wdXQocG9zaXRpb24ubGVmdCwgcG9zaXRpb24udG9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gYWRkIG91dHB1dCBib3hcbiAgICAgICAgc3BlY2lhbC5hcHBlbmRJdGVtKG5ldyBDb250ZXh0TWVudUl0ZW0oXCJPdXRwdXQgYm94XCIsIHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLnBhcmVudFNWRy5zbmFwVG9HcmlkKHBhcmVudFNWRy52aWV3Ym94LnRyYW5zZm9ybVgodGhpcy5wb3NpdGlvbi54KSksXG4gICAgICAgICAgICAgICAgdG9wOiB0aGlzLnBhcmVudFNWRy5zbmFwVG9HcmlkKHBhcmVudFNWRy52aWV3Ym94LnRyYW5zZm9ybVkodGhpcy5wb3NpdGlvbi55KSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHBhcmVudFNWRy5uZXdPdXRwdXQocG9zaXRpb24ubGVmdCwgcG9zaXRpb24udG9wKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHRoaXMuYXBwZW5kSXRlbShzcGVjaWFsKTtcblxuICAgICAgICAvLyBsaXN0IG9mIGdhdGVzIHRoYXQgY2FuIGJlIGFkZGVkXG4gICAgICAgIGNvbnN0IGdhdGVzID0gR2F0ZS52YWxpZEdhdGVzO1xuICAgICAgICBsZXQgZ2F0ZUxpc3QgPSBuZXcgQ29udGV4dE1lbnVJdGVtKFwiTmV3IGdhdGVcIiwgdGhpcywgcGFyZW50U1ZHKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGdhdGVzKSB7XG4gICAgICAgICAgICBnYXRlTGlzdC5hcHBlbmRJdGVtKFxuICAgICAgICAgICAgICAgIG5ldyBHYXRlTWVudUl0ZW0obmFtZSwgdGhpcylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBlbmRJdGVtKGdhdGVMaXN0KTtcblxuICAgICAgICAvLyBtb3JlIG9wdGlvbnMgd2lsbCBiZSBhZGRlZCBpbiB0aGUgZ2V0TGlicmFyeSgpIGNhbGxiYWNrIGJlbG93XG4gICAgICAgIGxldCBuZXR3b3JrTGlzdCA9IG5ldyBDb250ZXh0TWVudUl0ZW0oXCJBZGQgYSBuZXR3b3JrXCIsIHRoaXMpO1xuICAgICAgICBuZXR3b3JrTGlzdC5hcHBlbmRJdGVtKG5ldyBDb250ZXh0TWVudUl0ZW0oXCJQYXN0ZSBhIG5ldHdvcmtcIiwgdGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5SW1wb3J0RGlhbG9nKClcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmFwcGVuZEl0ZW0obmV0d29ya0xpc3QpOyAvLyBhbHdheXMgYXBwZW5kXG5cbiAgICAgICAgbGV0IGJsYWNrYm94TGlzdCA9IG5ldyBDb250ZXh0TWVudUl0ZW0oXCJBZGQgYSBibGFja2JveFwiLCB0aGlzKTsgLy8gYXBwZW5kcyBvbmx5IGlmIGNvbnRhaW5zIGl0ZW1zIChzZWUgdGhlIGNhbGxiYWNrKVxuXG4gICAgICAgIC8vIG5ldHdvcmsgaW1wb3J0IChibGFja2JveCwgbmV0d29yaylcbiAgICAgICAgZ2V0TGlicmFyeSgpLnRoZW4obmV0d29ya3MgPT4ge1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHtuYW1lLCBmaWxlLCBoYXNUYWJsZSwgaGFzTmV0d29ya30gb2YgbmV0d29ya3MpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgYSBuZXR3b3JrIGFzIGEgYmxhY2tib3hcbiAgICAgICAgICAgICAgICBpZihoYXNUYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBibGFja2JveExpc3QuYXBwZW5kSXRlbShcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBCbGFja2JveE1lbnVJdGVtKG5hbWUsIGZpbGUsIHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbG9hZCBhIG5ldHdvcmsgYXMgYSBuZXR3b3JrIG9mIGNvbXBvbmVudHMgY29ubmVjdGVkIHdpdGggd2lyZXNcbiAgICAgICAgICAgICAgICBpZihoYXNOZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmtMaXN0LmFwcGVuZEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTmV0d29ya01lbnVJdGVtKG5hbWUsIGZpbGUsIHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihibGFja2JveExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kSXRlbShibGFja2JveExpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBhZGQgY29uZGl0aW9uYWwgaXRlbXMgZm9yIGJveCBhbmQgd2lyZSByZW1vdmFsXG4gICAgICAgIHRoaXMuYXBwZW5kQ29uZGl0aW9uYWxJdGVtKCdib3gnLCAnUmVtb3ZlIHRoaXMgaXRlbScsIGlkID0+IHt0aGlzLnBhcmVudFNWRy5yZW1vdmVCb3goaWQpfSk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ29uZGl0aW9uYWxJdGVtKCd3aXJlJywgJ1JlbW92ZSB0aGlzIHdpcmUnLCBpZCA9PiB7dGhpcy5wYXJlbnRTVkcucmVtb3ZlV2lyZUJ5SWQoaWQpfSk7XG5cbiAgICAgICAgLy8gYWRkIHRoZSBjb250ZXh0IG1lbnUgdG8gdGhlIERPTVxuICAgICAgICBwYXJlbnRTVkcuJHN2Zy5iZWZvcmUodGhpcy4kZWwpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgaXRlbXMgaW4gdGhpcyBtZW51ICh1c2VkIGluIHRoZSAubGVuZ2h0IGdldHRlcikuIENvbmRpdGlvbmFsIGl0ZW1zIGRvIG5vdCBjb3VudC5cbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXRlbUNvdW50ID0gMDtcbiAgICB9XG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtQ291bnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYXBwZW5kIGEgY29udGV4dCBtZW51IGl0ZW0gdG8gdGhlIGNvbnRleHQgbWVudVxuICAgICAqIEBwYXJhbSAge0NvbnRleHRNZW51SXRlbX0gaXRlbSBpbnN0YW5jZSBvZiB7QGxpbmsgQ29udGV4dE1lbnVJdGVtfSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhpcyBtZW51XG4gICAgICovXG4gICAgYXBwZW5kSXRlbShpdGVtKSB7XG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZChpdGVtLmpRdWVyeSk7XG5cbiAgICAgICAgdGhpcy5pdGVtQ291bnQrKztcblxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhcHBlbmRzIGFuIGNvbm5kaXRpb25hbCBpdGVtICh0aGF0IGlzIHNob3duIG9ubHkgaWYgdGhlIHRhcmdldCBoYXMgdGhlIGNsYXNzIGl0ZW1DbGFzcylcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGl0ZW1DbGFzcyAgICAgc2hvdyB0aGUgaXRlbSBvbmx5IGlmIHRoZSB0YXJnZXQgaGFzIHRoaXMgY2xhc3NcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgICAgICAgICAgdGV4dCBvZiB0aGlzIG1lbnUgaXRlbVxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjbGlja0Z1bmN0aW9uIGZ1bmN0aW9uIHdpdGggb25lIGFyZ3VtZW50IChJRCBvZiB0aGUgdGFyZ2V0KSB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uIGNsaWNrXG4gICAgICovXG4gICAgYXBwZW5kQ29uZGl0aW9uYWxJdGVtKGl0ZW1DbGFzcywgdGV4dCwgY2xpY2tGdW5jdGlvbikge1xuICAgICAgICBpZighdGhpcy5jb25kaXRpb25hbEl0ZW1zKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbmFsSXRlbXMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29uZGl0aW9uYWxJdGVtc1t0aGlzLmNvbmRpdGlvbmFsSXRlbXMubGVuZ3RoXSA9IHtcbiAgICAgICAgICAgIGl0ZW1DbGFzczogaXRlbUNsYXNzLFxuICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgIGNsaWNrRnVuY3Rpb246IGNsaWNrRnVuY3Rpb25cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRpc3BsYXkgdGhlIGRpYWxvZyBmb3IgaW1wb3J0aW5nIGEgbmV0d29yayBmcm9tIGEgY2xpcGJvYXJkXG4gICAgICovXG4gICAgZGlzcGxheUltcG9ydERpYWxvZygpIHtcbiAgICAgICAgbGV0ICRwb3B1cCA9ICQoXCI8ZGl2PlwiKVxuICAgICAgICAgICAgLmFkZENsYXNzKFwiaW1wb3J0RXhwb3J0XCIpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoXCJpbXBvcnRcIik7XG5cbiAgICAgICAgbGV0IHRleHRhcmVhSWQgPSBcImltcG9ydEpTT05cIjtcbiAgICAgICAgbGV0ICR0ZXh0YmxvY2sgPSAkKFwiPHRleHRhcmVhPlwiKS5hdHRyKCdpZCcsIHRleHRhcmVhSWQpO1xuXG4gICAgICAgIGxldCBsaXR5SW5zdGFuY2U7XG5cbiAgICAgICAgJHBvcHVwLmFwcGVuZChcbiAgICAgICAgICAgICR0ZXh0YmxvY2tcbiAgICAgICAgKS5hcHBlbmQoXG4gICAgICAgICAgICAkKFwiPGE+XCIpLmF0dHIoe1xuICAgICAgICAgICAgICAgIFwiaHJlZlwiOiBcIiNcIixcbiAgICAgICAgICAgICAgICBcImNsYXNzXCI6IFwidXBsb2FkXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICQoXCI8aW1nPlwiKS5hdHRyKCdzcmMnLCBcImltZy9ndWkvaW1wb3J0LnN2Z1wiKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmFwcGVuZChcIiBpbXBvcnQgZnJvbSBKU09OXCIpXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoJCgnIycgKyB0ZXh0YXJlYUlkKS52YWwoKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U1ZHLm1lc3NhZ2VzLm5ld0Vycm9yTWVzc2FnZShcIlRoZSBpbXBvcnRlZCBmaWxlIGlzIG5vdCBhIHZhbGlkIEpTT04gZmlsZS5cIik7XG4gICAgICAgICAgICAgICAgICAgIGxpdHlJbnN0YW5jZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2Nlc3MgdGhlIGltcG9ydGVkIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTVkcuaW1wb3J0RGF0YShcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHRoaXMucGFyZW50U1ZHLnZpZXdib3gudHJhbnNmb3JtWCh0aGlzLnBvc2l0aW9uLngpIC8gdGhpcy5wYXJlbnRTVkcuZ3JpZFNpemUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZCh0aGlzLnBhcmVudFNWRy52aWV3Ym94LnRyYW5zZm9ybVkodGhpcy5wb3NpdGlvbi55KSAvIHRoaXMucGFyZW50U1ZHLmdyaWRTaXplKVxuICAgICAgICAgICAgICAgICAgICApLnRoZW4od2FybmluZ3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB3YXJuaW5nIG9mIHdhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTVkcubWVzc2FnZXMubmV3V2FybmluZ01lc3NhZ2Uod2FybmluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXR5SW5zdGFuY2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIGxpdHlJbnN0YW5jZSA9IGxpdHkoJHBvcHVwKTtcblxuICAgICAgICAvLyBmb2N1cyBvbiB0aGUgdGV4dGJsb2NrXG4gICAgICAgICR0ZXh0YmxvY2suZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkZWNpZGUgd2hldGhlciBvciBub3QgdG8gZGlzcGxheSBzcGVjaWZpYyBjb25kaXRpb25hbCBpdGVtc1xuICAgICAqIEBwYXJhbSAge2pRdWVyeS5lbGVtZW50fSAkdGFyZ2V0IGpRdWVyeSB0YXJnZXQgb2YgYSBNb3VzZUV2ZW50IChlbGVtZW50IHRoYXQgdXNlciBjbGlja2VkIG9uKVxuICAgICAqL1xuICAgIHJlc29sdmVDb25kaXRpb25hbEl0ZW1zKCR0YXJnZXQpIHtcbiAgICAgICAgZm9yKGxldCBpdGVtIG9mIHRoaXMuY29uZGl0aW9uYWxJdGVtcykge1xuICAgICAgICAgICAgaWYoJHRhcmdldC5oYXNDbGFzcyhpdGVtLml0ZW1DbGFzcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgIG5ldyBDb250ZXh0TWVudUl0ZW0oXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRleHQsIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jbGlja0Z1bmN0aW9uKCR0YXJnZXQuYXR0cignaWQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLmFkZENsYXNzKCdjb25kaXRpb25hbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGlkZSBhbGwgY29uZGl0aW9uYWwgaXRlbXNcbiAgICAgKi9cbiAgICBoaWRlQWxsQ29uZGl0aW9uYWxJdGVtcygpIHtcbiAgICAgICAgdGhpcy4kZWwuY2hpbGRyZW4oJy5jb25kaXRpb25hbCcpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRpc3BsYXlzIHRoZSBjb250ZXh0IG1lbnUgd2l0aCB0aGUgcmlnaHQgc2V0IG9mIGNvbmRpdGlvbmFsIGl0ZW1zXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB4ICAgICAgIGhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGNvbnRleHQgbWVudSBpbiBDU1MgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB5ICAgICAgIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBjb250ZXh0IG1lbnUgaW4gQ1NTIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge2pRdWVyeS5lbGVtZW50fSAkdGFyZ2V0IGpRdWVyeSB0YXJnZXQgb2YgYSBNb3VzZUV2ZW50IChlbGVtZW50IHRoYXQgdXNlciBjbGlja2VkIG9uKVxuICAgICAqL1xuICAgIGRpc3BsYXkoeCwgeSwgJHRhcmdldCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHlcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlc29sdmVDb25kaXRpb25hbEl0ZW1zKCR0YXJnZXQpO1xuXG4gICAgICAgIHRoaXMuJGVsLmNzcyh7XG4gICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgICAgdG9wOiB5LFxuICAgICAgICAgICAgbGVmdDogeFxuICAgICAgICB9KVxuICAgICAgICAvLyBzZXQgdGhlIHdpZHRoIGV4cGljaXRseSwgb3IgZWxzZSB0aGUgbWVudSB3aWxsIHdpZGVuIHdoZW4gZGlzcGxheWluZyBhIHN1Ym1lbnVcbiAgICAgICAgLy8gMiBpcyB0byBwcmV2ZW50IGEgd2VpcmQgdGV4dCB3cmFwIGJ1Z1xuICAgICAgICAuY3NzKCd3aWR0aCcsICdhdXRvJylcbiAgICAgICAgLmNzcygnd2lkdGgnLCB0aGlzLiRlbC5pbm5lcldpZHRoKCkgKyAyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoaWRlIHRoZSBjb250ZXh0IG1lbnVcbiAgICAgKi9cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLiRlbC5jc3Moe2Rpc3BsYXk6ICdub25lJ30pO1xuICAgICAgICAkKFwiLnN1Ykxpc3RcIikuY3NzKHtkaXNwbGF5OiAnbm9uZSd9KTtcbiAgICAgICAgdGhpcy5oaWRlQWxsQ29uZGl0aW9uYWxJdGVtcygpO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIHN2Z09iaiBmcm9tICcuL3N2Z09iamVjdHMnXG5pbXBvcnQgTG9naWMgZnJvbSAnLi9sb2dpYydcbmltcG9ydCBmaW5kUGF0aCBmcm9tICcuL2ZpbmRQYXRoJ1xuXG5cbi8qKlxuICogbWFwcGluZyBvZiBsb2dpY2FsIHN0YXRlcyB0byBjc3MgY2xhc3Nlc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuY29uc3Qgc3RhdGVDbGFzc2VzID0ge1xuICAgIG9uOiBcInN0YXRlT25cIixcbiAgICBvZmY6IFwic3RhdGVPZmZcIixcbiAgICB1bmtub3duOiBcInN0YXRlVW5rbm93blwiLFxuICAgIG9zY2lsbGF0aW5nOiBcInN0YXRlT3NjaWxsYXRpbmdcIlxufTtcblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdXNlZCBieSB7QGxpbmsgVHJhbnNmb3JtfS5cbiAqXG4gKiBSZXByZXNlbnRzIG9uZSBzaW5nbGUgcHJvcGVydHkgb2YgdGhlIHRyYW5zZm9ybSBhcmd1bWVudCwgZm9yIGV4YW1wbGUgYHRyYW5zbGF0ZSgzNjAgMTUwKWBcbiAqIHRoYXQgbWF5IGJlIGEgcGFydCBvZiBsb25nZXIgdHJhbnNmb3JtIGFyZ3VtZW50IGxpa2UgYHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgzNjAgMTUwKSByb3RhdGUoOTAgMzAgMjApXCJgXG4gKi9cbmNsYXNzIFByb3BlcnR5IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBQcm9wZXJ0eSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZ10gc3RyaW5nIGluIHRoZSBwcm9wZXJ0eSBmb3JtYXQgYHByb3BlcnR5bmFtZShsaXN0IG9mIHNwYWNlIHNlcGFyYXRlZCB2YWx1ZXMpYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZykge1xuICAgICAgICBpZihzdHJpbmchPT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IHN0cmluZy5yZXBsYWNlKC9eWyBdKihbXihdKykuKi8sIFwiJDFcIik7XG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSBzdHJpbmcucmVwbGFjZSgvXlteKF0rXFwoKC4qKVxcKS8sIFwiJDFcIikuc3BsaXQoJyAnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCBvciByZXBsYWNlIHRoZSBuYW1lIG9mIHRoaXMgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuZXcgbmFtZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHNldE5hbWUobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCBhcmd1bWVudHMgb2YgdGhpcyBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGFyZ3MgYXJyYXkgb2YgYXJndW1lbnRzXG4gICAgICovXG4gICAgc2V0QXJndW1lbnRzKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gcHJvcGVydHkgaW4gdGhlIHByb3BlcnR5IGZvcm1hdCBgbmFtZShhcmcxIGFyZzIpYFxuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArIFwiKFwiICsgdGhpcy5hcmdzLmpvaW4oXCIgXCIpICsgXCIpXCI7XG4gICAgfVxufVxuXG4vKipcbiAqIEFQSSBmb3IgbWFuaXB1bGF0aW5nIHRoZSB0cmFuc2Zvcm0gYXJndW1lbnQgdXNlZCBpbiBTVkdcbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zZm9ybSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgVHJhbnNmb3JtIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nXSBzdHJpbmcgaW4gdGhlIGZvcm1hdCBvZiB0aGUgYHRyYW5zZm9ybWAgYXJndW1lbnQgaW4gU1ZHLCBmb3IgZXhhbXBsZSBgdHJhbnNsYXRlKDM2MCAxNTApIHJvdGF0ZSg5MCAzMCAyMClgXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RyaW5nKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhcnJheSBvZiB7QGxpbmsgUHJvcGVydHl9IGluc3RhbmNlc1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG5cbiAgICAgICAgaWYoc3RyaW5nIT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc3RyaW5nLnNwbGl0KFwiKVwiKSkge1xuICAgICAgICAgICAgICAgIGlmKGl0ZW0pIHsgLy8gaWYgbm90IGVtcHR5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChuZXcgUHJvcGVydHkoaXRlbSArIFwiKVwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBkaXN0YW5jZXMgZnJvbSBTVkcgcGl4ZWxzIHRvIGdyaWQgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7Q2FudmFzfSBwYXJlbnRTVkcgaW5zdGFuY2Ugb2YgW0NhbnZhc10oLi9tb2R1bGUtQ2FudmFzLmh0bWwpXG4gICAgICovXG4gICAgdG9HcmlkUGl4ZWxzKHBhcmVudFNWRykge1xuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmKGl0ZW0ubmFtZSA9PT0gXCJ0cmFuc2xhdGVcIikge1xuICAgICAgICAgICAgICAgIGl0ZW0uYXJncyA9IFtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50U1ZHLlNWR1RvR3JpZChpdGVtLmFyZ3NbMF0pLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRTVkcuU1ZHVG9HcmlkKGl0ZW0uYXJnc1sxXSksXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSBlbHNlIGlmKGl0ZW0ubmFtZSA9PT0gXCJyb3RhdGVcIikge1xuICAgICAgICAgICAgICAgIGl0ZW0uYXJncyA9IFtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5hcmdzWzBdLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRTVkcuU1ZHVG9HcmlkKGl0ZW0uYXJnc1sxXSksXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFNWRy5TVkdUb0dyaWQoaXRlbS5hcmdzWzJdKSxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGRpc3RhbmNlcyBmcm9tIGdyaWQgcGl4ZWxzIHRvIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0gIHtDYW52YXN9IHBhcmVudFNWRyBpbnN0YW5jZSBvZiBbQ2FudmFzXSguL21vZHVsZS1DYW52YXMuaHRtbClcbiAgICAgKi9cbiAgICB0b1NWR1BpeGVscyhwYXJlbnRTVkcpIHtcbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZihpdGVtLm5hbWUgPT09IFwidHJhbnNsYXRlXCIpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFNWRy5ncmlkVG9TVkcoaXRlbS5hcmdzWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50U1ZHLmdyaWRUb1NWRyhpdGVtLmFyZ3NbMV0pLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0gZWxzZSBpZihpdGVtLm5hbWUgPT09IFwicm90YXRlXCIpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50U1ZHLmdyaWRUb1NWRyhpdGVtLmFyZ3NbMV0pLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRTVkcuZ3JpZFRvU1ZHKGl0ZW0uYXJnc1syXSksXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmluZCBhIHRyYW5zZm9ybSBwcm9wZXJ0eSBieSBuYW1lIGFuZCBnZXQgaXRzIGluZGV4IGluIHRoZSBbaXRlbXNdKCNpdGVtcykgYXJyYXlcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgaW5kZXggb2YgdGhlIHByb3BlcnR5IGluIHRoZSBhcnJheSBvZiBwcm9wZXJ0aWVzIG9yIGAtMWAgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgZ2V0SW5kZXgobmFtZSkge1xuICAgICAgICBmb3IobGV0IGkgPSAwIDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmKG5hbWUgPT09IHRoaXMuaXRlbXNbaV0ubmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdHJhbnNsYXRlIHByb3BlcnR5XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIG9mIHRoZSB0cmFuc2xhdGUgYXR0cmlidXRlXG4gICAgICovXG4gICAgZ2V0VHJhbnNsYXRlKCkge1xuICAgICAgICBsZXQgYXJncyA9IHRoaXMuZ2V0QXJndW1lbnRzKHRoaXMuZ2V0SW5kZXgoXCJ0cmFuc2xhdGVcIikpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBOdW1iZXIoYXJnc1swXSksXG4gICAgICAgICAgICB5OiBOdW1iZXIoYXJnc1sxXSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgcm90YXRlIHByb3BlcnR5XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIG9mIHRoZSByb3RhdGUgYXR0cmlidXRlXG4gICAgICovXG4gICAgZ2V0Um90YXRlKCkge1xuICAgICAgICBsZXQgYXJncyA9IHRoaXMuZ2V0QXJndW1lbnRzKHRoaXMuZ2V0SW5kZXgoXCJyb3RhdGVcIikpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWc6IE51bWJlcihhcmdzWzBdKSxcbiAgICAgICAgICAgIGNlbnRyZVg6IE51bWJlcihhcmdzWzFdKSxcbiAgICAgICAgICAgIGNlbnRyZVk6IE51bWJlcihhcmdzWzJdKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHRyYW5zbGF0ZSB0byB0aGUgc3BlY2lmaWVkIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IGhvcml6b250YWwgdHJhbnNsYXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSB2ZXJ0aWNhbCB0cmFuc2xhdGlvblxuICAgICAqL1xuICAgIHNldFRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyKFwidHJhbnNsYXRlXCIsIFt4LCB5XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHJvdGF0ZSB0byB0aGUgc3BlY2lmaWVkIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWcgICAgIGFuZ2xlIG9mIHRoZSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNlbnRyZVggaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgY2VudHJlIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjZW50cmVZIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBjZW50cmUgb2YgdGhlIHJvdGF0aW9uXG4gICAgICovXG4gICAgc2V0Um90YXRlKGRlZywgY2VudHJlWCwgY2VudHJlWSkge1xuICAgICAgICB0aGlzLnNldFBhcmFtZXRlcihcInJvdGF0ZVwiLCBbZGVnLCBjZW50cmVYLCBjZW50cmVZXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcm90YXRlIGJ5IDkwIGRlZ3JlZXMgdG8gdGhlIHJpZ2h0IG9yIGxlZnQsIGRlcGVuZGluZyBvbiB0aGUgcGFyYW1ldGVyIGByaWdodGBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2VudHJlWCBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBjZW50cmUgb2YgdGhlIHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNlbnRyZVkgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIGNlbnRyZSBvZiB0aGUgcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJpZ2h0IHJvdGF0ZSB0byB0aGUgcmlnaHQgaWYgYHRydWVgLCB0byB0aGUgbGVmdCBpZiBgZmFsc2VgXG4gICAgICovXG4gICAgcm90YXRlUmlnaHRBbmdsZShjZW50cmVYLCBjZW50cmVZLCByaWdodCkge1xuICAgICAgICBjb25zdCBhbW91bnQgPSByaWdodCA/IDkwIDogMjcwO1xuXG4gICAgICAgIGlmKHRoaXMuZ2V0SW5kZXgoXCJyb3RhdGVcIik9PT0tMSkge1xuICAgICAgICAgICAgdGhpcy5zZXRSb3RhdGUoYW1vdW50LCBjZW50cmVYLCBjZW50cmVZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdSb3RhdGlvbiA9IChwYXJzZUludCh0aGlzLmdldFJvdGF0ZSgpLmRlZykgKyBhbW91bnQpICUgMzYwO1xuXG4gICAgICAgICAgICBpZihuZXdSb3RhdGlvbj09PTE4MCkge1xuICAgICAgICAgICAgICAgIC8vIHN3YXAgY2VudHJlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSByb3RhdGUoYywgeCwgeSkgaXMgZGVmaW5lZCBsaWtlIHRyYW5zZm9ybSgteCwgLXkpIHJvdGF0ZShjKSB0cmFuc2Zvcm0oeCwgeSlcbiAgICAgICAgICAgICAgICBsZXQgYSA9IGNlbnRyZVg7XG4gICAgICAgICAgICAgICAgY2VudHJlWCA9IGNlbnRyZVk7XG4gICAgICAgICAgICAgICAgY2VudHJlWSA9IGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0Um90YXRlKFxuICAgICAgICAgICAgICAgIG5ld1JvdGF0aW9uLFxuICAgICAgICAgICAgICAgIGNlbnRyZVgsXG4gICAgICAgICAgICAgICAgY2VudHJlWVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJvdGF0ZSBieSA5MCBkZWdyZWVzIHRvIHRoZSByaWdodFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gY2VudHJlWCBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBjZW50cmUgb2YgdGhlIHJvdGF0aW9uXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBjZW50cmVZIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBjZW50cmUgb2YgdGhlIHJvdGF0aW9uXG4gICAgICovXG4gICAgcm90YXRlUmlnaHQoY2VudHJlWCwgY2VudHJlWSkge1xuICAgICAgICB0aGlzLnJvdGF0ZVJpZ2h0QW5nbGUoY2VudHJlWCwgY2VudHJlWSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcm90YXRlIGJ5IDkwIGRlZ3JlZXMgdG8gdGhlIGxlZnRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNlbnRyZVggaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgY2VudHJlIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSAge251bWJlcn0gY2VudHJlWSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgY2VudHJlIG9mIHRoZSByb3RhdGlvblxuICAgICAqL1xuICAgIHJvdGF0ZUxlZnQoY2VudHJlWCwgY2VudHJlWSkge1xuICAgICAgICB0aGlzLnJvdGF0ZVJpZ2h0QW5nbGUoY2VudHJlWCwgY2VudHJlWSwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdHJhbnNmb3JtIHZhbHVlcyBpbiBhIHN0cmluZ1xuICAgICAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSB2YWx1ZSBmb3IgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSBvZiBhIFNWRyBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0KCkge1xuICAgICAgICBsZXQgcmV0VmFsO1xuICAgICAgICBmb3IoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZihyZXRWYWwpIHtcbiAgICAgICAgICAgICAgICByZXRWYWwgKz0gXCIgXCIgKyBpdGVtLmdldCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRWYWwgPSBpdGVtLmdldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRWYWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGFyZ3VtZW50cyBvZiBhIHByb3BlcnR5IHNwZWNpZmllZCBieSBpbmRleFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gaW5kZXggaW5kZXggb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHJldHVybiB7YXJyYXl9ICAgICAgIGFycmF5IG9mIGFyZ3VtZW50cyBvZiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XG4gICAgICovXG4gICAgZ2V0QXJndW1lbnRzKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zW2luZGV4XS5hcmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCBhcmd1bWV0cyBvZiBhIHByb3BlcnR5IHNwZWNpZmllZCBieSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBhcmdzIGFycmF5IG9mIGFyZ3VtZW50cyBvZiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XG4gICAgICovXG4gICAgc2V0UGFyYW1ldGVyKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIGluZGV4IG9mIHRoZSBwYXJhbWV0ZXIgKGlmIHNldCksIGVsc2UgaW5kZXggPT0gLTFcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5nZXRJbmRleChuYW1lKTtcblxuICAgICAgICAvLyBpZiB0aGUgcHJvcGVydHkgaGFzIGJlZW4gYWxyZWFkeSBzZXQsIGNoYW5nZSBpdCAocmV3cml0ZSB0aGUgYXJyYXkgaW4gdGhlIHJpZ2h0IGluZGV4KVxuICAgICAgICAvLyBlbHNlIGNyZWF0ZSBhIG5ldyBvbmUgKHNldCBpbmRleCB0byB0aGUgbGVuZ3RoIG9mIGFuIGFycmF5IC0tPiBhZCBhbiBpdGVtIHRvIHRoZSBlbmQpXG4gICAgICAgIGlmKGluZGV4PT09LTEpIHtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW2luZGV4XSA9IG5ldyBQcm9wZXJ0eSgpO1xuICAgICAgICAgICAgdGhpcy5pdGVtc1tpbmRleF0uc2V0TmFtZShuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNhdmUgYXJncyB1bmRlciB0aGUgcmlnaHQgaW5kZXhcbiAgICAgICAgdGhpcy5pdGVtc1tpbmRleF0uc2V0QXJndW1lbnRzKGFyZ3MpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBwYXJlbnQgY2xhc3MgZm9yIGFsbCBuZXR3b3JrIGVsZW1lbnRzXG4gKi9cbmNsYXNzIE5ldHdvcmtFbGVtZW50IHtcbiAgICAvKipcbiAgICAgKiBCYXNpYyBjb25zdHJ1Y3RvciBmb3IgTmV0d29ya0VsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gcGFyZW50U1ZHIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb2Yge0BsaW5rIENhbnZhc30gdGhhdCB0aGlzIGVsZW1lbnQgYmVsb25ncyB0b1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFNWRykge1xuICAgICAgICBpZighcGFyZW50U1ZHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiUGFyZW50IFNWRyBlbGVtZW50IGhhcyB0byBiZSBkZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudFNWRyA9IHBhcmVudFNWRztcblxuICAgICAgICAvLyB1c2VkIHRvIHN0b3JlIHRoZSBzdmpPYmplY3QncyBpbnN0YW5jZSBvZiB0aGlzIGVsZW1lbnRcbiAgICAgICAgdGhpcy5zdmdPYmogPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB1bmlxdWUgSUQgb2YgdGhlIFNWRyBlbGVtZW50IHRpZWQgdG8gdGhpcyBsb2dpY2FsIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IElEIG9mIHRoZSBTVkcgZWxlbWVudFxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ZnT2JqLmlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGVtcHR5IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHByZXZlbnQgZXJyb3IgbWVzc2FnZXMsIGZ1bmN0aW9uIGlzIGltcGxlbWVudGVkIGxhdGVyIGluIHRoZSB7QGxpbmsgQm94fSBjbGFzc1xuICAgICAqL1xuICAgIG9uTW91c2VEb3duKCkge31cblxuICAgIC8qKlxuICAgICAqIGVtcHR5IGZ1bmN0aW9uIHRvIHByZXZlbnQgZXJyb3IgbWVzc2FnZXMsIGZ1bmN0aW9uIGlzIGltcGxlbWVudGVkIGxhdGVyIGluIHRoZSB7QGxpbmsgQm94fSBhbmQge0BsaW5rIENvbm5lY3Rvcn0gY2xhc3Nlc1xuICAgICAqL1xuICAgIG9uTW91c2VVcCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBlbXB0eSBmdW5jdGlvbiB0byBwcmV2ZW50IGVycm9yIG1lc3NhZ2VzLCBmdW5jdGlvbiBpcyBpbXBsZW1lbnRlZCBsYXRlciBpbiB0aGUge0BsaW5rIEJveH0gY2xhc3NcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZSgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBcInZpcnR1YWxcIiBnZXR0ZXIgZm9yIGpzb24gZGF0YSwgcHJpbnRzIGFuIGVycm9yIHRoYXQgaXQgaGFzIHRvIGJlIHJlZGVmaW5lZCBpbiB0aGUgZGVyaXZlZCBjbGFzc2VzXG4gICAgICovXG4gICAgZ2V0IGV4cG9ydERhdGEoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCInanNvbicgZ2V0dGVyIGhhcyBub3QgYmVlbiBkZWZpbmVkIGZvciB0aGlzIGVsZW1lbnRcIiwgdGhpcyk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG4vKipcbiAqIHBhcmVudCBjbGFzcyBmb3IgaW5wdXQgYW5kIG91dHB1dCBjb25uZWN0b3JzXG4gKiBAZXh0ZW5kcyBOZXR3b3JrRWxlbWVudFxuICovXG5jbGFzcyBDb25uZWN0b3IgZXh0ZW5kcyBOZXR3b3JrRWxlbWVudCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDYW52YXN9IHBhcmVudFNWRyBsaW5rIHRvIHRoZSB7QGxpbmsgQ2FudmFzfSBpbnN0YW5jZSB0aGF0IHRoaXMgY29ubmVjdG9yIHdpbGwgYmVsb25nIHRvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyaWRTaXplICBzaXplIG9mIHRoZSBncmlkIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdCAgICAgIGhvcml6b250YWwgcG9zaXRpb24gZGVmaW5lZCBpbiBncmlkIHVuaXRzIChTVkcgcGl4ZWxzIGRpdmlkZWQgYnkgdGhlIGdyaWQgc2l6ZSlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wICAgICAgIHZlcnRpY2FsIHBvc2l0aW9uIGRlZmluZWQgaW4gZ3JpZCB1bml0cyAoU1ZHIHBpeGVscyBkaXZpZGVkIGJ5IHRoZSBncmlkIHNpemUpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyZW50U1ZHLCBsZWZ0LCB0b3ApIHtcbiAgICAgICAgc3VwZXIocGFyZW50U1ZHKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2l6ZSBvZiB0aGUgZ3JpZCBpbiBTVkcgcGl4ZWxzXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyaWRTaXplID0gcGFyZW50U1ZHLmdyaWRTaXplO1xuICAgICAgICAvKipcbiAgICAgICAgICogc2l6ZSBvZiB0aGUgY29ubmVjdG9yIGluIFNWRyBwaXhlbHNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdG9yU2l6ZSA9IHBhcmVudFNWRy5ncmlkU2l6ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9mZnNldCBvZiB0aGUgY29ubmVjdG9yIGZyb20gdGhlIGdyaWQgaW4gU1ZHIHBpeGVsc1xuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0b3JPZmZzZXQgPSB0aGlzLmNvbm5lY3RvclNpemUgLyAyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpbnN0YW5jZSBvZiB7QGxpbmsgc3ZnT2JqZWN0cy5zdmdPYmp9IHRoYXQgaG9sZHMgYWxsIFNWRyBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIGNvbm5lY3RvclxuICAgICAgICAgKiBAdHlwZSB7c3ZnT2JqfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdmdPYmogPSBuZXcgc3ZnT2JqLlJlY3RhbmdsZShcbiAgICAgICAgICAgIGxlZnQgKiB0aGlzLmdyaWRTaXplIC0gdGhpcy5jb25uZWN0b3JPZmZzZXQsXG4gICAgICAgICAgICB0b3AgKiB0aGlzLmdyaWRTaXplIC0gdGhpcy5jb25uZWN0b3JPZmZzZXQsXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvclNpemUsXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvclNpemUsXG4gICAgICAgICAgICBcIm5vbmVcIixcbiAgICAgICAgICAgIFwiYmxhY2tcIlxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuc3ZnT2JqLiRlbC5hZGRDbGFzcyhcImNvbm5lY3RvclwiKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdGhpcyBmbGFnIGRlc2NyaWJlcyB3aGV0aGVyIHRoaXMgY29ubmVjdG9yIGlzIGFuIGlucHV0IGNvbm5lY3RvclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNJbnB1dENvbm5lY3RvciA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjdXJyZW50IGxvZ2ljYWwgc3RhdGUgb2YgdGhpcyBjb25uZWN0b3JcbiAgICAgICAgICogQHR5cGUge0xvZ2ljLnN0YXRlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbGVtZW50U3RhdGUgPSBMb2dpYy5zdGF0ZS51bmtub3duO1xuICAgICAgICB0aGlzLnN2Z09iai5hZGRDbGFzcyhzdGF0ZUNsYXNzZXMudW5rbm93bik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBvZiBpZHMgb2YgYWxsIHdpcmVzIGNvbm5lY3RlZCB0byB0aGlzIGNvbm5lY3RvclxuICAgICAgICAgKiBAdHlwZSB7U2V0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aXJlSWRzID0gbmV3IFNldCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHdoZXRoZXIgdGhpcyBjb25uZWN0b3IgaXMgYW4gb3V0cHV0IGNvbm5lY3RvclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGlzT3V0cHV0Q29ubmVjdG9yKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNJbnB1dENvbm5lY3RvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB3aGV0aGVyIHRoaXMgY29ubmVjdG9yIGlzIGFuIG91dHB1dCBjb25uZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNldCBpc091dHB1dENvbm5lY3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLmlzSW5wdXRDb25uZWN0b3IgPSAhdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgd2lyZSBpZCB0byB0aGUgbGlzdCBvZiB3aXJlIGlkc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3aXJlSWRcbiAgICAgKi9cbiAgICBhZGRXaXJlSWQod2lyZUlkKSB7XG4gICAgICAgIHRoaXMud2lyZUlkcy5hZGQod2lyZUlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgYSB3aXJlIGlkIGZyb20gdGhlIGxpc3Qgb2Ygd2lyZSBpZHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2lyZUlkXG4gICAgICovXG4gICAgcmVtb3ZlV2lyZUlkKHdpcmVJZCkge1xuICAgICAgICB0aGlzLndpcmVJZHMuZGVsZXRlKHdpcmVJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGEgd2lyZSBzcGVjaWZpZWQgYnkgSUQgYW5kIHVwZGF0ZSB0aGUgY29ubmVjdG9yXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB3aXJlSWQgSUQgb2YgdGhlIHdpcmUgdG8gYmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIHJlbW92ZVdpcmVJZEFuZFVwZGF0ZSh3aXJlSWQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVXaXJlSWQod2lyZUlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgbG9naWNhbCBzdGF0ZSBvZiB0aGUgY29ubmVjdG9yXG4gICAgICogQHBhcmFtIHtMb2dpYy5zdGF0ZX0gc3RhdGUgbmV3IHN0YXRlIG9mIHRoZSBjb25uZWN0b3JcbiAgICAgKi9cbiAgICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgICB0aGlzLnN2Z09iai5yZW1vdmVDbGFzc2VzKHN0YXRlQ2xhc3Nlcy5vbiwgc3RhdGVDbGFzc2VzLm9mZiwgc3RhdGVDbGFzc2VzLnVua25vd24sIHN0YXRlQ2xhc3Nlcy5vc2NpbGxhdGluZyk7XG5cbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBMb2dpYy5zdGF0ZS51bmtub3duOlxuICAgICAgICAgICAgICAgIHRoaXMuc3ZnT2JqLmFkZENsYXNzKHN0YXRlQ2xhc3Nlcy51bmtub3duKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTG9naWMuc3RhdGUub246XG4gICAgICAgICAgICAgICAgdGhpcy5zdmdPYmouYWRkQ2xhc3Moc3RhdGVDbGFzc2VzLm9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTG9naWMuc3RhdGUub2ZmOlxuICAgICAgICAgICAgICAgIHRoaXMuc3ZnT2JqLmFkZENsYXNzKHN0YXRlQ2xhc3Nlcy5vZmYpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZzpcbiAgICAgICAgICAgICAgICB0aGlzLnN2Z09iai5hZGRDbGFzcyhzdGF0ZUNsYXNzZXMub3NjaWxsYXRpbmcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbGVtZW50U3RhdGUgPSBzdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgc3RhdGUgb2YgdGhpcyBjb25uZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtMb2dpYy5zdGF0ZX1cbiAgICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRTdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgc3ZnT2JqIGluc3RhbmNlIGNvbnRlbnQgb2YgdGhpcyBjb25uZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtzdmdPYmplY3RzLlJlY3RhbmdsZX1cbiAgICAgKi9cbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN2Z09iajtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjYWxsIFt3aXJlQ3JlYXRpb25IZWxwZXJdKC4vbW9kdWxlLUNhbnZhcy5odG1sI3dpcmVDcmVhdGlvbkhlbHBlcikgb24gbW91c2UgdXBcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoKSB7XG4gICAgICAgIHRoaXMucGFyZW50U1ZHLndpcmVDcmVhdGlvbkhlbHBlcih0aGlzLnN2Z09iai5pZCk7XG4gICAgfVxufVxuXG4vKipcbiAqIENvbm5lY3RvciB0aGF0IGdldHMgaXRzIHN0YXRlIGZyb20gYSBjb25uZWN0ZWQgdmFsdWUgYW5kIHBhc3NlcyBpdCB0aHJvdWdoIHRvIHRoZSB7QGxpbmsgQm94fSB0aGlzIGNvbm5lY3RvciBiZWxvbmdzIHRvLlxuICogQGV4dGVuZHMgQ29ubmVjdG9yXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnB1dENvbm5lY3RvciBleHRlbmRzIENvbm5lY3RvciB7XG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGUgY29uc3RydWN0b3IgZnJvbSB0aGUgcGFyZW50IHtAbGluayBDb25uZWN0b3J9IGNsYXNzIGFuZCBzZXQgaXNJbnB1dENvbm5lY3RvciB0byB0cnVlLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzfSBwYXJlbnRTVkcgbGluayB0byB0aGUge0BsaW5rIENhbnZhc30gaW5zdGFuY2UgdGhhdCB0aGlzIGNvbm5lY3RvciB3aWxsIGJlbG9uZyB0b1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0ICAgICAgaG9yaXpvbnRhbCBwb3NpdGlvbiBkZWZpbmVkIGluIGdyaWQgdW5pdHMgKFNWRyBwaXhlbHMgZGl2aWRlZCBieSB0aGUgZ3JpZCBzaXplKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgICAgICAgdmVydGljYWwgcG9zaXRpb24gZGVmaW5lZCBpbiBncmlkIHVuaXRzIChTVkcgcGl4ZWxzIGRpdmlkZWQgYnkgdGhlIGdyaWQgc2l6ZSlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRTVkcsIGxlZnQsIHRvcCkge1xuICAgICAgICBzdXBlcihwYXJlbnRTVkcsIGxlZnQsIHRvcCk7XG5cbiAgICAgICAgdGhpcy5pc0lucHV0Q29ubmVjdG9yID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoZSBzZXRTdGF0ZSBtZXRob2Qgb2Yge0BsaW5rIENvbm5lY3Rvcn0gYW5kIHRoYW4gcmVmcmVzaCB0aGUgc3RhdGUgb2YgdGhlIGNvbm5lY3RlZCB7QGxpbmsgQm94fVxuICAgICAqIEBwYXJhbSB7TG9naWMuc3RhdGV9IHN0YXRlIG5ldyB7QGxpbmsgTG9naWMuc3RhdGV9IG9mIHRoZSBjb25uZWN0b3JcbiAgICAgKi9cbiAgICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgICBzdXBlci5zZXRTdGF0ZShzdGF0ZSk7XG5cbiAgICAgICAgbGV0IGdhdGUgPSB0aGlzLnBhcmVudFNWRy5nZXRCb3hCeUNvbm5lY3RvcklkKHRoaXMuc3ZnT2JqLmlkKTtcbiAgICAgICAgZ2F0ZS5yZWZyZXNoU3RhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgdGhlIHdpcmUgKGJ5IGNhbGxpbmcgdGhlIHJlbW92ZVdpcmVJZEFuZFVwZGF0ZSBvZiB7QGxpbmsgQ29ubmVjdG9yfSlcbiAgICAgKiBhbmQgdXBkYXRlIHN0YXRlIG9mIHRoaXMgY29ubmVjdG9yIGJ5IHNldHRpbmcgaXQgdG8gdW5kZWZpbmVkIHVzaW5nIHRoZSBzZXRTdGF0ZSBtZXRob2RcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHdpcmVJZCBJRCBvZiB0aGUge0BsaW5rIFdpcmV9XG4gICAgICovXG4gICAgcmVtb3ZlV2lyZUlkQW5kVXBkYXRlKHdpcmVJZCkge1xuICAgICAgICBzdXBlci5yZW1vdmVXaXJlSWRBbmRVcGRhdGUod2lyZUlkKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShMb2dpYy5zdGF0ZS51bmtub3duKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29ubmVjdG9yIHRoYXQgdGFrZXMgYSBzdGF0ZSBkZWZpbmVkIGJ5IHRoZSB7QGxpbmsgQm94fSBpdCBiZWxvbmdzIHRvIGFuZCBwYXNzZXMgaXQgdG8gYWxsIGNvbm5lY3RlZCB3aXJlXG4gKiBAZXh0ZW5kcyBDb25uZWN0b3JcbiAqL1xuZXhwb3J0IGNsYXNzIE91dHB1dENvbm5lY3RvciBleHRlbmRzIENvbm5lY3RvciB7XG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGUgY29uc3RydWN0b3IgZnJvbSB0aGUgcGFyZW50IHtAbGluayBDb25uZWN0b3J9IGNsYXNzIGFuZCBzZXQgaXNPdXRwdXRDb25uZWN0b3IgdG8gdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gcGFyZW50U1ZHIGxpbmsgdG8gdGhlIHtAbGluayBDYW52YXN9IGluc3RhbmNlIHRoYXQgdGhpcyBjb25uZWN0b3Igd2lsbCBiZWxvbmcgdG9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdCAgICAgIGhvcml6b250YWwgcG9zaXRpb24gZGVmaW5lZCBpbiBncmlkIHVuaXRzIChTVkcgcGl4ZWxzIGRpdmlkZWQgYnkgdGhlIGdyaWQgc2l6ZSlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wICAgICAgIHZlcnRpY2FsIHBvc2l0aW9uIGRlZmluZWQgaW4gZ3JpZCB1bml0cyAoU1ZHIHBpeGVscyBkaXZpZGVkIGJ5IHRoZSBncmlkIHNpemUpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyZW50U1ZHLCBsZWZ0LCB0b3ApIHtcbiAgICAgICAgc3VwZXIocGFyZW50U1ZHLCBsZWZ0LCB0b3ApO1xuXG4gICAgICAgIHRoaXMuaXNPdXRwdXRDb25uZWN0b3IgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIHNldFN0YXRlIG1ldGhvZCBvZiB7QGxpbmsgQ29ubmVjdG9yfSBhbmQgdGhhbiBzZXQgdGhlIHN0YXRlIG9mIHRoZSBjb25uZWN0ZWQge0BsaW5rIFdpcmV9c1xuICAgICAqIEBwYXJhbSB7TG9naWMuc3RhdGV9IHN0YXRlIG5ldyB7QGxpbmsgTG9naWMuc3RhdGV9IG9mIHRoZSBjb25uZWN0b3JcbiAgICAgKi9cbiAgICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgICBzdXBlci5zZXRTdGF0ZShzdGF0ZSk7XG5cbiAgICAgICAgZm9yIChjb25zdCB3aXJlSWQgb2YgdGhpcy53aXJlSWRzKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFNWRy5nZXRXaXJlQnlJZCh3aXJlSWQpLnNldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBQYXJlbnQgY2xhc3MgZm9yIGdhdGVzIGFuZCBpbnB1dCBhbmQgb3V0cHV0IGJveGVzLiBEZWZpbmVzIGFsbCB0aGUgZmFjdG9yc1xuICogdGhhdCB0aGUgYm94ZXMgaGF2ZSBpbiBjb21tb24gKHN2Z09iaiBzdHJ1Y3R1cmUsIGRyYWdnYWJpbGl0eSBhbmQgcm90YXRhYmlsaXR5Li4uKVxuICogQGV4dGVuZHMgTmV0d29ya0VsZW1lbnRcbiAqL1xuY2xhc3MgQm94IGV4dGVuZHMgTmV0d29ya0VsZW1lbnQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzfSBwYXJlbnRTVkcgIGluc3RhbmNlIG9mIFtDYW52YXNdKC4vbW9kdWxlLUNhbnZhcy5odG1sKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgICAgIG5hbWUgb2YgdGhlIGVsZW1lbnQgKGlucHV0LCBvdXRwdXQsIGFuZCwgb3IsIHhvci4uLilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2F0ZWdvcnkgICB0eXBlIG9mIHRoZSBlbGVtZW50IChpbywgZ2F0ZSlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JpZFdpZHRoICB3aWR0aCBvZiB0aGUgZWxlbWVudCBpbiBncmlkIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncmlkSGVpZ2h0IGhlaWdodCBvZiB0aGUgZWxlbWVudCBpbiBncmlkIHBpeGVsc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFNWRywgbmFtZSwgY2F0ZWdvcnksIGdyaWRXaWR0aCwgZ3JpZEhlaWdodCkge1xuICAgICAgICBzdXBlcihwYXJlbnRTVkcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzcGVjaWZpZXMgdGhlIGJveCB0eXBlIHdpdGhpbiB0aGUgY2F0ZWdvcnkgKGlucHV0L291dHB1dCBpbiBpbywgYW5kL29yLy4uLiBpbiBnYXRlKVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogc3BlY2lmaWVzIHRoZSBib3ggY2F0ZWdvcnkgKGlvIGZvciBpbnB1dCBvciBvdXRwdXQsIGdhdGUgZm9yIGxvZ2ljIGdhdGVzKVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYXRlZ29yeSA9IGNhdGVnb3J5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzaXplIG9mIHRoZSBncmlkIGluIFNWRyBwaXhlbHNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JpZFNpemUgPSB0aGlzLnBhcmVudFNWRy5ncmlkU2l6ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYXJyYXkgb2YgY29ubmVjdG9ycyBvZiB0aGlzIGJveFxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3RvcnMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogc3ZnT2JqIGNvbnRhaW5pbmcgYWxsIFNWRyBkYXRhIHVzZWQgdG8gZGlzcGxheSB0aGlzIGJveFxuICAgICAgICAgKiBAdHlwZSB7c3ZnT2JqfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdmdPYmogPSBuZXcgc3ZnT2JqLkdyb3VwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdpZHRoIG9mIHRoaXMgZWxlbWVudCBpbiBTVkcgcGl4ZWxzXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndpZHRoID0gZ3JpZFdpZHRoICogdGhpcy5ncmlkU2l6ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhlaWdodCBvZiB0aGlzIGVsZW1lbnQgaW4gU1ZHIHBpeGVsc1xuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBncmlkSGVpZ2h0ICogdGhpcy5ncmlkU2l6ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogd2lkdGggb2YgdGhpcyBlbGVtZW50IGluIGdyaWQgcGl4ZWxzXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyaWRXaWR0aCA9IGdyaWRXaWR0aDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhlaWdodCBvZiB0aGlzIGVsZW1lbnQgaW4gZ3JpZCBwaXhlbHNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JpZEhlaWdodCA9IGdyaWRIZWlnaHQ7XG5cbiAgICAgICAgLy8gdHJhbnNwYXJlbnQgYmFja2dyb3VuZCByZWN0YW5nbGVcbiAgICAgICAgbGV0IHJlY3RhbmdsZSA9IG5ldyBzdmdPYmouUmVjdGFuZ2xlKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBcIm5vbmVcIiwgXCJub25lXCIpO1xuICAgICAgICByZWN0YW5nbGUuJGVsLmFkZENsYXNzKCdyZWN0Jyk7XG5cbiAgICAgICAgdGhpcy5zdmdPYmouYWRkQ2hpbGQocmVjdGFuZ2xlKTtcblxuICAgICAgICAvLyBpbWFnZSBvZiB0aGUgZWxlbWVudFxuICAgICAgICB0aGlzLmltYWdlID0gbmV3IHN2Z09iai5TdmdJbWFnZSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy51cmwpO1xuICAgICAgICB0aGlzLnN2Z09iai5hZGRDaGlsZCh0aGlzLmltYWdlKTtcblxuICAgICAgICAvLyBhZGQgdHlwZT1cImdhdGVcIiwgdXNlZCBpbiBzcGVjaWFsIGNhbGxiYWNrcyBpbiBjb250ZXh0bWVudVxuICAgICAgICB0aGlzLnN2Z09iai5hZGRBdHRyKHtcInR5cGVcIjogY2F0ZWdvcnl9KTtcblxuICAgICAgICB0aGlzLnN2Z09iai4kZWwuYWRkQ2xhc3MoXCJib3hcIik7XG4gICAgICAgIHRoaXMuc3ZnT2JqLiRlbC5hZGRDbGFzcyhjYXRlZ29yeSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXJsIG9mIHRoZSBpbWFnZSBkZXBpY3RpbmcgdGhpcyBvYmplY3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB1cmwoKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBjYXRlZ29yeSA9IHRoaXMuY2F0ZWdvcnkgfHwgXCJcIixcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLm5hbWUgfHwgXCJcIixcbiAgICAgICAgICAgIHN1ZmZpeCA9IHRoaXMuaW1nU3VmZml4IHx8IFwiXCI7XG5cbiAgICAgICAgcmV0dXJuIGBpbWcvc3ZnLyR7Y2F0ZWdvcnl9LyR7bmFtZX0ke3N1ZmZpeH0uc3ZnYDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgYWxsIGlucHV0IGNvbm5lY3RvcnMgb2YgdGhpcyBib3hcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgaW5wdXQgY29ubmVjdG9yc1xuICAgICAqL1xuICAgIGdldCBpbnB1dENvbm5lY3RvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RvcnMuZmlsdGVyKGNvbm4gPT4gY29ubi5pc0lucHV0Q29ubmVjdG9yKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBhbGwgb3V0cHV0IGNvbm5lY3RvcnMgb2YgdGhpcyBib3hcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2Ygb3V0cHV0IGNvbm5lY3RvcnNcbiAgICAgKi9cbiAgICBnZXQgb3V0cHV0Q29ubmVjdG9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdG9ycy5maWx0ZXIoY29ubiA9PiBjb25uLmlzT3V0cHV0Q29ubmVjdG9yKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBkYXRhIG9mIHRoaXMgYm94IGFzIGEgSlNPTi1yZWFkeSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgZXNzZW50aWFsIGRhdGEgZm9yIHRoaXMgYm94XG4gICAgICovXG4gICAgZ2V0IGV4cG9ydERhdGEoKSB7XG4gICAgICAgIGxldCBjb25uZWN0aW9ucyA9IFtdO1xuXG4gICAgICAgIC8vIGdvIHRocm91Z2ggYWxsIGNvbm5lY3RvcnNcbiAgICAgICAgbGV0IGNvdW50ZXIgPSAwXG4gICAgICAgIGZvciAoY29uc3QgY29ubiBvZiB0aGlzLmNvbm5lY3RvcnMpIHtcbiAgICAgICAgICAgIC8vIGdvIHRocm91Z2ggZWFjaCBpdHMgd2lyZSBpZFxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbm4ud2lyZUlkcykge1xuICAgICAgICAgICAgICAgIGxldCB0aGlzV2lyZUlkO1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLnBhcmVudFNWRy5leHBvcnRXaXJlSWRNYXAuaGFzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB3aXJlIGlkIGlzIG5vdCBpbiB0aGUgbWFwLCBhZGQgaXQgYW5kIGFzc2lnbiBuZXcgYXJiaXRyYXJ5IGlkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U1ZHLmV4cG9ydFdpcmVJZE1hcC5zZXQoaXRlbSwgdGhpcy5wYXJlbnRTVkcuZXhwb3J0V2lyZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1dpcmVJZCA9IHRoaXMucGFyZW50U1ZHLmV4cG9ydFdpcmVJZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTVkcuZXhwb3J0V2lyZUlkKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBnZXQgaWQgZnJvbSB0aGUgbWFwXG4gICAgICAgICAgICAgICAgICAgIHRoaXNXaXJlSWQgPSB0aGlzLnBhcmVudFNWRy5leHBvcnRXaXJlSWRNYXAuZ2V0KGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoaXMgY29ubmVjdGlvbiB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zW2Nvbm5lY3Rpb25zLmxlbmd0aF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBjb25uLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHdpcmVJZDogdGhpc1dpcmVJZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudGVyKytcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBjYXRlZ29yeTogdGhpcy5jYXRlZ29yeSxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5nZXRUcmFuc2Zvcm0odHJ1ZSksXG4gICAgICAgICAgICBjb25uZWN0aW9uczogY29ubmVjdGlvbnNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgc2V0IG9mIG5vZGVzIHRoYXQgYXJlIG5vdCBzdWl0YWJsZSBmb3Igd2lyZSByb3V0aW5nXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbbWFyZ2luVG9wPTBdICAgIHRvcCBtYXJnaW4gb2YgdGhlIGVsZW1lbnQgKGRpc3RhbmNlIGZyb20gdGhlIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgYWxzbyBibG9ja2VkKVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW21hcmdpblJpZ2h0PTBdICByaWdodCBtYXJnaW4gb2YgdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFttYXJnaW5Cb3R0b209MF0gYm90dG9tIG1hcmdpbiBvZiB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW21hcmdpbkxlZnQ9MF0gICBsZWZ0IG1hcmdpbiBvZiB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc3BlY2lhbE5vZGVzICAgICBhZGRpdGlvbmFsIG5vZGVzIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBzZXRcbiAgICAgKiBAcmV0dXJuIHtTZXR9ICAgICAgICAgICAgICAgICAgICAgc2V0IG9mIG5vdCBzdWl0YWJsZSBub2Rlc1xuICAgICAqL1xuICAgIGdlbmVyYXRlQmxvY2tOb2RlcyhtYXJnaW5Ub3AgPSAwLCBtYXJnaW5SaWdodCA9IDAsIG1hcmdpbkJvdHRvbSA9IDAsIG1hcmdpbkxlZnQgPSAwLCAuLi5zcGVjaWFsTm9kZXMpIHtcbiAgICAgICAgdGhpcy5ibG9ja2VkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvcihsZXQgeCA9IG1hcmdpbkxlZnQgOyB4IDw9IHRoaXMuZ3JpZFdpZHRoIC0gbWFyZ2luUmlnaHQgOyB4KyspIHtcbiAgICAgICAgICAgIGZvcihsZXQgeSA9IG1hcmdpblRvcCA7IHkgPD0gdGhpcy5ncmlkSGVpZ2h0IC0gbWFyZ2luQm90dG9tIDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja2VkTm9kZXMuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBzcGVjaWFsTm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYmxvY2tlZE5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGVtcHR5IGZ1bmN0aW9uLCByZWRlZmluZWQgaW4gaW5oZXJpdGVkIGVsZW1lbnRzXG4gICAgICogcmVmcmVzaFN0YXRlIHRha2VzIGlucHV0IGNvbm5lY3RvciB2YWx1ZXMgYW5kIHNldHMgb3V0cHV0IHZhbHVlcyBhY2NvcmRpbmdseVxuICAgICAqL1xuICAgIHJlZnJlc2hTdGF0ZSgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiQ2FsbGluZyB0aGUgdmlydHVhbCBmdW5jdGlvbiByZWZyZXNoU3RhdGUgaGFzIG5vIGVmZmVjdC5cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2hhbmdlIGltYWdlIHRvIGFub3RoZXIgb25lIHRoYXQgZW5kcyB3aXRoIGEgc3BlY2lmaWVkIHN1ZmZpeFxuICAgICAqXG4gICAgICogKnVzYWdlOiogYGNoYW5nZUltYWdlKFwiYWJjXCIpYCBjaGFuZ2VzIGltYWdlIHVybCB0byBgaW1hZ2UtYWJjLnN2Z2AsXG4gICAgICogYGNoYW5nZUltYWdlKClgIGNoYW5nZXMgaW1hZ2UgdXJsIHRvIHRoZSBkZWZhdWx0IG9uZSAoYGltYWdlLnN2Z2ApXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBbc3VmZml4XSBuZXcgc3VmZml4IGZvciB0aGUgaW1hZ2VcbiAgICAgKi9cbiAgICBjaGFuZ2VJbWFnZShzdWZmaXgpIHtcbiAgICAgICAgaWYoc3VmZml4ID09PSB1bmRlZmluZWQgfHwgc3VmZml4ID09PSBcIlwiKSB7XG4gICAgICAgICAgICB0aGlzLmltZ1N1ZmZpeCA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmltZ1N1ZmZpeCA9IFwiLVwiICsgc3VmZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbWFnZS5jaGFuZ2VVcmwodGhpcy51cmwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBhIGpRdWVyeSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGlzIGJveFxuICAgICAqIEByZXR1cm4ge2pRdWVyeS5lbGVtZW50fVxuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ZnT2JqLmdldCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJvdGF0ZSB0aGUgc2V0IG9mIGJsb2NrZWQgbm9kZXMgYnkgOTAgZGVncmVlcyB0byB0aGUgcmlnaHQgb3IgdG8gdGhlIGxlZnQsIGRlcGVuZGluZyBvbiB0aGUgcGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiB1c2VkIHRvIHJvdGF0ZSB0aGUgbm9kZXMgd2hlbiB0aGUgb2JqZWN0IGl0c2VsZiBpcyByb3RhdGVkXG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gcmlnaHQgcm90YXRlIGNsb2Nrd2lzZSBpZiB0cnVlLCBjb3VudGVyY2xvY2t3aXNlIGlmIGZhbHNlXG4gICAgICovXG4gICAgcm90YXRlQmxvY2tlZE5vZGVzKHJpZ2h0KSB7XG4gICAgICAgIGlmKHRoaXMucm90YXRpb25QYXJpdHk9PT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb25QYXJpdHkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucm90YXRpb25QYXJpdHkgPSAhdGhpcy5yb3RhdGlvblBhcml0eTtcblxuICAgICAgICBsZXQgbmV3QmxvY2tlZE5vZGVzID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8vIHJvdGF0ZSB0aGUgbm9kZVxuXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLmJsb2NrZWROb2Rlcykge1xuICAgICAgICAgICAgbGV0IG5ld05vZGU7XG5cbiAgICAgICAgICAgIGlmKHRoaXMucm90YXRpb25QYXJpdHkpIHtcbiAgICAgICAgICAgICAgICBpZihyaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogTWF0aC5hYnMobm9kZS55IC0gdGhpcy5ncmlkSGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IG5vZGUueFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld05vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBub2RlLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBNYXRoLmFicyhub2RlLnggLSB0aGlzLmdyaWRXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld05vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBNYXRoLmFicyhub2RlLnkgLSB0aGlzLmdyaWRXaWR0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBub2RlLnhcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogbm9kZS55LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogTWF0aC5hYnMobm9kZS54IC0gdGhpcy5ncmlkSGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3QmxvY2tlZE5vZGVzLmFkZChuZXdOb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYmxvY2tlZE5vZGVzID0gbmV3QmxvY2tlZE5vZGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJvdGF0ZSB0aGUgc2V0IG9mIGJsb2NrZWQgbm9kZXMgdG8gdGhlIHJpZ2h0XG4gICAgICpcbiAgICAgKiB1c2VkIHRvIHJvdGF0ZSB0aGUgbm9kZXMgd2hlbiB0aGUgb2JqZWN0IGl0c2VsZiBpcyByb3RhdGVkXG4gICAgICovXG4gICAgcm90YXRlQmxvY2tlZE5vZGVzUmlnaHQoKSB7XG4gICAgICAgIHRoaXMucm90YXRlQmxvY2tlZE5vZGVzKHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJvdGF0ZSB0aGUgc2V0IG9mIGJsb2NrZWQgbm9kZXMgdG8gdGhlIHJpZ2h0XG4gICAgICpcbiAgICAgKiB1c2VkIHRvIHJvdGF0ZSB0aGUgbm9kZXMgd2hlbiB0aGUgb2JqZWN0IGl0c2VsZiBpcyByb3RhdGVkXG4gICAgICovXG4gICAgcm90YXRlQmxvY2tlZE5vZGVzTGVmdCgpIHtcbiAgICAgICAgdGhpcy5yb3RhdGVCbG9ja2VkTm9kZXMoZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhIGNvbm5lY3RvciB0byB0aGUgZWxlbWVudCBvbiB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICBsZWZ0ICAgICAgICAgICAgIGhvcml6b250YWwgZGlzdGFuY2UgZnJvbSB0aGUgbGVmdCBlZGdlIG9mIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICB0b3AgICAgICAgICAgICAgIHZlcnRpY2FsIGRpc3RhbmNlIGZyb20gdGhlIHRvcCBlZGdlIG9mIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc0lucHV0Q29ubmVjdG9yIHdoZXRoZXIgb3Igbm90IHNob3VsZCB0aGlzIGNvbm5lY3RvciBhbiBpbnB1dCBjb25uZWN0b3IgKGB0cnVlYCBmb3IgaW5wdXQgY29ubmVjdG9yLCBgZmFsc2VgIGZvciBvdXRwdXQgY29ubmVjdG9yKVxuICAgICAqL1xuICAgIGFkZENvbm5lY3RvcihsZWZ0LCB0b3AsIGlzSW5wdXRDb25uZWN0b3IpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5jb25uZWN0b3JzLmxlbmd0aDtcbiAgICAgICAgaWYoaXNJbnB1dENvbm5lY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JzW2luZGV4XSA9IG5ldyBJbnB1dENvbm5lY3Rvcih0aGlzLnBhcmVudFNWRywgbGVmdCwgdG9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yc1tpbmRleF0gPSBuZXcgT3V0cHV0Q29ubmVjdG9yKHRoaXMucGFyZW50U1ZHLCBsZWZ0LCB0b3ApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ZnT2JqLmFkZENoaWxkKHRoaXMuY29ubmVjdG9yc1tpbmRleF0uZ2V0KCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhbiBpbnB1dCBjb25uZWN0b3IgdG8gdGhlIGVsZW1lbnQgb24gdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IGhvcml6b250YWwgZGlzdGFuY2UgZnJvbSB0aGUgbGVmdCBlZGdlIG9mIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcCAgdmVydGljYWwgZGlzdGFuY2UgZnJvbSB0aGUgdG9wIGVkZ2Ugb2YgdGhlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBhZGRJbnB1dENvbm5lY3RvcihsZWZ0LCB0b3ApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkQ29ubmVjdG9yKGxlZnQsIHRvcCwgdHJ1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYW4gb3V0cHV0IGNvbm5lY3RvciB0byB0aGUgZWxlbWVudCBvbiB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgaG9yaXpvbnRhbCBkaXN0YW5jZSBmcm9tIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wICB2ZXJ0aWNhbCBkaXN0YW5jZSBmcm9tIHRoZSB0b3AgZWRnZSBvZiB0aGUgZWxlbWVudFxuICAgICAqL1xuICAgIGFkZE91dHB1dENvbm5lY3RvcihsZWZ0LCB0b3ApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkQ29ubmVjdG9yKGxlZnQsIHRvcCwgZmFsc2UpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBjb25uZWN0b3Igb2JqZWN0IGJhc2VkIG9uIGl0cyBpZFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gY29ubmVjdG9ySWQgSUQgb2YgdGhlIHtAbGluayBDb25uZWN0b3J9XG4gICAgICogQHJldHVybiB7Q29ubmVjdG9yfSAgICAgICAgICAgICBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIENvbm5lY3Rvcn0gb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgZ2V0Q29ubmVjdG9yQnlJZChjb25uZWN0b3JJZCkge1xuICAgICAgICBmb3IobGV0IGkgPSAwIDsgaSA8IHRoaXMuY29ubmVjdG9ycy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgIGlmKHRoaXMuY29ubmVjdG9yc1tpXS5pZD09PWNvbm5lY3RvcklkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdG9yc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBjb25uZWN0b3Igbm90IGZvdW5kLCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBpbnN0YW5jZSBvZiB7QGxpbmsgVHJhbnNmb3JtfSByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIG9mIHRoaXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtncmlkUGl4ZWxzPWZhbHNlXSBpZiBgdHJ1ZWAsIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgaW4gZ3JpZCBwaXhlbHMgaW5zdGVhZCBvZiBTVkcgcGl4ZWxzXG4gICAgICogQHJldHVybiB7VHJhbnNmb3JtfSAgICAgICAgICAgICAgICAgIHtAbGluayBUcmFuc2Zvcm19IG9mIHRoZSBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0VHJhbnNmb3JtKGdyaWRQaXhlbHMgPSBmYWxzZSkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtO1xuICAgICAgICBpZiAoIXRoaXMuc3ZnT2JqLiRlbC5hdHRyKFwidHJhbnNmb3JtXCIpKSB7XG4gICAgICAgICAgICAvLyB0aGUgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGEgXCJ0cmFuc2Zvcm1cIiBwcm9wZXJ0eSAtLT4gY3JlYXRlIGl0XG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB0cmFuc2Zvcm0uc2V0VHJhbnNsYXRlKDAsIDApO1xuICAgICAgICAgICAgdGhpcy5zdmdPYmouYWRkQXR0cih7XCJ0cmFuc2Zvcm1cIjogdHJhbnNmb3JtLmdldCgpfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGUgZWxlbWVudCBkb2VzIGhhdmUgYSBcInRyYW5zZm9ybVwiIHByb3BlcnR5IC0tPiBjaGFuZ2UgaXRcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0odGhpcy5zdmdPYmouJGVsLmF0dHIoXCJ0cmFuc2Zvcm1cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29udmVydCB2YWx1ZXMgdG8gZ3JpZCBwaXhlbHNcbiAgICAgICAgaWYoZ3JpZFBpeGVscykge1xuICAgICAgICAgICAgdHJhbnNmb3JtLnRvR3JpZFBpeGVscyh0aGlzLnBhcmVudFNWRyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgaW5zdGFuY2Ugb2Yge0BsaW5rIFRyYW5zZm9ybX0gcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSBvZiB0aGlzIGVsZW1lbnQgX3dpdGggbGVuZ2h0IHVuaXRzIGluIGdyaWQgcGl4ZWxzX1xuICAgICAqIEByZXR1cm4ge1RyYW5zZm9ybX0ge0BsaW5rIFRyYW5zZm9ybX0gb2YgdGhlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRHcmlkUGl4ZWxUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRyYW5zZm9ybSh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUgb2YgdGhpcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybSB7QGxpbmsgVHJhbnNmb3JtfSBvZiB0aGUgZWxlbWVudCAod2l0aCBsZW5ndGhzIHNwZWNpZmllZCBpbiBTVkcgcGl4ZWxzKVxuICAgICAqL1xuICAgIHNldFRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5zdmdPYmouYWRkQXR0cih7XCJ0cmFuc2Zvcm1cIjogdHJhbnNmb3JtLmdldCgpfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gZXZlcnkgbW91c2UgZG93biBvbiB0aGlzIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIG1vdmVzIHRoZSBlbGVtZW50IHRvIHRoZSBmcm9udCBhbmQgY2FsbHMgb25Nb3VzZURvd25MZWZ0IGlmIGFwcGxpY2FibGVcbiAgICAgKiBAcGFyYW0gIHtqUXVlcnkuTW91c2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICB0aGlzLm1vdXNlTGVmdCA9IGZhbHNlO1xuICAgICAgICBpZihldmVudC53aGljaCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5tb3VzZUxlZnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5vbk1vdXNlRG93bkxlZnQoZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBtb3ZlIHRoZSBET00gZWxlbWVudCB0byBmcm9udFxuICAgICAgICAgICAgdGhpcy5wYXJlbnRTVkcubW92ZVRvRnJvbnRCeUlkKHRoaXMuc3ZnT2JqLmlkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uIGV2ZXJ5IGxlZnQgbW91c2UgZG93biBvbiB0aGlzIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIHByZXBhcmVzIGVsZW1lbnQgZm9yIHRoZSBcImNsaWNrXCIgYW5kIFwiZHJhZyBhbmQgZHJvcFwiIGFjdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtqUXVlcnkuTW91c2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bkxlZnQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb3VzZU1vdmVkID0gZmFsc2U7XG5cbiAgICAgICAgbGV0IHRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKCk7XG5cbiAgICAgICAgLy8gc2F2ZSB0aGUgY3VycmVudCBpdGVtIHBvc2l0aW9uIGludG8gYSB2YXJpYWJsZVxuICAgICAgICBsZXQgY3VycmVudFBvc2l0aW9uID0gdHJhbnNmb3JtLmdldFRyYW5zbGF0ZSgpO1xuXG4gICAgICAgIGxldCB7cGFnZVgsIHBhZ2VZfSA9IHRoaXMucGFyZW50U1ZHLnZpZXdib3gudHJhbnNmb3JtRXZlbnQoZXZlbnQpXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIG1vdXNlIG9mZnNldCBmcm9tIHRoZSBvYmplY3Qgb3JpZ2luXG4gICAgICAgIHRoaXMub2Zmc2V0ID0ge1xuICAgICAgICAgICAgeDogcGFnZVggLSBjdXJyZW50UG9zaXRpb24ueCxcbiAgICAgICAgICAgIHk6IHBhZ2VZIC0gY3VycmVudFBvc2l0aW9uLnlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiBldmVyeSBsZWZ0IG1vdXNlIG1vdmUgd2l0aCB0aGlzIGVsZW1lbnRcbiAgICAgKiBhcHBsaWVzIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSB2YWx1ZXMgdG8gcHJvdmlkZSB0aGUgXCJkcmFnIGFuZCBkcm9wXCIgZnVuY3Rpb25hbGl0eVxuICAgICAqIEBwYXJhbSAge2pRdWVyeS5Nb3VzZUV2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIGlmKHRoaXMubW91c2VMZWZ0KSB7XG4gICAgICAgICAgICB0aGlzLnN2Z09iai4kZWwuYWRkQ2xhc3MoJ2dyYWJiZWQnKTtcblxuICAgICAgICAgICAgdGhpcy5tb3VzZU1vdmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgbGV0IHtwYWdlWCwgcGFnZVl9ID0gdGhpcy5wYXJlbnRTVkcudmlld2JveC50cmFuc2Zvcm1FdmVudChldmVudClcblxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHBhZ2VYIC0gdGhpcy5vZmZzZXQueDtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IHBhZ2VZIC0gdGhpcy5vZmZzZXQueTtcblxuICAgICAgICAgICAgbGV0IHRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB0cmFuc2Zvcm0uc2V0VHJhbnNsYXRlKGxlZnQsIHRvcCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlV2lyZXModHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiBldmVyeSBtb3VzZSB1cCBvbiB0aGlzIGVsZW1lbnRcbiAgICAgKiBwcm92aWRlcyB0aGUgXCJjbGlja1wiIGZ1bmN0aW9uYWxpdHkgYW5kIGNhbGxzIHRoZSBvbkRyb3AgaGFuZGxlciBmb3IgdGhlIFwiZHJhZyBhbmQgZHJvcFwiIGZ1bmN0aW9uYWxpdHlcbiAgICAgKiBAcGFyYW0gIHtqUXVlcnkuTW91c2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgaWYoZXZlbnQud2hpY2ggPT09IDEpIHtcbiAgICAgICAgICAgIGlmKHRoaXMubW91c2VNb3ZlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Ecm9wKGV2ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDIgKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2xpY2tNaWRkbGUoZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdmdPYmouJGVsLnJlbW92ZUNsYXNzKCdncmFiYmVkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2FsbGVkIGJ5IG9uTW91c2VVcCB3aGVuIHRoZSBtb3VzZSBoYXMgYmVlbiBtb3ZlZCBiZXR3ZWVuIG9uTW91c2VEb3duIGFuZCBvbk1vdXNlVXBcbiAgICAgKlxuICAgICAqIGFwcGxpZXMgZ3JpZCBzbmFwcGluZyBvZiB0aGUgZWxlbWVudCBvbiB0aGUgZW5kIG9mIHRoZSBcImRyYWcgYW5kIGRyb3BcIiBhY3Rpb25cbiAgICAgKiBAcGFyYW0gIHtqUXVlcnkuTW91c2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbkRyb3AoZXZlbnQpIHtcbiAgICAgICAgbGV0IHtwYWdlWCwgcGFnZVl9ID0gdGhpcy5wYXJlbnRTVkcudmlld2JveC50cmFuc2Zvcm1FdmVudChldmVudClcblxuICAgICAgICBsZXQgbGVmdCA9IHBhZ2VYIC0gdGhpcy5vZmZzZXQueDtcbiAgICAgICAgbGV0IHRvcCA9IHBhZ2VZIC0gdGhpcy5vZmZzZXQueTtcblxuICAgICAgICBsZWZ0ID0gdGhpcy5wYXJlbnRTVkcuc25hcFRvR3JpZChsZWZ0KTtcbiAgICAgICAgdG9wID0gdGhpcy5wYXJlbnRTVkcuc25hcFRvR3JpZCh0b3ApO1xuXG4gICAgICAgIGxldCB0cmFuc2Zvcm0gPSB0aGlzLmdldFRyYW5zZm9ybSgpO1xuICAgICAgICB0cmFuc2Zvcm0uc2V0VHJhbnNsYXRlKGxlZnQsIHRvcCk7XG5cbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZVdpcmVzKCk7XG5cbiAgICAgICAgLy8gaWYgdHV0b3JpYWwgZXhpc3RzLCBjYWxsIHR1dG9yaWFsIGNhbGxiYWNrXG4gICAgICAgIGlmKHRoaXMucGFyZW50U1ZHLnR1dG9yaWFsKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFNWRy50dXRvcmlhbC5vbkJveE1vdmVkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBlbXB0eSBmdW5jdGlvbiwgd2lsbCBiZSByZWRlZmluZWQgaW4gSW5wdXRCb3hcbiAgICAgKi9cbiAgICBvbkNsaWNrKCkge31cblxuICAgIC8qKlxuICAgICAqIGN1c3RvbSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgbWlkZGxlIGNsaWNrIHRoYXQgcm90YXRlcyB0aGUgYm94IGJ5IDkwIGRlZ3JlZXMgdG8gdGhlIHJpZ2h0XG4gICAgICovXG4gICAgb25DbGlja01pZGRsZShldmVudCkge1xuICAgICAgICAvLyBnZXQgdGhlIHRyYW5zZm9ybSB2YWx1ZSBmb3IgdGhpcyBib3hcbiAgICAgICAgbGV0IHRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKCk7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBib3VuZGluZyByZWN0YW5nbGUgZm9yIHRoaXMgYm94XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5zdmdPYmouJGVsWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIC8vIHVzZSB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIGRpbWVuc2lvbnMgdG8gZmlndXJlIG91dCB0aGUgZ2VvbWV0cmljYWwgY2VudHJlIG9mIHRoZSBib3hcbiAgICAgICAgbGV0IGNlbnRyZVggPSBNYXRoLnJvdW5kKHJlY3Qud2lkdGggLyAyKTtcbiAgICAgICAgbGV0IGNlbnRyZVkgPSBNYXRoLnJvdW5kKHJlY3QuaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgY2VudHJlWCAtPSBjZW50cmVYICUgdGhpcy5ncmlkU2l6ZTtcbiAgICAgICAgY2VudHJlWSAtPSBjZW50cmVZICUgdGhpcy5ncmlkU2l6ZTtcblxuICAgICAgICAvLyBhcHBseSB0aGUgcm90YXRpb24gdG8gdGhlIHRyYW5zZm9ybSBvYmplY3RcbiAgICAgICAgaWYoZXZlbnQuY3RybEtleSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtLnJvdGF0ZUxlZnQoY2VudHJlWCwgY2VudHJlWSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0ucm90YXRlUmlnaHQoY2VudHJlWCwgY2VudHJlWSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIGFwcGx5IHRoZSBtb2RpZmllZCB0cmFuc2Zvcm0gb2JqZWN0IG90IHRoZSBzdmdPYmpcbiAgICAgICAgdGhpcy5zdmdPYmouYWRkQXR0cih7XCJ0cmFuc2Zvcm1cIjogdHJhbnNmb3JtLmdldCgpfSk7XG5cbiAgICAgICAgLy8gcm90YXRlIGFsc28gdGhlIGJsb2NrZWQgbm9kZXNcbiAgICAgICAgaWYoZXZlbnQuY3RybEtleSkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGVCbG9ja2VkTm9kZXNMZWZ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZUJsb2NrZWROb2Rlc1JpZ2h0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHdpcmVzXG4gICAgICAgIHRoaXMudXBkYXRlV2lyZXMoKTtcblxuICAgICAgICAvLyBpZiB0dXRvcmlhbCBleGlzdHMsIGNhbGwgdHV0b3JpYWwgY2FsbGJhY2tcbiAgICAgICAgaWYodGhpcy5wYXJlbnRTVkcudHV0b3JpYWwpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50U1ZHLnR1dG9yaWFsLm9uQm94Um90YXRlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhbGwgd2lyZXMgY29ubmVjdGVkIHRvIHRoaXMgYm94LiBJdGVyYXRlcyBvdmVyIGFsbCB3aXJlcyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gdGhpcyBib3hcbiAgICAgKiBhbmQgY2FsbHMgcm91dGVXaXJlIChvciB0ZW1wb3JhcnlXaXJlIGlmIHRoZSBgdGVtcG9yYXJ5YCBwYXJhbWV0ZXIgaXMgc2V0IHRvIHRydWUpIHRvIHVwZGF0ZSB0aGUgd2lyZSByb3V0aW5nXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW3RlbXBvcmFyeT1mYWxzZV0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIHVwZGF0ZVdpcmVzKHRlbXBvcmFyeSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdG9ycy5mb3JFYWNoKGNvbm4gPT4ge1xuICAgICAgICAgICAgY29ubi53aXJlSWRzLmZvckVhY2god2lyZUlkID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgd2lyZSA9IHRoaXMucGFyZW50U1ZHLmdldFdpcmVCeUlkKHdpcmVJZCk7XG4gICAgICAgICAgICAgICAgaWYodGVtcG9yYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHdpcmUudGVtcG9yYXJ5V2lyZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpcmUucm91dGVXaXJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9XG59XG5cbi8qKlxuICogSW5wdXRCb3ggaGFzIG9ubHkgb3V0cHV0IGNvbm5lY3RvcnMgYW5kIGlzIHVzZWQgdG8gc2V0IHRoZSBpbnB1dCBzdGF0ZXMgZm9yIHRoZSBsb2dpYyBuZXR3b3JrLlxuICogQGV4dGVuZHMgQm94XG4gKi9cbmV4cG9ydCBjbGFzcyBJbnB1dEJveCBleHRlbmRzIEJveCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDYW52YXN9IHBhcmVudFNWRyAgaW5zdGFuY2Ugb2YgW0NhbnZhc10oLi9tb2R1bGUtQ2FudmFzLmh0bWwpXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaXNPbj1mYWxzZV0gdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIGlucHV0Ym94IChgdHJ1ZWAgaXMgKm9uKiwgYGZhbHNlYCBpcyAqb2ZmKilcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRTVkcsIGlzT24gPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBncmlkV2lkdGggPSA3O1xuICAgICAgICBjb25zdCBncmlkSGVpZ2h0ID0gNDtcblxuICAgICAgICBzdXBlcihwYXJlbnRTVkcsIFwiaW5wdXRcIiwgXCJvdGhlclwiLCBncmlkV2lkdGgsIGdyaWRIZWlnaHQpO1xuXG4gICAgICAgIHRoaXMuYWRkQ29ubmVjdG9yKGdyaWRXaWR0aCwgZ3JpZEhlaWdodCAvIDIsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLm9uID0gaXNPbjtcblxuICAgICAgICB0aGlzLmdlbmVyYXRlQmxvY2tOb2RlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBkYXRhIG9mIHRoaXMgaW5wdXQgYm94IGFzIGEgSlNPTi1yZWFkeSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgZXNzZW50aWFsIGRhdGEgZm9yIHRoaXMgaW5wdXQgYm94XG4gICAgICovXG4gICAgZ2V0IGV4cG9ydERhdGEoKSB7XG4gICAgICAgIGxldCBkYXRhID0gc3VwZXIuZXhwb3J0RGF0YTtcbiAgICAgICAgZGF0YS5pc09uID0gdGhpcy5pc09uO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGdlbmVyYXRlQmxvY2tOb2RlcygpIHtcbiAgICAgICAgLy8gYmxvY2sgdGhlIGlucHV0IGNvbm5lY3RvciBub2RlXG4gICAgICAgIGNvbnN0IHNwZWNpYWxOb2RlID0ge1xuICAgICAgICAgICAgeDogdGhpcy5ncmlkV2lkdGgsXG4gICAgICAgICAgICB5OiB0aGlzLmdyaWRIZWlnaHQgLyAyXG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZ2VuZXJhdGVCbG9ja05vZGVzKDAsIDEsIDEsIDAsIHNwZWNpYWxOb2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdGFydCBhIG5ldyBzaW11bGF0aW9uIGZyb20gdGhlIG91dHB1dCBjb25uZWN0b3JcbiAgICAgKi9cbiAgICByZWZyZXNoU3RhdGUoKSB7XG4gICAgICAgIHRoaXMucGFyZW50U1ZHLnN0YXJ0TmV3U2ltdWxhdGlvbih0aGlzLmNvbm5lY3RvcnNbMF0sIHRoaXMuY29ubmVjdG9yc1swXS5zdGF0ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIHN0YXRlIG9mIHRoZSBpbnB1dGJveCB0byB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGlzT24gc2V0IHRvICpvbiogaWYgYHRydWVgLCBzZXQgdG8gKm9mZiogaWYgYGZhbHNlYFxuICAgICAqL1xuICAgIHNldCBvbihpc09uKSB7XG4gICAgICAgIGlmIChpc09uKSB7XG4gICAgICAgICAgICAvLyB0dXJuIG9uXG4gICAgICAgICAgICB0aGlzLmNoYW5nZUltYWdlKFwib25cIik7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnNbMF0uc2V0U3RhdGUoTG9naWMuc3RhdGUub24pO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoU3RhdGUoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdHVybiBvZmZcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlSW1hZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yc1swXS5zZXRTdGF0ZShMb2dpYy5zdGF0ZS5vZmYpO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoU3RhdGUoKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc09uID0gaXNPbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHN0YXRlIG9mIHRoZSBpbnB1dGJveCAoYHRydWVgIGlmICpvbiosIGBmYWxzZWAgaWYgKm9mZiopXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIGdldCBvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0b2dnbGUgdGhlIHN0YXRlIG9mIHRoZSBpbnB1dGJveFxuICAgICAqL1xuICAgIG9uQ2xpY2soKSB7XG4gICAgICAgIHRoaXMub24gPSAhdGhpcy5vbjtcblxuICAgICAgICBpZih0aGlzLnBhcmVudFNWRy50dXRvcmlhbCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRTVkcudHV0b3JpYWwub25DaGFuZ2VJbnB1dEJveFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogT3V0cHV0Qm94IGhhcyBvbmx5IGlucHV0IGNvbm5lY3RvcnMgYW5kIGlzIHVzZWQgdG8gdmlzdWFsaXplIHRoZSBvdXRwdXQgc3RhdGVzIG9mIHRoZSBsb2dpYyBuZXR3b3JrLlxuICogQGV4dGVuZHMgQm94XG4gKi9cbmV4cG9ydCBjbGFzcyBPdXRwdXRCb3ggZXh0ZW5kcyBCb3gge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzfSBwYXJlbnRTVkcgIGluc3RhbmNlIG9mIFtDYW52YXNdKC4vbW9kdWxlLUNhbnZhcy5odG1sKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFNWRykge1xuICAgICAgICBjb25zdCBncmlkSGVpZ2h0ID0gNDtcbiAgICAgICAgY29uc3QgZ3JpZFdpZHRoID0gNTtcblxuICAgICAgICBzdXBlcihwYXJlbnRTVkcsIFwib3V0cHV0XCIsIFwib3RoZXJcIiwgZ3JpZFdpZHRoLCBncmlkSGVpZ2h0KTtcblxuICAgICAgICB0aGlzLmFkZENvbm5lY3RvcigwLCBncmlkSGVpZ2h0IC8gMiwgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5nZW5lcmF0ZUJsb2NrTm9kZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgc3RhdGUgb2YgdGhpcyBvdXRwdXQgYm94IHRvIG1hdGNoIHRoZSBzdGF0ZSBvZiBpdHMgaW5wdXQgY29ubmVjdG9yXG4gICAgICovXG4gICAgcmVmcmVzaFN0YXRlKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHRoaXMuY29ubmVjdG9yc1swXS5zdGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVmbGVjdCB0aGUgaW5wdXQgY29ubmVjdG9yIHN0YXRlIGluIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBlbGVtZW50IC0gc2V0XG4gICAgICogdGhlIGVsZW1lbnQgaW1hZ2UgdG8gcmVwcmVzZW50IHRoZSBjb3JyZXNwb25kaW5nIHN0YXRlXG4gICAgICogQHBhcmFtIHtMb2dpYy5zdGF0ZX0gc3RhdGUgbmV3IHN0YXRlIG9mIHRoaXMgb3V0cHV0Qm94XG4gICAgICovXG4gICAgc2V0U3RhdGUoc3RhdGUpIHtcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBMb2dpYy5zdGF0ZS5vbjpcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZUltYWdlKFwib25cIik7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0dXRvcmlhbCBleGlzdHMsIGNhbGwgdHV0b3JpYWwgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBpZih0aGlzLnBhcmVudFNWRy50dXRvcmlhbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNWRy50dXRvcmlhbC5vbk91dHB1dEJveFRydWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExvZ2ljLnN0YXRlLm9mZjpcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZUltYWdlKFwib2ZmXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMb2dpYy5zdGF0ZS51bmtub3duOlxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTG9naWMuc3RhdGUub3NjaWxsYXRpbmc6XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VJbWFnZShcIm9zY1wiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdlbmVyYXRlQmxvY2tOb2RlcygpIHtcbiAgICAgICAgLy8gYmxvY2sgdGhlIGlucHV0IGNvbm5lY3RvciBub2RlXG4gICAgICAgIGNvbnN0IHNwZWNpYWxOb2RlID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IHRoaXMuZ3JpZEhlaWdodCAvIDJcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5nZW5lcmF0ZUJsb2NrTm9kZXMoMCwgMCwgMCwgMSwgc3BlY2lhbE5vZGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBHYXRlIGlzIGEgYm94IHRoYXQgcHJvY2Vzc2VzIHRoZSBzdGF0ZXMgb2YgaXRzIGlucHV0IGNvbm5lY3RvcnMgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBpbiBpdHMgb3V0cHV0IGNvbm5lY3RvcnMuXG4gKiBAZXh0ZW5kcyBCb3hcbiAqL1xuZXhwb3J0IGNsYXNzIEdhdGUgZXh0ZW5kcyBCb3gge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzfSBwYXJlbnRTVkcgIGluc3RhbmNlIG9mIFtDYW52YXNdKC4vbW9kdWxlLUNhbnZhcy5odG1sKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgICAgIG5hbWUgb2YgdGhlIGdhdGUgKGFuZCwgbm90LCB4b3IuLi4pXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyZW50U1ZHLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gOTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gNDtcblxuICAgICAgICBzdXBlcihwYXJlbnRTVkcsIG5hbWUsIFwiZ2F0ZVwiLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvLyBBREQgQ09OTkVDVE9SU1xuXG4gICAgICAgIGxldCBzcGVjaWFsTm9kZXMgPSBbXTtcblxuICAgICAgICAvLyBvdXRwdXRcbiAgICAgICAgdGhpcy5hZGRDb25uZWN0b3Iod2lkdGgsIGhlaWdodCAvIDIsIGZhbHNlKTtcblxuICAgICAgICAvLyBibG9jayB0aGUgb3V0cHV0IGNvbm5lY3RvclxuICAgICAgICBzcGVjaWFsTm9kZXMucHVzaCh7XG4gICAgICAgICAgICB4OiB3aWR0aCxcbiAgICAgICAgICAgIHk6IGhlaWdodCAvIDJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYodGhpcy5uYW1lPT09XCJub3RcIiB8fCB0aGlzLm5hbWU9PT1cInJlcGVhdGVyXCIpIHtcbiAgICAgICAgICAgIC8vIGlucHV0XG4gICAgICAgICAgICB0aGlzLmFkZENvbm5lY3RvcigwLCBoZWlnaHQgLyAyLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGJsb2NrIHRoZSBpbnB1dCBjb25uZWN0b3JcbiAgICAgICAgICAgIHNwZWNpYWxOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IGhlaWdodCAvIDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5wdXRcbiAgICAgICAgICAgIHRoaXMuYWRkQ29ubmVjdG9yKDAsIGhlaWdodCAvIDQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5hZGRDb25uZWN0b3IoMCwgaGVpZ2h0IC8gKDQvMyksIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBibG9jayB0aGUgaW5wdXQgY29ubmVjdG9yc1xuICAgICAgICAgICAgc3BlY2lhbE5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogaGVpZ2h0IC8gNFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHNwZWNpYWxOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IGhlaWdodCAvICg0LzMpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gYWRkIG9uZSBibG9ja2VkIG5vZGUgYmV0d2VlbiB0aGUgaW5wdXRzIChmb3IgYmV0dGVyIGxvb2tpbmcgd2lyaW5nKVxuICAgICAgICAgICAgc3BlY2lhbE5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogaGVpZ2h0IC8gMlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdlbmVyYXRlQmxvY2tOb2RlcyguLi5zcGVjaWFsTm9kZXMpO1xuXG4gICAgICAgIHRoaXMucmVmcmVzaFN0YXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYXJyYXkgb2YgdmFsaWQgZ2F0ZSBuYW1lc1xuICAgICAqIEB0eXBlIHtTZXR9XG4gICAgICovXG4gICAgc3RhdGljIGdldCB2YWxpZEdhdGVzKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNldChbXCJub3RcIiwgXCJhbmRcIiwgXCJvclwiLCBcIm5hbmRcIiwgXCJub3JcIiwgXCJ4b3JcIiwgXCJ4bm9yXCIsIFwicmVwZWF0ZXJcIl0pO1xuICAgIH1cblxuICAgIGdlbmVyYXRlQmxvY2tOb2RlcyguLi5zcGVjaWFsTm9kZXMpIHtcbiAgICAgICAgaWYoc3BlY2lhbE5vZGVzIT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdXBlci5nZW5lcmF0ZUJsb2NrTm9kZXMoMCwgMSwgMCwgMSwgLi4uc3BlY2lhbE5vZGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLmdlbmVyYXRlQmxvY2tOb2RlcygwLCAxLCAwLCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByb2NjZXNzIHRoZSBpbnB1dCBjb25uZWN0b3Igc3RhdGVzIGFuZCByZWZsZWN0IHRoZW0gaW4gdGhlIG91dHB1dCBjb25uZWN0b3Igc3RhdGVzIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBsb2dpYyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgZ2F0ZSdzIG5hbWVcbiAgICAgKi9cbiAgICByZWZyZXNoU3RhdGUoKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IExvZ2ljLnN0YXRlLnVua25vd25cbiAgICAgICAgc3dpdGNoICh0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhbmRcIjpcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IExvZ2ljLmFuZCh0aGlzLmNvbm5lY3RvcnNbMV0uc3RhdGUsIHRoaXMuY29ubmVjdG9yc1syXS5zdGF0ZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJuYW5kXCI6XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBMb2dpYy5uYW5kKHRoaXMuY29ubmVjdG9yc1sxXS5zdGF0ZSwgdGhpcy5jb25uZWN0b3JzWzJdLnN0YXRlKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm5vclwiOlxuICAgICAgICAgICAgICAgIHN0YXRlID0gTG9naWMubm9yKHRoaXMuY29ubmVjdG9yc1sxXS5zdGF0ZSwgdGhpcy5jb25uZWN0b3JzWzJdLnN0YXRlKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm5vdFwiOlxuICAgICAgICAgICAgICAgIHN0YXRlID0gTG9naWMubm90KHRoaXMuY29ubmVjdG9yc1sxXS5zdGF0ZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvclwiOlxuICAgICAgICAgICAgICAgIHN0YXRlID0gTG9naWMub3IodGhpcy5jb25uZWN0b3JzWzFdLnN0YXRlLCB0aGlzLmNvbm5lY3RvcnNbMl0uc3RhdGUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwieG5vclwiOlxuICAgICAgICAgICAgICAgIHN0YXRlID0gTG9naWMueG5vcih0aGlzLmNvbm5lY3RvcnNbMV0uc3RhdGUsIHRoaXMuY29ubmVjdG9yc1syXS5zdGF0ZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ4b3JcIjpcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IExvZ2ljLnhvcih0aGlzLmNvbm5lY3RvcnNbMV0uc3RhdGUsIHRoaXMuY29ubmVjdG9yc1syXS5zdGF0ZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyZXBlYXRlclwiOlxuICAgICAgICAgICAgICAgIHN0YXRlID0gdGhpcy5jb25uZWN0b3JzWzFdLnN0YXRlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90aWZ5IHRoZSBzaW11bGF0b3IgYWJvdXQgdGhpcyBjaGFuZ2VcbiAgICAgICAgdGhpcy5wYXJlbnRTVkcuc2ltdWxhdGlvbi5ub3RpZnlDaGFuZ2UodGhpcy5jb25uZWN0b3JzWzBdLmlkLCBzdGF0ZSlcbiAgICB9XG59XG5cbi8qKlxuICogQmxhY2tib3ggaXMgYSBib3ggdGhhdCBpcyBkZWZpbmVkIGJ5IGl0cyBldmFsdWF0aW9uIGZ1bmN0aW9uXG4gKiBAZXh0ZW5kcyBCb3hcbiAqL1xuZXhwb3J0IGNsYXNzIEJsYWNrYm94IGV4dGVuZHMgQm94IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gcGFyZW50U1ZHICBpbnN0YW5jZSBvZiBbQ2FudmFzXSguL21vZHVsZS1DYW52YXMuaHRtbClcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5wdXRDb25uZWN0b3JzICBudW1iZXIgb2YgaW5wdXQgY29ubmVjdG9yc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvdXRwdXRDb25uZWN0b3JzIG51bWJlciBvZiBvdXRwdXQgY29ubmVjdG9yc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2YWxGdW5jdGlvbiAgIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYGlucHV0Q29ubmVjdG9yc2AgW0xvZ2ljLnN0YXRlXSguL21vZHVsZS1Mb2dpYy5odG1sIy5zdGF0ZSlzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHJldHVybnMgYG91dHB1dENvbm5lY3RvcnNgIExvZ2ljLnN0YXRlcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdICAgICAgICBuYW1lIHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgb24gdGhlIGJsYWNrYm94XG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyZW50U1ZHLCBpbnB1dENvbm5lY3RvcnMsIG91dHB1dENvbm5lY3RvcnMsIGV2YWxGdW5jdGlvbiwgbmFtZSA9IFwiXCIpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSAxMTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgoaW5wdXRDb25uZWN0b3JzLCBvdXRwdXRDb25uZWN0b3JzKSAqIDI7XG5cbiAgICAgICAgc3VwZXIocGFyZW50U1ZHLCBuYW1lLCBcImJsYWNrYm94XCIsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIGNvbnN0IGNvbm5lY3RvclBpbkxlbmdodCA9IDIuNSAqIHRoaXMuZ3JpZFNpemU7XG5cbiAgICAgICAgLy8gb3ZlcnJpZGUgZGVmYXVsdCBzdmdPYmogc3RydWN0dXJlXG4gICAgICAgIHRoaXMuc3ZnT2JqID0gbmV3IHN2Z09iai5Hcm91cCgpO1xuXG4gICAgICAgIC8vIHRyYW5zcGFyZW50IGJhY2tncm91bmQgcmVjdGFuZ2xlXG4gICAgICAgIGxldCBoaXRib3ggPSBuZXcgc3ZnT2JqLlJlY3RhbmdsZSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgXCJub25lXCIsIFwibm9uZVwiKTtcbiAgICAgICAgaGl0Ym94LiRlbC5hZGRDbGFzcygncmVjdCcpO1xuXG4gICAgICAgIHRoaXMuc3ZnT2JqLmFkZENoaWxkKGhpdGJveCk7XG5cbiAgICAgICAgLy8gbWFpbiByZWN0YW5nbGVcbiAgICAgICAgY29uc3QgYm9keVdpZHRoID0gdGhpcy53aWR0aCAtIDIgKiBjb25uZWN0b3JQaW5MZW5naHQ7XG5cbiAgICAgICAgbGV0IHJlY3RhbmdsZSA9IG5ldyBzdmdPYmouUmVjdGFuZ2xlKGNvbm5lY3RvclBpbkxlbmdodCwgMCwgYm9keVdpZHRoLCB0aGlzLmhlaWdodCwgXCJ3aGl0ZVwiLCBcImJsYWNrXCIpO1xuICAgICAgICByZWN0YW5nbGUuYWRkQXR0cih7J3N0cm9rZS13aWR0aCc6ICcyLjUnfSk7XG4gICAgICAgIHJlY3RhbmdsZS4kZWwuYWRkQ2xhc3MoJ3JlY3QnKTtcblxuICAgICAgICB0aGlzLnN2Z09iai5hZGRDaGlsZChyZWN0YW5nbGUpO1xuXG4gICAgICAgIC8vIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGJveFxuICAgICAgICBjb25zdCB0ZXh0V2lkdGggPSBib2R5V2lkdGggLSB0aGlzLmdyaWRTaXplO1xuICAgICAgICBjb25zdCB0ZXh0SGVpZ2h0ID0gdGhpcy5oZWlnaHQgLSB0aGlzLmdyaWRTaXplO1xuICAgICAgICBsZXQgdGV4dCA9IG5ldyBzdmdPYmouTXVsdGlMaW5lVGV4dChcbiAgICAgICAgICAgICh0aGlzLndpZHRoIC0gdGV4dFdpZHRoKSAvIDIsIC8vIGhvcml6b250YWwgY2VudGVyaW5nXG4gICAgICAgICAgICAodGhpcy5oZWlnaHQgLSB0ZXh0SGVpZ2h0KSAvIDIsIC8vIHZlcnRpY2FsIGNlbnRlcmluZ1xuICAgICAgICAgICAgdGV4dFdpZHRoLFxuICAgICAgICAgICAgdGV4dEhlaWdodCxcbiAgICAgICAgICAgIG5hbWUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgIHRoaXMuZ3JpZFNpemUgKiAxLjJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zdmdPYmouYWRkQ2hpbGQodGV4dCk7XG5cbiAgICAgICAgLy8gYWRkIGlucHV0IGNvbm5lY3RvcnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDAgOyBpIDwgaW5wdXRDb25uZWN0b3JzIDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBncmlkUG9zaXRpb24gPSAoaSAqIDIpICsgMTtcbiAgICAgICAgICAgIGNvbnN0IHBpeGVsUG9zaXRpb24gPSBncmlkUG9zaXRpb24gKiB0aGlzLmdyaWRTaXplO1xuXG4gICAgICAgICAgICBsZXQgcGluID0gbmV3IHN2Z09iai5Qb2x5TGluZShcbiAgICAgICAgICAgICAgICBuZXcgc3ZnT2JqLlBvbHlsaW5lUG9pbnRzKFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IHN2Z09iai5Qb2x5bGluZVBvaW50KDAsIHBpeGVsUG9zaXRpb24pLFxuICAgICAgICAgICAgICAgICAgICBuZXcgc3ZnT2JqLlBvbHlsaW5lUG9pbnQoY29ubmVjdG9yUGluTGVuZ2h0LCBwaXhlbFBvc2l0aW9uKSxcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgIFwiYmxhY2tcIlxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICB0aGlzLnN2Z09iai5hZGRDaGlsZChwaW4pO1xuXG4gICAgICAgICAgICAvLyBhZGQgdGhlIGNvbm5lY3RvclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dENvbm5lY3RvcigwLCBncmlkUG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIG91dHB1dCBjb25uZWN0b3JzXG4gICAgICAgIGZvciAobGV0IGkgPSAwIDsgaSA8IG91dHB1dENvbm5lY3RvcnMgOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyaWRQb3NpdGlvbiA9IChpICogMikgKyAxO1xuICAgICAgICAgICAgY29uc3QgcGl4ZWxQb3NpdGlvbiA9IGdyaWRQb3NpdGlvbiAqIHRoaXMuZ3JpZFNpemU7XG5cbiAgICAgICAgICAgIGxldCBwaW4gPSBuZXcgc3ZnT2JqLlBvbHlMaW5lKFxuICAgICAgICAgICAgICAgIG5ldyBzdmdPYmouUG9seWxpbmVQb2ludHMoW1xuICAgICAgICAgICAgICAgICAgICBuZXcgc3ZnT2JqLlBvbHlsaW5lUG9pbnQodGhpcy53aWR0aCAtIGNvbm5lY3RvclBpbkxlbmdodCwgcGl4ZWxQb3NpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBzdmdPYmouUG9seWxpbmVQb2ludCh0aGlzLndpZHRoLCBwaXhlbFBvc2l0aW9uKSxcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgIFwiYmxhY2tcIlxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICB0aGlzLnN2Z09iai5hZGRDaGlsZChwaW4pO1xuXG4gICAgICAgICAgICB0aGlzLmFkZE91dHB1dENvbm5lY3Rvcih3aWR0aCwgZ3JpZFBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3ZnT2JqLiRlbC5hZGRDbGFzcyhcImJveFwiKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZnVuY3Rpb24gdGhhdCB0YWtlcyBgaW5wdXRDb25uZWN0b3JzYCBbTG9naWMuc3RhdGVdKC4vbW9kdWxlLUxvZ2ljLmh0bWwjLnN0YXRlKXNcbiAgICAgICAgICogYW5kIHJldHVybnMgYG91dHB1dENvbm5lY3RvcnNgIExvZ2ljLnN0YXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXZhbEZ1bmN0aW9uID0gZXZhbEZ1bmN0aW9uO1xuXG4gICAgICAgIC8vIHJlZ2VuZXJhdGUgdGhlIGJsb2NrZWQgbm9kZXMgYWZ0ZXIgYWRkaW5nIGFsbCB0aGUgY29ubmVjdG9yc1xuICAgICAgICB0aGlzLmdlbmVyYXRlQmxvY2tOb2RlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBkYXRhIG9mIHRoaXMgYmxhY2tib3ggYXMgYSBKU09OLXJlYWR5IG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBlc3NlbnRpYWwgZGF0YSBmb3IgdGhpcyBibGFja2JveFxuICAgICAqL1xuICAgIGdldCBleHBvcnREYXRhKCkge1xuICAgICAgICBsZXQgZGF0YSA9IHN1cGVyLmV4cG9ydERhdGE7XG4gICAgICAgIGRhdGEuaW5wdXRzID0gdGhpcy5pbnB1dENvbm5lY3RvcnMubGVuZ3RoO1xuICAgICAgICBkYXRhLm91dHB1dHMgPSB0aGlzLm91dHB1dENvbm5lY3RvcnMubGVuZ3RoO1xuXG4gICAgICAgIC8vIGdlbmVyYXRlIHRoZSB0cnV0aCB0YWJsZVxuXG4gICAgICAgIGRhdGEudGFibGUgPSBbXVxuXG4gICAgICAgIC8vIGFycmF5IG9mIHRlc3RlZCBpbnB1dCBzdGF0ZXNcbiAgICAgICAgY29uc3Qgc3RhdGVMaXN0ID0gTG9naWMuc3RhdGVMaXN0O1xuXG4gICAgICAgIC8vIHJlY3Vyc2l2ZSBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyBhbGwgcG9zc2libGUgaW5wdXRzXG4gICAgICAgIGNvbnN0IGdldFBlcm11dGF0aW9ucyA9IChsZW5ndGgpID0+IHtcbiAgICAgICAgICAgIGxldCBwZXJtdXRhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0YXRlIG9mIHN0YXRlTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVybXV0YXRpb25zLnB1c2goW3N0YXRlXSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGVybXV0YXRpb25zO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3RhdGUgb2Ygc3RhdGVMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IoY29uc3QgcGVybSBvZiBnZXRQZXJtdXRhdGlvbnMobGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJtdXRhdGlvbnMucHVzaChbc3RhdGUsIC4uLnBlcm1dKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwZXJtdXRhdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZW5lcmF0ZSBvdXRwdXRzIGZvciBhbGwgdGhlIHBvc3NpYmxlIGlucHV0c1xuICAgICAgICBmb3IgKGNvbnN0IGlucHV0VmFsdWVzIG9mIGdldFBlcm11dGF0aW9ucyhkYXRhLmlucHV0cykpIHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dFZhbHVlcyA9IHRoaXMuZXZhbEZ1bmN0aW9uKC4uLmlucHV0VmFsdWVzKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gb3V0cHV0IHZhbHVlIHRoYXQgaXMgbm90IExvZ2ljLnN0YXRlLnVua25vd24sIGFkZCB0aGlzIGxpbmUgdG8gdGhlXG4gICAgICAgICAgICAvLyB0cnV0aHRhYmxlLCBvdGhlcndpc2UgZG9uJ3QgYWRkIGl0IChpZiBhbGwgb3V0cHV0IHZhbHVlcyBhcmUgTG9naWMuc3RhdGUudW5rbm93bixcbiAgICAgICAgICAgIC8vIHRoZSBpbnB1dCBjb21iaW5hdGlvbiBkb2VzIG5vdCBoYXZlIHRvIGJlIGRlZmluZXMsIGJlY2F1c2UgTG9naWMuc3RhdGUudW5rbm93biBpcyB0aGUgZGVmYXVsdCB2YWx1ZSlcbiAgICAgICAgICAgIGlmIChvdXRwdXRWYWx1ZXMucmVkdWNlKChhY2N1bXVsYXRvciwgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvciB8fCBjdXJyZW50ICE9PSBMb2dpYy5zdGF0ZS51bmtub3duXG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGRhdGEudGFibGUucHVzaChbLi4uaW5wdXRWYWx1ZXMsIC4uLm91dHB1dFZhbHVlc10pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcm9jY2VzcyB0aGUgaW5wdXQgY29ubmVjdG9yIHN0YXRlcyBhbmQgcmVmbGVjdCB0aGVtIGluIHRoZSBvdXRwdXQgY29ubmVjdG9yIHN0YXRlcyBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgbG9naWMgZGVmaW5lZCBieSB0aGlzLmV2YWxGdW5jdGlvblxuICAgICAqL1xuICAgIHJlZnJlc2hTdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgaW5wdXRTdGF0ZXMgPSB0aGlzLmlucHV0Q29ubmVjdG9ycy5tYXAoY29ubiA9PiBjb25uLnN0YXRlKTtcbiAgICAgICAgLy8gY2FsbCB0aGUgZXZhbEZ1bmN0aW9uIHRvIGdldCB0aGUgb3V0cHV0IHN0YXRlc1xuICAgICAgICBjb25zdCBvdXRwdXRTdGF0ZXMgPSB0aGlzLmV2YWxGdW5jdGlvbiguLi5pbnB1dFN0YXRlcyk7XG5cbiAgICAgICAgLy8gYXBwbHkgdGhlIG91dHB1dFN0YXRlcyB0byB0aGUgb3V0cHV0Q29ubmVjdG9yc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dFN0YXRlcy5sZW5ndGggOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0Q29ubmVjdG9yc1tpXS5zZXRTdGF0ZShvdXRwdXRTdGF0ZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2VuZXJhdGVCbG9ja05vZGVzKCkge1xuICAgICAgICAvLyBhZGQgYmxvY2tlZCBub2RlcyBvbiB0aGUgY29ubmVjdG9ycyBhbmQgYmV0d2VlbiB0aGVtIGFzIHdlbGxcblxuICAgICAgICBsZXQgc3BlY2lhbE5vZGVzID0gW11cbiAgICAgICAgZm9yIChsZXQgaSA9IDEgOyBpIDwgdGhpcy5pbnB1dENvbm5lY3RvcnMubGVuZ3RoICogMiA7ICsraSkge1xuICAgICAgICAgICAgc3BlY2lhbE5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogaVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMSA7IGkgPCB0aGlzLm91dHB1dENvbm5lY3RvcnMubGVuZ3RoICogMiA7ICsraSkge1xuICAgICAgICAgICAgc3BlY2lhbE5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IHRoaXMuZ3JpZFdpZHRoLFxuICAgICAgICAgICAgICAgIHk6IGlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5nZW5lcmF0ZUJsb2NrTm9kZXMoMCwgMSwgMCwgMSwgLi4uc3BlY2lhbE5vZGVzKTtcbiAgICB9XG59XG5cbi8qKlxuICogV2lyZSByZXByZXNlbnRzIGNvbm5lY3Rpb24gb2YgdHdvIHtAbGluayBDb25uZWN0b3J9cy5cbiAqIEBleHRlbmRzIE5ldHdvcmtFbGVtZW50XG4gKi9cbmV4cG9ydCBjbGFzcyBXaXJlIGV4dGVuZHMgTmV0d29ya0VsZW1lbnQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzfSBwYXJlbnRTVkcgIGluc3RhbmNlIG9mIFtDYW52YXNdKC4vbW9kdWxlLUNhbnZhcy5odG1sKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgZnJvbUlkICAgIGlkIG9mIHRoZSBmaXJzdCBjb25uZWN0b3IgdGhpcyB3aXJlIHdpbGwgYmUgY29ubmVjdGVkIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICB0b0lkICAgICAgaWQgb2YgdGhlIHNlY29uZCBjb25uZWN0b3IgdGhpcyB3aXJlIHdpbGwgYmUgY29ubmVjdGVkIHRvXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmVmcmVzaD10cnVlXSBpZiBgdHJ1ZWAsIHRoZSBbQ2FudmFzXSguL21vZHVsZS1DYW52YXMuaHRtbCkgd2lsbCByZWZyZXNoIGFmdGVyIGNyZWF0aW5nIHRoaXMgd2lyZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFNWRywgZnJvbUlkLCB0b0lkLCByZWZyZXNoID0gdHJ1ZSwgcm91dGUgPSB0cnVlKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudFNWRyk7XG5cbiAgICAgICAgdGhpcy5ncmlkU2l6ZSA9IHBhcmVudFNWRy5ncmlkU2l6ZTtcblxuICAgICAgICB0aGlzLmZyb21JZCA9IGZyb21JZDtcbiAgICAgICAgdGhpcy50b0lkID0gdG9JZDtcblxuICAgICAgICB0aGlzLnN0YXJ0Qm94ID0gdGhpcy5wYXJlbnRTVkcuZ2V0Qm94QnlDb25uZWN0b3JJZChmcm9tSWQpO1xuICAgICAgICB0aGlzLmVuZEJveCA9IHRoaXMucGFyZW50U1ZHLmdldEJveEJ5Q29ubmVjdG9ySWQodG9JZCk7XG5cbiAgICAgICAgdGhpcy5ib3hlcyA9IFt0aGlzLnN0YXJ0Qm94LCB0aGlzLmVuZEJveF1cblxuICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdG9yID0gdGhpcy5wYXJlbnRTVkcuZ2V0Q29ubmVjdG9yQnlJZChmcm9tSWQpO1xuICAgICAgICB0aGlzLmVuZENvbm5lY3RvciA9IHRoaXMucGFyZW50U1ZHLmdldENvbm5lY3RvckJ5SWQodG9JZCk7XG5cbiAgICAgICAgdGhpcy5jb25uZWN0b3JzID0gW3RoaXMuc3RhcnRDb25uZWN0b3IsIHRoaXMuZW5kQ29ubmVjdG9yXVxuXG4gICAgICAgIGlmKHJvdXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlV2lyZSh0cnVlLCByZWZyZXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGVtcG9yYXJ5V2lyZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbGVtZW50U3RhdGUgPSBMb2dpYy5zdGF0ZS51bmtub3duO1xuXG4gICAgICAgIGZvciAobGV0IGNvbm5lY3RvciBvZiB0aGlzLmNvbm5lY3RvcnMpIHtcbiAgICAgICAgICAgIGlmKGNvbm5lY3Rvci5pc091dHB1dENvbm5lY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoY29ubmVjdG9yLnN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3ZnT2JqLiRlbC5hZGRDbGFzcyhcIndpcmVcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGRhdGEgb2YgdGhpcyB3aXJlIGFzIGEgSlNPTi1yZWFkeSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgZXNzZW50aWFsIGRhdGEgZm9yIHRoaXMgd2lyZVxuICAgICAqL1xuICAgIGdldCBleHBvcnREYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbUlkOiB0aGlzLmZyb21JZCxcbiAgICAgICAgICAgIHRvSWQ6IHRoaXMudG9JZFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgc3RhdGUgb2YgdGhpcyB3aXJlIHRvIG1hdGNoIHRoZSBzdGF0ZSBvZiB0aGUgaW5wdXQgY29ubmVjdG9yIGl0IGlzIGNvbm5lY3RlZCB0b1xuICAgICAqIEBwYXJhbSB7TG9naWMuc3RhdGV9IHN0YXRlIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgICB0aGlzLnN2Z09iai5yZW1vdmVDbGFzc2VzKHN0YXRlQ2xhc3Nlcy5vbiwgc3RhdGVDbGFzc2VzLm9mZiwgc3RhdGVDbGFzc2VzLnVua25vd24sIHN0YXRlQ2xhc3Nlcy5vc2NpbGxhdGluZyk7XG5cbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBMb2dpYy5zdGF0ZS51bmtub3duOlxuICAgICAgICAgICAgICAgIHRoaXMuc3ZnT2JqLmFkZENsYXNzKHN0YXRlQ2xhc3Nlcy51bmtub3duKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTG9naWMuc3RhdGUub246XG4gICAgICAgICAgICAgICAgdGhpcy5zdmdPYmouYWRkQ2xhc3Moc3RhdGVDbGFzc2VzLm9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTG9naWMuc3RhdGUub2ZmOlxuICAgICAgICAgICAgICAgIHRoaXMuc3ZnT2JqLmFkZENsYXNzKHN0YXRlQ2xhc3Nlcy5vZmYpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZzpcbiAgICAgICAgICAgICAgICB0aGlzLnN2Z09iai5hZGRDbGFzcyhzdGF0ZUNsYXNzZXMub3NjaWxsYXRpbmcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhcnRDb25uZWN0b3IuaXNJbnB1dENvbm5lY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5zdGFydENvbm5lY3Rvci5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5lbmRDb25uZWN0b3IuaXNJbnB1dENvbm5lY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5lbmRDb25uZWN0b3Iuc2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbGVtZW50U3RhdGUgPSBzdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGN1cnJlbnQgW0xvZ2ljLnN0YXRlXSguL21vZHVsZXMtTG9naWMuaHRtbCMuc3RhdGUpIG9mIHRoaXMgd2lyZVxuICAgICAqIEByZXR1cm4ge0xvZ2ljLnN0YXRlfVxuICAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFN0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgc3RhdGUgb2YgdGhpcyB3aXJlXG4gICAgICovXG4gICAgdXBkYXRlV2lyZVN0YXRlKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGJveCBvZiB0aGlzLmJveGVzKSB7XG4gICAgICAgICAgICBib3gucmVmcmVzaFN0YXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgalF1ZXJ5IGVsZW1lbnQgZm9yIHRoaXMgd2lyZVxuICAgICAqIEByZXR1cm4ge2pRdWVyeS5lbGVtZW50fVxuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ZnT2JqLmdldCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgcG9seWxpbmUgcG9pbnRzIGZvciBhIHRlbXBvcmFyeSB3aXJlIHBsYWNlbWVudCBjb25uZWN0aW5nIHRoZSB0d28gY29ubmVjdG9yc1xuICAgICAqIEByZXR1cm4ge1BvbHlsaW5lUG9pbnRzfSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFBvbHlsaW5lUG9pbnRzfVxuICAgICAqL1xuICAgIGdldFRlbXBvcmFyeVdpcmVQb2ludHMoKSB7XG4gICAgICAgIGxldCBwb2ludHMgPSBuZXcgc3ZnT2JqLlBvbHlsaW5lUG9pbnRzKCk7XG4gICAgICAgIHBvaW50cy5hcHBlbmQobmV3IHN2Z09iai5Qb2x5bGluZVBvaW50KHRoaXMud2lyZVN0YXJ0LngsIHRoaXMud2lyZVN0YXJ0LnkpKTtcbiAgICAgICAgcG9pbnRzLmFwcGVuZChuZXcgc3ZnT2JqLlBvbHlsaW5lUG9pbnQodGhpcy53aXJlRW5kLngsIHRoaXMud2lyZUVuZC55KSk7XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcm91dGUgdGhlIHdpcmUgdXNpbmcgdGhlIHRlbXBvcmFyeSB3aXJlIHBvaW50c1xuICAgICAqL1xuICAgIHRlbXBvcmFyeVdpcmUoKSB7XG4gICAgICAgIHRoaXMud2lyZVN0YXJ0ID0gdGhpcy5wYXJlbnRTVkcuZ2V0Q29ubmVjdG9yUG9zaXRpb24odGhpcy5zdGFydENvbm5lY3RvciwgZmFsc2UpO1xuICAgICAgICB0aGlzLndpcmVFbmQgPSB0aGlzLnBhcmVudFNWRy5nZXRDb25uZWN0b3JQb3NpdGlvbih0aGlzLmVuZENvbm5lY3RvciwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuc2V0V2lyZVBhdGgodGhpcy5nZXRUZW1wb3JhcnlXaXJlUG9pbnRzKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJvdXRlIHRoZSB3aXJlIHVzaW5nIHRoZSBtb2RpZmllZCBBKiB3aXJlIHJvdXRpbmcgYWxnb3JpdGhtXG4gICAgICovXG4gICAgcm91dGVXaXJlKHNuYXBUb0dyaWQgPSB0cnVlLCByZWZyZXNoID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLndpcmVTdGFydCA9IHRoaXMucGFyZW50U1ZHLmdldENvbm5lY3RvclBvc2l0aW9uKHRoaXMuc3RhcnRDb25uZWN0b3IsIHNuYXBUb0dyaWQpO1xuICAgICAgICB0aGlzLndpcmVFbmQgPSB0aGlzLnBhcmVudFNWRy5nZXRDb25uZWN0b3JQb3NpdGlvbih0aGlzLmVuZENvbm5lY3Rvciwgc25hcFRvR3JpZCk7XG5cbiAgICAgICAgdGhpcy5wb2ludHMgPSB0aGlzLmZpbmRSb3V0ZShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLndpcmVTdGFydC54IC8gdGhpcy5ncmlkU2l6ZSxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLndpcmVTdGFydC55IC8gdGhpcy5ncmlkU2l6ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLndpcmVFbmQueCAvIHRoaXMuZ3JpZFNpemUsXG4gICAgICAgICAgICAgICAgeTogdGhpcy53aXJlRW5kLnkgLyB0aGlzLmdyaWRTaXplXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNldFdpcmVQYXRoKHRoaXMucG9pbnRzKTtcblxuICAgICAgICBpZiAocmVmcmVzaClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlV2lyZVN0YXRlKCk7XG5cbiAgICAgICAgLy8gcmVnZW5lcmF0ZSBpbmNvbnZlbmllbnQgbm9kZXNcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUluY29udmVuaWVudE5vZGVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHRoZSB3aXJlIHRvIGZvbGxvdyB0aGUgc3BlY2lmaWVkIHBvaW50c1xuICAgICAqIEBwYXJhbSB7UG9seWxpbmVQb2ludHN9IHBvaW50cyBpbnN0YW5jZSBvZiB7QGxpbmsgUG9seWxpbmVQb2ludHN9XG4gICAgICovXG4gICAgc2V0V2lyZVBhdGgocG9pbnRzKSB7XG4gICAgICAgIC8vIHNldCB0aGUgbGluZVxuICAgICAgICBpZih0aGlzLnN2Z09iaiE9PXVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gdGhpcy5zdmdPYmoudXBkYXRlUG9pbnRzKHBvaW50cyk7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLnN2Z09iai5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGNoaWxkLnVwZGF0ZVBvaW50cyhwb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdmdPYmogPSBuZXcgc3ZnT2JqLkdyb3VwKCk7XG5cbiAgICAgICAgICAgIGxldCBoaXRib3ggPSBuZXcgc3ZnT2JqLlBvbHlMaW5lKHBvaW50cywgMTAsICd3aGl0ZScpO1xuICAgICAgICAgICAgaGl0Ym94LmFkZENsYXNzKFwiaGl0Ym94XCIpO1xuICAgICAgICAgICAgaGl0Ym94LmFkZEF0dHIoe29wYWNpdHk6IDB9KTtcbiAgICAgICAgICAgIHRoaXMuc3ZnT2JqLmFkZENoaWxkKGhpdGJveCk7XG5cbiAgICAgICAgICAgIGxldCBtYWluTGluZSA9IG5ldyBzdmdPYmouUG9seUxpbmUocG9pbnRzLCAyKTtcbiAgICAgICAgICAgIG1haW5MaW5lLmFkZENsYXNzKFwibWFpblwiLCBcInN0YXRlVW5rbm93blwiKTtcbiAgICAgICAgICAgIHRoaXMuc3ZnT2JqLmFkZENoaWxkKG1haW5MaW5lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhdGhUb1BvbHlsaW5lKHBhdGgpIHtcbiAgICAgICAgbGV0IHRvdGFsUGF0aCA9IG5ldyBzdmdPYmouUG9seWxpbmVQb2ludHMoKTtcbiAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBwYXRoKSB7XG4gICAgICAgICAgICB0b3RhbFBhdGguYXBwZW5kKG5ldyBzdmdPYmouUG9seWxpbmVQb2ludChwb2ludC54ICogdGhpcy5ncmlkU2l6ZSwgcG9pbnQueSAqIHRoaXMuZ3JpZFNpemUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxQYXRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZpbmQgYSBuaWNlIHJvdXRlIGZvciB0aGUgd2lyZVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc3RhcnQgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgIHRoYXQgcmVwcmVzZW50IHRoZSBmaXJzdCBlbmRwb2ludCBvZiB0aGUgd2lyZSBpbiBncmlkIHBpeGVsXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBlbmQgICBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWAgdGhhdCByZXByZXNlbnQgdGhlIHNlY29uZCBlbmRwb2ludCBvZiB0aGUgd2lyZSBpbiBncmlkIHBpeGVsc1xuICAgICAqIEByZXR1cm4ge1BvbHlsaW5lUG9pbnRzfSAgICAgICBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgZmluZFJvdXRlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgbGV0IG5vblJvdXRhYmxlID0gdGhpcy5wYXJlbnRTVkcuZ2V0Tm9uUm91dGFibGVOb2RlcygpO1xuXG4gICAgICAgIGxldCBwdW5pc2hlZEJ1dFJvdXRhYmxlO1xuICAgICAgICBpZih0aGlzLnN2Z09iaj09PXVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHVuaXNoZWRCdXRSb3V0YWJsZSA9IHRoaXMucGFyZW50U1ZHLmdldEluY29udmVuaWVudE5vZGVzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwdW5pc2hlZEJ1dFJvdXRhYmxlID0gdGhpcy5wYXJlbnRTVkcuZ2V0SW5jb252ZW5pZW50Tm9kZXModGhpcy5zdmdPYmouaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBhdGggPSBmaW5kUGF0aChzdGFydCwgZW5kLCBub25Sb3V0YWJsZSwgcHVuaXNoZWRCdXRSb3V0YWJsZSwgdGhpcy5ncmlkU2l6ZSk7XG5cbiAgICAgICAgaWYocGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aFRvUG9seWxpbmUocGF0aCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIGlmIGEgcGF0aCB3YXMgbm90IGZvdW5kLCB0cnkgYWdhaW4gYnV0IGRvbid0IHRha2UgaW50byBhY2NvdW50IHRoZSBwdW5pc2hlZCBhbmQgbm9uIHJvdXRhYmxlIG5vZGVcbiAgICAgICAgcGF0aCA9IGZpbmRQYXRoKHN0YXJ0LCBlbmQsIG5ldyBTZXQoKSwgbmV3IFNldCgpLCB0aGlzLmdyaWRTaXplKTtcblxuICAgICAgICBpZihwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXRoVG9Qb2x5bGluZShwYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBwYXRoIHdhcyBzdGlsbCBub3QgZm91bmQsIGdpdmUgdXAgYW5kIHJldHVybiB0ZW1wb3JhcnkgcG9pbnRzXG4gICAgICAgIHJldHVybiB0aGlzLmdldFRlbXBvcmFyeVdpcmVQb2ludHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSBhIHNldCBvZiBub2RlcywgdGhhdCBhcmUgaW5jb252ZW5pZW50IGZvciB3aXJpbmcsIGJ1dCBjYW4gYmUgdXNlZCwganVzdCBhcmUgbm90IHByZWZlcnJlZFxuICAgICAqIEByZXR1cm4ge1NldH0gc2V0IG9mIG5vZGVzIChvYmplY3RzIGNvbnRhaW5pbmcgeCBhbmQgeSBjb29yZGluYXRlcykgdGhhdCBhcmUgbm90IHByZWZlcnJlZCBmb3Igd2lyaW5nXG4gICAgICovXG4gICAgZ2VuZXJhdGVJbmNvbnZlbmllbnROb2RlcygpIHtcbiAgICAgICAgdGhpcy5pbmNvbnZlbmllbnROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgICBsZXQgcHJldlBvaW50O1xuXG4gICAgICAgIHRoaXMucG9pbnRzLmZvckVhY2gocG9pbnQgPT4ge1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICB4ID0gdGhpcy5wYXJlbnRTVkcuU1ZHVG9HcmlkKHBvaW50LngpLFxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLnBhcmVudFNWRy5TVkdUb0dyaWQocG9pbnQueSk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2UG9pbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwcmV2UG9pbnQgaXMgdW5kZWZpbmVkLCBhZGQgdGhlIGZpcnN0IHBvaW50XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNvbnZlbmllbnROb2Rlcy5hZGQoe3gsIHl9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZWxzZSBhZGQgYWxsIHRoZSBwb2ludCBiZXR3ZWVuIHRoZSBwcmV2UG9pbnQgKGV4Y2x1ZGVkKSBhbmQgcG9pbnQgKGluY2x1ZGVkKVxuXG4gICAgICAgICAgICAgICAgaWYocHJldlBvaW50LnggPT09IHgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxpbmUgaXMgaG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKHByZXZQb2ludC55LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvID0gTWF0aC5tYXgocHJldlBvaW50LnksIHkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGZyb20gPD0gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5jb252ZW5pZW50Tm9kZXMuYWRkKHt4OiB4LCB5OiBmcm9tfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJldlBvaW50LnkgPT09IHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxpbmUgaXMgdmVydGljYWxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1pbihwcmV2UG9pbnQueCwgeCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0byA9IE1hdGgubWF4KHByZXZQb2ludC54LCB4KTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZShmcm9tIDw9IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluY29udmVuaWVudE5vZGVzLmFkZCh7eDogZnJvbSwgeTogeX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGluZSBpcyBuZWl0aGVyIGhvcml6b250YWwgbm9yIHZlcnRpY2FsLCB0aHJvdyBhbiBlcnJvciBmb3IgYmV0dGVyIGZ1dHVyZSBkZWJ1Z2dpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcihcImdldEluY29udmVuaWVudE5vZGVzOiBsaW5lIGJldHdlZW4gdHdvIHBvaW50cyBpcyBuZWl0aGVyIGhvcml6b250YWwgbm9yIHZlcnRpY2FsXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0IG5ldyBwcmV2UG9pbnRcbiAgICAgICAgICAgIHByZXZQb2ludCA9IHt4LCB5fTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHttYW5oYXR0YW5EaXN0YW5jZX0gZnJvbSAnLi9oZWxwZXJGdW5jdGlvbnMnXG5pbXBvcnQgTWFwV2l0aERlZmF1bHRWYWx1ZSBmcm9tICcuL21hcFdpdGhEZWZhdWx0VmFsdWUnXG5cbmltcG9ydCB7IFByaW9yaXR5UXVldWUgfSBmcm9tICdsaWJzdGwnOyAvLyBub3RlOiBpbXBvcnRlZCBmcm9tIGEgbm9kZSBtb2R1bGVcblxuLyoqXG4gKiByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIHNldCBvZiBwb2ludHMgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludCAoYW5kIHJldHVybnMgYGZhbHNlYCBvdGhlcndpc2UpXG4gKiBAcGFyYW0ge1NldH0gc2V0IHNldCBvZiBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqL1xuZnVuY3Rpb24gc2V0SGFzVGhpc1BvaW50KHNldCwgcG9pbnQpIHtcbiAgICBmb3IgKGxldCBpdGVtIG9mIHNldCkge1xuICAgICAgICBpZiAoaXRlbS54ID09PSBwb2ludC54ICYmIGl0ZW0ueSA9PT0gcG9pbnQueSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IG1vdmVzIHRoZSBwYXNzZWQgcG9pbnQgaW4gdGhlIHNwZWNpZmllZCBkaXJlY3Rpb24uIEl0IHNpbXBseSBhZGRzIG9yIHN1YnRyYWN0cyAxIGZyb20gb25lIG9mIHRoZSBjb29yZGluYXRlcyBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBvaW50ICAgICBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqIEBwYXJhbSAge251bWJlcn0gZGlyZWN0aW9uIGRpcmVjdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gMDogdXBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSAxOiByaWdodFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIDI6IGRvd25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSAzOiBsZWZ0XG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqL1xuZnVuY3Rpb24gbW92ZVBvaW50KHBvaW50LCBkaXJlY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICBjYXNlIDA6IC8vIHVwXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHBvaW50LngsXG4gICAgICAgICAgICAgICAgeTogcG9pbnQueSAtIDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMTogLy8gcmlnaHRcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogcG9pbnQueCArIDEsXG4gICAgICAgICAgICAgICAgeTogcG9pbnQueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAyOiAvLyBkb3duXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHBvaW50LngsXG4gICAgICAgICAgICAgICAgeTogcG9pbnQueSArIDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMzogLy8gbGVmdFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBwb2ludC54IC0gMSxcbiAgICAgICAgICAgICAgICB5OiBwb2ludC55XG4gICAgICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBoZWxwZXIgYmFja3RyYWNraW5nIGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGFTdGFyIGFsZ29yaXRobSB0byBjb25zdHJ1Y3QgdGhlIGZpbmFsIHBhdGhcbiAqIEBwYXJhbSAge09iamVjdH0gY2FtZUZyb20gICAgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgXG4gKiBAcGFyYW0gIHtPYmplY3R9IGN1cnJlbnROb2RlIG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICogQHJldHVybiB7VE9ET31cbiAqL1xuZnVuY3Rpb24gcmVjb25zdHJ1Y3RQYXRoKGNhbWVGcm9tLCBjdXJyZW50Tm9kZSkge1xuICAgIGxldCBwYXRoID0gW107XG5cbiAgICBwYXRoLnB1c2goe1xuICAgICAgICB4OiBjdXJyZW50Tm9kZS54LFxuICAgICAgICB5OiBjdXJyZW50Tm9kZS55XG4gICAgfSlcblxuICAgIHdoaWxlIChjYW1lRnJvbS5oYXMoY3VycmVudE5vZGUpKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gY2FtZUZyb20uZ2V0KGN1cnJlbnROb2RlKTtcbiAgICAgICAgcGF0aC5wdXNoKHtcbiAgICAgICAgICAgIHg6IGN1cnJlbnROb2RlLngsXG4gICAgICAgICAgICB5OiBjdXJyZW50Tm9kZS55XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGg7XG59XG5cbi8qKlxuICogSGVhdmlseSBtb2RpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQSogYWxnb3JpdGhtXG4gKiBAcGFyYW0gIHtPYmplY3R9IHN0YXJ0IG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YCB0aGF0IHJlcHJlc2VudCB0aGUgZmlyc3QgZW5kcG9pbnQgb2YgdGhlIHdpcmUgaW4gZ3JpZCBwaXhlbHNcbiAqIEBwYXJhbSAge09iamVjdH0gZW5kICAgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgIHRoYXQgcmVwcmVzZW50IHRoZSBzZWNvbmQgZW5kcG9pbnQgb2YgdGhlIHdpcmUgaW4gZ3JpZCBwaXhlbHNcbiAqIEBwYXJhbSAge1NldH0gbm9uUm91dGFibGUgc2V0IG9mIG5vbiByb3V0YWJsZSBub2Rlc1xuICogQHBhcmFtICB7U2V0fSBwdW5pc2hlZEJ1dFJvdXRhYmxlIHNldCBvZiBub2RlcyB0aGF0IGFyZSBub3Qgb3B0aW1hbCBmb3Igcm91dGluZ1xuICogQHJldHVybiB7VE9ET31cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmluZFBhdGgoc3RhcnQsIGVuZCwgbm9uUm91dGFibGUsIHB1bmlzaGVkQnV0Um91dGFibGUpIHtcblxuICAgIGNvbnN0IGRpc3RhbmNlRnVuY3Rpb24gPSBtYW5oYXR0YW5EaXN0YW5jZTtcblxuICAgIGNvbnN0IHdpcmVDcm9zc1B1bmlzaG1lbnQgPSAxO1xuICAgIGNvbnN0IHdpcmVCZW5kUHVuaXNobWVudCA9IDE7XG5cbiAgICAvLyBudW1iZXIgb2Ygbm9kZXMsIHRoYXQgY2FuIGJlIG9wZW5lZCBhdCBvbmNlXG4gICAgLy8gb25jZSBpcyB0aGlzIGxpbWl0IGV4Y2VlZGVkLCBhU3RhciB3aWxsIGZhaWwgYW5kIHJldHVybiB1bmRlZmluZWRcbiAgICBjb25zdCBtYXhOb2RlTGltaXQgPSAxMDAwMDA7XG5cbiAgICBsZXQgY2xvc2VkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IG9wZW5Ob2RlcyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgb3Blbk5vZGVRdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XG5cbiAgICAvLyBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBvcGVuIG5vZGVzOlxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgbmV3IG9wZW4gbm9kZSB0byB0aGUgc3RydWN0dXJlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgICBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWAgdGhhdCByZXByZXNlbnQgdGhlIGZpcnN0IGVuZHBvaW50IG9mIHRoZSB3aXJlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZzY29yZSBmU2NvcmUgb2YgdGhpcyBub2RlXG4gICAgICovXG4gICAgY29uc3QgYWRkT3Blbk5vZGUgPSAobm9kZSwgZnNjb3JlKSA9PiB7XG4gICAgICAgIG9wZW5Ob2Rlcy5hZGQobm9kZSk7XG4gICAgICAgIC8vIGZsaXAgdGhlIGZzY29yZSwgYmVjYXVzZSBQcmlvcml0eVF1ZXVlIHVzZXMgbWF4IGhlYXBcbiAgICAgICAgb3Blbk5vZGVRdWV1ZS5lbnF1ZXVlKG5vZGUsIDEgLyBmc2NvcmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgb3BlbiBub2RlIHdpdGggdGhlIGxvd2VzdCBmU2NvcmUgYW5kIHJlbW92ZSBpdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgIHRoYXQgcmVwcmVzZW50IHRoZSBmaXJzdCBlbmRwb2ludCBvZiB0aGUgd2lyZVxuICAgICAqL1xuICAgIGNvbnN0IGdldE9wZW5Ob2RlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gb3Blbk5vZGVRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgIG9wZW5Ob2Rlcy5kZWxldGUobm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGxldCBjYW1lRnJvbSA9IG5ldyBNYXAoKTtcblxuICAgIC8vIGRlZmF1bHQgdmFsdWU6IGluZmluaXR5XG4gICAgbGV0IGdTY29yZSA9IG5ldyBNYXBXaXRoRGVmYXVsdFZhbHVlKEluZmluaXR5KTtcbiAgICBnU2NvcmUuc2V0KHN0YXJ0LCAwKTtcblxuICAgIGxldCBzdGFydEZTY29yZSA9IGRpc3RhbmNlRnVuY3Rpb24oc3RhcnQsIGVuZCk7XG5cbiAgICBhZGRPcGVuTm9kZShzdGFydCwgc3RhcnRGU2NvcmUpO1xuXG4gICAgb3Blbk5vZGVzLmFkZChzdGFydCk7XG4gICAgb3Blbk5vZGVRdWV1ZS5lbnF1ZXVlKHN0YXJ0LCAxIC8gc3RhcnRGU2NvcmUpO1xuXG4gICAgd2hpbGUgKG9wZW5Ob2Rlcy5zaXplID4gMCkge1xuICAgICAgICAvLyBnZXQgdGhlIHZhbHVlIGZyb20gb3Blbk5vZGVzIHRoYXQgaGFzIHRoZSBsb3dlc3QgZlNjb3JlXG4gICAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gZ2V0T3Blbk5vZGUoKTtcblxuICAgICAgICAvLyBpZiB3ZSByZWFjaGVkIHRoZSBlbmQgcG9pbnQsIHJlY29uc3RydWN0IHRoZSBwYXRoIGFuZCByZXR1cm4gaXRcbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLnggPT0gZW5kLnggJiYgY3VycmVudE5vZGUueSA9PSBlbmQueSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlY29uc3RydWN0UGF0aChjYW1lRnJvbSwgY3VycmVudE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoaXMgbm9kZSB0byB0aGUgY2xvc2VkIG5vZGVzXG4gICAgICAgIGNsb3NlZE5vZGVzLmFkZChjdXJyZW50Tm9kZSk7XG5cbiAgICAgICAgLy8gdGhlIGZhcnRoZXN0IHBvaW50cyBhY2Nlc3NpYmxlIHdpdGhvdXQgYXZvaWRpbmcgb2JzdGFjbGVzIGluIGV2ZXJ5IGRpcmVjdGlvblxuICAgICAgICAvLyAoYnV0IG1heCA1MCBpbiBlYWNoIGRpcmVjdGlvbilcbiAgICAgICAgZm9yIChsZXQgZGlyZWN0aW9uID0gMDsgZGlyZWN0aW9uIDwgNDsgZGlyZWN0aW9uKyspIHtcbiAgICAgICAgICAgIGxldCBuZXdQb2ludCA9IG1vdmVQb2ludChjdXJyZW50Tm9kZSwgZGlyZWN0aW9uKTtcblxuICAgICAgICAgICAgbGV0IHdpcmVzQ3Jvc3NlZCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTA7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5ld1BvaW50IGlzIGluIHRoZSBzZXQgb2Ygbm9uIHJvdXRhYmxlIHBvaW50cyxcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBhZGQgaXQgYW5kIHN0b3AgcHJvY2VlZGluZyBpbiB0aGlzIGRpcmVjdGlvblxuICAgICAgICAgICAgICAgIGlmIChzZXRIYXNUaGlzUG9pbnQobm9uUm91dGFibGUsIG5ld1BvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIG5vdCB0aGUgZW5kIHBvaW50LCBicmVha1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3UG9pbnQueCAhPT0gZW5kLnggfHwgbmV3UG9pbnQueSAhPT0gZW5kLnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2tpcCB0aGlzIG5vZGUsIGlmIGl0IGhhcyBiZWVuIGFscmVhZHkgY2xvc2VkXG4gICAgICAgICAgICAgICAgLy8gb3IgaWYgaXQgaXMgb24gdGhlIGxpc3Qgb2Ygbm9uIHJvdXRhYmxlIG5vZGVzXG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlZE5vZGVzLmhhcyhuZXdQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHBvc3NpYmxlIEdTY29yZSBieSBhcHBseWluZyBhIHB1bmlzaG1lbnQgZm9yIGVhY2ggbm9kZSAoXCJiZW5kXCIpIGluIHRoZSBwYXRoXG4gICAgICAgICAgICAgICAgbGV0IG5ld0dTY29yZSA9IHdpcmVCZW5kUHVuaXNobWVudCArIGdTY29yZS5nZXRXaXRoRGVmYXVsdChjdXJyZW50Tm9kZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0SGFzVGhpc1BvaW50KHB1bmlzaGVkQnV0Um91dGFibGUsIG5ld1BvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbm9kZSBpcyBpbiB0aGUgc2V0IG9mIHB1bmlzaGVkIG5vZGVzLCBhcHBseSB0aGUgcHVuaXNobWVudFxuICAgICAgICAgICAgICAgICAgICB3aXJlc0Nyb3NzZWQrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhcHBseSB0aGUgcHVuaXNobWVudCBmb3IgZWFjaCB3aXJlIGNyb3NzZWQgaW4gdGhpcyBkaXJlY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBub3RlOiB3ZSBhcmUgY291bnRpbmcgdGhlIHdpcmVzIGNyb3NzZWQgd2hlbiBleHBvcnRpbmcgdGhpcyBkaXJlY3Rpb24sIG5vdCB0aGUgd2lyZXNcbiAgICAgICAgICAgICAgICAvLyBjcm9zc2VkIGluIHRoZSBmaW5hbCBwYXRoLCB0aGVyZSB3aWxsIGJlIHByb2JhYmx5IG9ubHkgYXQgbW9zdCBvZiB0aGVzZSBub2RlcyBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBmaW5hbCBwYXRoLCBub3QgbXVsdGlwbGVcbiAgICAgICAgICAgICAgICBuZXdHU2NvcmUgKz0gd2lyZXNDcm9zc2VkICogd2lyZUNyb3NzUHVuaXNobWVudDtcblxuICAgICAgICAgICAgICAgIC8vIHNraXAgdGhpcyBub2RlIGlmIGl0IGhhcyB3b3JzdCBlc3RpbWFnZSBnc2NvcmUgdGhhbiBpbiB0aGUgZ3Njb3JlIHRhYmxlXG4gICAgICAgICAgICAgICAgaWYgKG5ld0dTY29yZSA+PSBnU2NvcmUuZ2V0V2l0aERlZmF1bHQobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhbWVGcm9tLnNldChuZXdQb2ludCwgY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgICAgIGdTY29yZS5zZXQobmV3UG9pbnQsIG5ld0dTY29yZSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdGU2NvcmUgPSBuZXdHU2NvcmUgKyBkaXN0YW5jZUZ1bmN0aW9uKG5ld1BvaW50LCBlbmQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFvcGVuTm9kZXMuaGFzKG5ld1BvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHBvaW50IHRvIHRoZSBsaXN0IG9mIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICBhZGRPcGVuTm9kZShuZXdQb2ludCwgbmV3RlNjb3JlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRvIHRoZSBuZXh0IHBvaW50IGluIHRoZSBkaXJlY2l0b25cbiAgICAgICAgICAgICAgICBuZXdQb2ludCA9IG1vdmVQb2ludChuZXdQb2ludCwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcGVuTm9kZXMuc2l6ZSA+IG1heE5vZGVMaW1pdCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYGFTdGFyOiBOdW1iZXIgb2Ygb3BlbiBub2RlcyAoJHtvcGVuTm9kZXMuc2l6ZX0pIGV4Y2VlZGVkIHRoZSBsaW1pdCBmb3Igb3BlbiBub2RlcyAoJHttYXhOb2RlTGltaXR9KS5gKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgd2UgZ290IGhlcmUsIHRoZSBwYXRoIHdhcyBub3QgZm91bmRcblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4iLCJpbXBvcnQgeyBnZXRKU09OU3RyaW5nIH0gZnJvbSBcIi4vaGVscGVyRnVuY3Rpb25zXCI7XG5cbi8qKlxuICogRmxvYXRpbmdCdXR0b24gcmVwcmVzZW50cyBhIGJ1dHRvbiB0aGF0IGlzIHVzZWQgaW4gdGhlIGZsb2F0aW5nIG1lbnUgaW4gdGhlIHJpZ2h0IGJvdHRvbSBjb3JuZXJcbiAqIG9mIHRoZSBhcHBsaWNhdGlvbi4gSXQgbWF5IGhhdmUgYSBjdXN0b20gdG9vbHRpcCBhbmQgY2FsbGJhY2sgb24gdGhlIGNsaWNrIGV2ZW50XG4gKi9cbmNsYXNzIEZsb2F0aW5nQnV0dG9uIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnV0dG9uQ2xhc3MgQ3VzdG9tIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhlIFNWRyBpY29uIHVzZWQgb24gdGhpcyBidXR0b24uIFRoaXMgc3RyaW5nIGlzIGFsc28gYWRkZWQgYXMgYSBDU1MgY2xhc3MgdG8gdGhlIGJ1dHRvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9vbHRpcCAgICAgdG9vbHRpcCBmb3IgdGhlIGJ1dHRvbiwgdGhhdCB3aWxsIGJlIGRpc3BsYXllZCBvbiBob3ZlciBhbmQgYWxzbyB1c2VkIGFzIGFsdGVybmF0aXZlIHRpdGxlIGZvciB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbGlja0V2ZW50ICBjdXN0b20gY2FsbGJhY2sgd2hlbiB1c2VyIGNsaWNrcyB0aGUgYnV0dG9uXG4gICAgICogQHBhcmFtIHtDYW52YXN9IHBhcmVudFNWRyAgIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IFNWRyBlbGVtZW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYnV0dG9uQ2xhc3MsIHRvb2x0aXAsIGNsaWNrRXZlbnQsIHBhcmVudFNWRykge1xuICAgICAgICAvKipcbiAgICAgICAgICogalF1ZXJ5IGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBidXR0b25cbiAgICAgICAgICogQHR5cGUge2pRdWVyeS5lbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kZWwgPSAkKCc8YT4nKVxuXG4gICAgICAgIC8vIGFkZCBjbGFzc2VzIHRvIHRoZSBlbGVtZW50XG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKFwiYnV0dG9uXCIpO1xuICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcyhidXR0b25DbGFzcyk7XG5cbiAgICAgICAgLy8gYWRkIHRoZSBpY29uXG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZChcbiAgICAgICAgICAgICQoXCI8aW1nPlwiKVxuICAgICAgICAgICAgLmF0dHIoXCJzcmNcIiwgYGltZy9ndWkvJHtidXR0b25DbGFzc30uc3ZnYClcbiAgICAgICAgICAgIC5hdHRyKFwiYWx0XCIsIHRvb2x0aXApXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gYWRkIHRoZSB0b29sdGlwIGVsZW1lbnQgYW5kIGFuIGV2ZW50IGxpc3RlbmVyIGlmIHRvb2x0aXAgaXMgZGVmaW5lZFxuICAgICAgICBpZiAodG9vbHRpcCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBqUXVlcnkgZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIHRvb2x0aXBcbiAgICAgICAgICAgICAqIEB0eXBlIHtqUXVlcnkuZWxlbWVudH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy4kdG9vbHRpcCA9ICQoXCI8ZGl2PlwiKTtcbiAgICAgICAgICAgIHRoaXMuJHRvb2x0aXBcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJ0b29sdGlwXCIpXG4gICAgICAgICAgICAgICAgLmh0bWwodG9vbHRpcCk7XG5cbiAgICAgICAgICAgIHBhcmVudFNWRy4kc3ZnLmFmdGVyKHRoaXMuJHRvb2x0aXApO1xuXG4gICAgICAgICAgICB0aGlzLiRlbC5ob3ZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdG9vbHRpcC5mYWRlSW4oMjAwKTtcbiAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiR0b29sdGlwLmZhZGVPdXQoMjAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIG9uIGNsaWNrLCBpZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgZGVmaW5lZFxuICAgICAgICBpZiAoY2xpY2tFdmVudCkge1xuICAgICAgICAgICAgdGhpcy4kZWwub24oXCJjbGlja1wiLCBjbGlja0V2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqIEBtb2R1bGUgRmxvYXRpbmdNZW51ICovXG4vKipcbiAqIENsYXNzIHRvIHJlcHJlc2VudCB0aGUgZmxvYXRpbmcgbWVudSBpbiB0aGUgcmlnaHQgYm90dG9tIGNvcm5lciBvZiB0aGUgcGFnZS5cbiAqIEl0IGluc3RhbnRpYXRlcyBhbGwgdGhlIGJ1dHRvbnMgYW5kIHRoZWlyIGNhbGxiYWNrcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmxvYXRpbmdNZW51IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gcGFyZW50U1ZHIHJlZmVyZW5jZSB0byB0aGUgQ2FudmFzIGVsZW1lbnQgdGhpcyBtZW51IGlzIGFzc29jaWF0ZWQgd2l0aFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFNWRykge1xuICAgICAgICAvKipcbiAgICAgICAgICogdGhlIGpRdWVyeSBlbGVtZW50IGNvbnRhaW5pbmcgYWxsIGJ1dHRvbnNcbiAgICAgICAgICogQHR5cGUge2pRdWVyeS5lbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kZWwgPSAkKCc8ZGl2PicpXG5cbiAgICAgICAgY29uc3QgaWQgPSAnZmxvYXRpbmdNZW51JztcblxuICAgICAgICB0aGlzLiRlbC5hdHRyKFwiaWRcIiwgaWQpO1xuXG4gICAgICAgIC8vIGNvbnN0ICRsb2FkZXIgPSAkKFwiPGRpdj5cIikuYWRkQ2xhc3MoXCJsb2FkZXJcIikuYWRkQ2xhc3MoXCJoaWRkZW5cIik7XG5cblxuICAgICAgICAvKiBFWFBPUlQgKi9cbiAgICAgICAgdGhpcy5hcHBlbmQoXG4gICAgICAgICAgICBuZXcgRmxvYXRpbmdCdXR0b24oXCJleHBvcnRcIiwgXCJHZXQgY29kZSBmb3IgdGhpcyBuZXR3b3JrXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHBvcHVwIGNvbnRhaW5lciBob2xkaW5nIGFsbCBwb3B1cCBjb250ZW50ICh0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIGxpdHkpXG4gICAgICAgICAgICAgICAgbGV0ICRwb3B1cCA9ICQoXCI8ZGl2PlwiKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJpbXBvcnRFeHBvcnRcIilcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiZXhwb3J0XCIpO1xuXG4gICAgICAgICAgICAgICAgLy8gZ2VuZXJhdGUgdGhlIGJsb2NrIHdpdGggY29kZSB0byBiZSBkaXNwbGF5ZWQgYW5kIGFwcGVuZCBpdCB0byB0aGUgcG9wdXAgZWxlbWVudFxuICAgICAgICAgICAgICAgIGNvbnN0ICR0ZXh0YmxvY2sgPSAkKFwiPHRleHRhcmVhPlwiKS50ZXh0KFxuICAgICAgICAgICAgICAgICAgICBnZXRKU09OU3RyaW5nKHBhcmVudFNWRy5leHBvcnREYXRhLCB0cnVlKVxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgICRwb3B1cC5hcHBlbmQoJHRleHRibG9jayk7XG5cbiAgICAgICAgICAgICAgICAvLyBnZW5lcmF0ZSB0aGUgbGlua3NcbiAgICAgICAgICAgICAgICAkcG9wdXAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAkKFwiPGE+XCIpLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJocmVmXCI6IGdldEpTT05TdHJpbmcocGFyZW50U1ZHLmV4cG9ydERhdGEsIHRydWUsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiOiBcImRvd25sb2FkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRvd25sb2FkXCI6IFwibmV0d29yay5qc29uXCJcbiAgICAgICAgICAgICAgICAgICAgfSkuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgJChcIjxpbWc+XCIpLmF0dHIoJ3NyYycsIFwiaW1nL2d1aS9leHBvcnQuc3ZnXCIpXG4gICAgICAgICAgICAgICAgICAgICkuYXBwZW5kKFwiIGV4cGFuZGVkIEpTT05cIilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICRwb3B1cC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICQoXCI8YT5cIikuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImhyZWZcIjogZ2V0SlNPTlN0cmluZyhwYXJlbnRTVkcuZXhwb3J0RGF0YSwgZmFsc2UsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiOiBcImRvd25sb2FkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRvd25sb2FkXCI6IFwibmV0d29yay5taW4uanNvblwiXG4gICAgICAgICAgICAgICAgICAgIH0pLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXCI8aW1nPlwiKS5hdHRyKCdzcmMnLCBcImltZy9ndWkvZXhwb3J0LnN2Z1wiKVxuICAgICAgICAgICAgICAgICAgICApLmFwcGVuZChcIiBjb21wYWN0IEpTT05cIilcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgbGl0eSgkcG9wdXApO1xuXG4gICAgICAgICAgICAgICAgLy8gaGlnaGxpZ2h0IHRoZSB0ZXh0IGluIHRoZSB0ZXh0YmxvY2tcbiAgICAgICAgICAgICAgICAkdGV4dGJsb2NrLnNlbGVjdCgpO1xuICAgICAgICAgICAgfSwgcGFyZW50U1ZHKVxuICAgICAgICApO1xuXG4gICAgICAgIC8qIFR1dG9yaWFsICovXG4gICAgICAgIHRoaXMuYXBwZW5kKFxuICAgICAgICAgICAgbmV3IEZsb2F0aW5nQnV0dG9uKFwidHV0b3JpYWxcIiwgXCJTdGFydCB0aGUgdHV0b3JpYWxcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHBhcmVudFNWRy5zdGFydFR1dG9yaWFsKCk7XG4gICAgICAgICAgICB9LCBwYXJlbnRTVkcpXG4gICAgICAgICk7XG5cbiAgICAgICAgcGFyZW50U1ZHLiRzdmcuYWZ0ZXIodGhpcy4kZWwpO1xuXG4gICAgICAgIC8qIEhFTFAgKi9cblxuICAgICAgICBsZXQgaGVscCA9IG5ldyBGbG9hdGluZ0J1dHRvbihcImhlbHBcIiwgXCJEaXNwbGF5IGEgaGVscCBwYWdlXCIsIGZhbHNlLCBwYXJlbnRTVkcpO1xuICAgICAgICBoZWxwLiRlbC5hdHRyKHtcbiAgICAgICAgICAgICdocmVmJzogJy4vZG9jcy91c2VyLmh0bWwnLFxuICAgICAgICAgICAgJ2RhdGEtbGl0eSc6ICcnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFwcGVuZChoZWxwKTtcblxuICAgICAgICBwYXJlbnRTVkcuJHN2Zy5hZnRlcih0aGlzLiRlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYXBwZW5kIGEgRmxvYXRpbmdCdXR0b24gdG8gdGhpcyBtZW51XG4gICAgICogQHBhcmFtICB7RmxvYXRpbmdCdXR0b259IG1lbnVJdGVtIGFwcGVuZCBhbiBpbnN0YW5jZSBvZiAge0BsaW5rIEZsb2F0aW5nQnV0dG9ufSB0byB0aGlzIG1lbnVcbiAgICAgKi9cbiAgICBhcHBlbmQobWVudUl0ZW0pIHtcbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKG1lbnVJdGVtLiRlbCk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQG1vZHVsZSBIZWxwZXJGdW5jdGlvbnNcbiAqL1xuXG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gXCJqc29uLXN0cmluZ2lmeS1wcmV0dHktY29tcGFjdFwiOyAvLyBub3RlOiBpbXBvcnRlZCBmcm9tIGEgbW9kdWxlXG5cbi8qKlxuICogYWRkIGEgY3Jvc3MgYnJvd3NlciBldmVudCBsaXN0ZW5lciBvbiBhIG1vdXNlIHNjcm9sbFxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IERPTSBxdWVyeSBvZiB0aGUgZWxlbWVudCB0aGF0IHRoZSBsaXN0ZW5lciB3aWxsIGJlIGFkZGVkIHRvXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jICBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy4gVGhlIGZ1bmN0aW9uIHRha2VzIGFzIGEgcGFyYW1ldGVyIGFuIGV2ZW50IG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZE1vdXNlU2Nyb2xsRXZlbnRMaXN0ZW5lcihxdWVyeSwgZnVuYykge1xuICAgIGxldCBNb3VzZVdoZWVsSGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICAgICAgLy8gcmVkZWNsYXJlIGZvciBvbGQgSUUgc3VwcG9ydFxuICAgICAgICB2YXIgZXZlbnQgPSB3aW5kb3cuZXZlbnQgfHwgZXZlbnQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVkZWNsYXJlXG5cbiAgICAgICAgZXZlbnQuZGVsdGEgPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgKGV2ZW50LndoZWVsRGVsdGEgfHwgLWV2ZW50LmRldGFpbCkpKTtcblxuICAgICAgICBmdW5jKGV2ZW50KVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgc3ZnZWxlbWVudDtcblxuICAgIC8vIGlmIHRoZSBxdWVyeSBpcyBhIHNpbXBsZSBET00gaWQgc2VsZWN0b3IsIHdlIGNhbiB1c2UgZ2V0RWxlbWVudEJ5SWQgd2hpY2ggaGFzIGJldHRlciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIGlmKHF1ZXJ5Lm1hdGNoKC9eI1xcdyskLykpIHtcbiAgICAgICAgc3ZnZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHF1ZXJ5LnN1YnN0cigxKSlcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdmdlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihxdWVyeSlcbiAgICB9XG5cbiAgICBpZiAoc3ZnZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIC8vIElFOSwgQ2hyb21lLCBTYWZhcmksIE9wZXJhXG4gICAgICAgIHN2Z2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNld2hlZWxcIiwgTW91c2VXaGVlbEhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgLy8gRmlyZWZveFxuICAgICAgICBzdmdlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Nb3VzZVNjcm9sbFwiLCBNb3VzZVdoZWVsSGFuZGxlciwgZmFsc2UpO1xuICAgIH0gZWxzZSAge1xuICAgICAgICAvLyBJRSA2LzcvOFxuICAgICAgICBzdmdlbGVtZW50LmF0dGFjaEV2ZW50KFwib25tb3VzZXdoZWVsXCIsIE1vdXNlV2hlZWxIYW5kbGVyKTtcbiAgICB9XG4gICAgc3ZnZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnZXZlbnQnLCBlKVxuICAgIH0sIGZhbHNlKVxufVxuXG4vKipcbiAqIGNvbnZlcnQgYSBkYXRhIG9iamVjdCB0byBKU09OIHN0cmluZyBvciB0byBhIGRhdGEgVVJJIGNvbnRhaW5pbmcgYSBKU09OIHN0cmluZ1xuICogQHBhcmFtICB7T2JqZWN0fSAgZGF0YSAgICAgICAgICAgIG9iamVjdCB0aGF0IHdpbGwgYmUgc2VyaWFsaXplZCBpbnRvIGEgSlNPTiBzdHJpbmdcbiAqIEBwYXJhbSAge0Jvb2xlYW59IFtwcmV0dHk9ZmFsc2VdICBpZiBgdHJ1ZWAsIHRoZSBjb2RlIHdpbGwgYmUgcHJvcHJlcmx5IGluZGVudGVkLCBlbHNlIGEgbW9yZSBjb21wYWN0IHN5bnRheCB3aWxsIGJlIHVzZWRcbiAqIEBwYXJhbSAge0Jvb2xlYW59IFtkYXRhVXJpPWZhbHNlXSByZXR1cm4gZGF0YVVyaSBjb250YWluaW5nIHRoZSBKU09OIHN0cmluZyBpbnN0ZWFkIG9mIHRoZSBwdXJlIEpTT04gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRKU09OU3RyaW5nKGRhdGEsIHByZXR0eSA9IGZhbHNlLCBkYXRhVXJpID0gZmFsc2UpIHtcbiAgICBpZihkYXRhVXJpKSB7XG4gICAgICAgIHJldHVybiAnZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgsJ1xuICAgICAgICAgICAgKyBlbmNvZGVVUklDb21wb25lbnQoZ2V0SlNPTlN0cmluZyhkYXRhLCBwcmV0dHkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKHByZXR0eSkge1xuICAgICAgICAgICAgY2FzZSB0cnVlOlxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoZGF0YSwge21heExlbmd0aDogNTB9KTtcbiAgICAgICAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIHJldHVybnMgdGhlIE1hbmhhdHRhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludHMgX2FfIGFuZCBfYl9cbiAqIEBwYXJhbSAge09iamVjdH0gYSBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqIEBwYXJhbSAge09iamVjdH0gYiBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hbmhhdHRhbkRpc3RhbmNlKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYS54IC0gYi54KSArIE1hdGguYWJzKGEueSAtIGIueSk7XG59XG4iLCIvKiogQG1vZHVsZSBJZCAqL1xuXG4vKipcbiAqIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIElkXG4gKiBAdHlwZSB7SWR9XG4gKi9cbmxldCBleGlzdGluZ0lkSW5zdGFuY2U7XG5cbi8qKlxuICogc2luZ2xldG9uIHRvIGdlbmVyYXRlIHVuaXF1ZSBpZCdzXG4gKlxuICogdXNhZ2U6IGBsZXQgaWQgPSBuZXcgSWQoKS51bmlxdWVgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYoIWV4aXN0aW5nSWRJbnN0YW5jZSl7XG4gICAgICAgICAgICBleGlzdGluZ0lkSW5zdGFuY2UgPSB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByZWZpeCBmb3IgdGhlIGlkLCB0aGF0IGlzIGNvbW1vbiBpbiBhbGwgdGhlIElkc1xuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmVmaXggPSBcImlkXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG51bWVyaWMgcGFydCBvZiB0aGUgbmV4dCBpZCAodGhlIG5leHQgaWQgd2l0aG91dCB0aGUgcHJlZml4KVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0SWQgPSAwO1xuXG4gICAgICAgIHJldHVybiBleGlzdGluZ0lkSW5zdGFuY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHVuaXF1ZSBJRFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gbmV3IHVuaXF1ZSBJRFxuICAgICAqL1xuICAgIGdldCB1bmlxdWUoKSB7XG4gICAgICAgIGxldCByZXRWYWwgPSB0aGlzLnByZWZpeCArIHRoaXMubmV4dElkO1xuXG4gICAgICAgIC8vIGZpbmQgbmV4dCB1bnVzZWQgaWRYWFhYIHRvIHByZXZlbnQgaWQgY29sbGlzaW9uIHRoYXQgbWlnaHQgYmUgY2F1c2VkIGJ5IHNvbWUgb3RoZXIgY29tcG9uZW50XG4gICAgICAgIC8vIChpdCByZWFsbHkgc2hvdWxkIG5vdCBoYXBwZW4sIGJ1dCB0aGlzIGlzIGEgc2ltcGxlIHdheSB0byBlbnN1cmUgaXQpXG4gICAgICAgIHdoaWxlKCQoXCIjXCIrcmV0VmFsKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dElkKys7XG4gICAgICAgICAgICByZXRWYWwgPSB0aGlzLmdlbmVyYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIHRoaXMgaWRcbiAgICAgICAgdGhpcy5uZXh0SWQrKztcblxuICAgICAgICByZXR1cm4gcmV0VmFsO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiogQG1vZHVsZSBMb2dpYyAqL1xuLyoqXG4gKiBkZWZpbml0aW9ucyBvZiBsb2dpYyBzdGF0ZXMgYW5kIGJhc2ljIGxvZ2ljIGZ1bmN0aW9ucyB1c2VkIGluIHRoZSBzaW11bGF0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvZ2ljIHtcbiAgICAvKipcbiAgICAgKiBFbnVtIGZvciBsb2dpYyBzdGF0ZXMuXG4gICAgICpcbiAgICAgKiBTdGF0ZXM6XG4gICAgICogLSBgdW5rbm93bmBcbiAgICAgKiAtIGBvbmBcbiAgICAgKiAtIGBvZmZgXG4gICAgICogLSBgb3NjaWxsYXRpbmdgXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5rbm93bjogMCxcbiAgICAgICAgICAgIG9uOiAxLFxuICAgICAgICAgICAgb2ZmOiAyLFxuICAgICAgICAgICAgb3NjaWxsYXRpbmc6IDNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGxpc3Qgb2YgYWxsIHN0YXRlcyB0aGF0IGNhbiBiZSB1c2VkIGluIHRoZSBzaW11bGF0aW9uXG4gICAgICpcbiAgICAgKiBUaGlzIGdldHRlciBpdGVyYXRlcyBvdmVyIExvZ2ljLnN0YXRlIGFuZCByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHZhbHVlcyBvZiBMb2dpYy5zdGF0ZSdzIG1lbWJlcnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBzdGF0ZUxpc3QoKSB7XG4gICAgICAgIGxldCBzdGF0ZXMgPSBbXTtcblxuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgYWxsIGRlZmluZWQgc3RhdGVzIGFuZCBhZGQgdGhlaXIgdmFsdWVzIHRvIHRoZSBzdGF0ZXMgYXJyYXlcbiAgICAgICAgT2JqZWN0LmtleXMoTG9naWMuc3RhdGUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHN0YXRlcy5wdXNoKExvZ2ljLnN0YXRlW2tleV0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc3RhdGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvZ2ljIEFORFxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBhIGZpcnN0IGlucHV0IHN0YXRlXG4gICAgICogQHBhcmFtICB7TG9naWMuc3RhdGV9IGIgc2Vjb25kIGlucHV0IHN0YXRlXG4gICAgICogQHJldHVybiB7TG9naWMuc3RhdGV9ICAgb3V0cHV0IHN0YXRlXG4gICAgICovXG4gICAgc3RhdGljIGFuZChhLCBiKSB7XG4gICAgICAgIHJldHVybiBMb2dpYy5ydW5TeW1tZXRyaWNSdWxlcyhhLCBiLCBbXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9uLCBMb2dpYy5zdGF0ZS5vbl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub2ZmXSxcbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vbiwgTG9naWMuc3RhdGUudW5rbm93biwgTG9naWMuc3RhdGUudW5rbm93bl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZ10sXG5cbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vZmYsIExvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub2ZmXSxcbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vZmYsIExvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLm9mZl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub2ZmLCBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZywgTG9naWMuc3RhdGUub2ZmXSxcblxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLnVua25vd25dLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS51bmtub3duXSxcblxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZywgTG9naWMuc3RhdGUub3NjaWxsYXRpbmddXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dpYyBOQU5EXG4gICAgICogQHBhcmFtICB7TG9naWMuc3RhdGV9IGEgZmlyc3QgaW5wdXQgc3RhdGVcbiAgICAgKiBAcGFyYW0gIHtMb2dpYy5zdGF0ZX0gYiBzZWNvbmQgaW5wdXQgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtMb2dpYy5zdGF0ZX0gICBvdXRwdXQgc3RhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgbmFuZChhLCBiKSB7XG4gICAgICAgIHJldHVybiBMb2dpYy5ub3QoTG9naWMuYW5kKGEsIGIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2dpYyBOT1JcbiAgICAgKiBAcGFyYW0gIHtMb2dpYy5zdGF0ZX0gYSBmaXJzdCBpbnB1dCBzdGF0ZVxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBiIHNlY29uZCBpbnB1dCBzdGF0ZVxuICAgICAqIEByZXR1cm4ge0xvZ2ljLnN0YXRlfSAgIG91dHB1dCBzdGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBub3IoYSwgYikge1xuICAgICAgICByZXR1cm4gTG9naWMubm90KExvZ2ljLm9yKGEsIGIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2dpYyBOT1RcbiAgICAgKiBAcGFyYW0gIHtMb2dpYy5zdGF0ZX0gYSBmaXJzdCBpbnB1dCBzdGF0ZVxuICAgICAqIEByZXR1cm4ge0xvZ2ljLnN0YXRlfSAgIG91dHB1dCBzdGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBub3QoYSkge1xuICAgICAgICBpZihhID09PSBMb2dpYy5zdGF0ZS5vbikge1xuICAgICAgICAgICAgcmV0dXJuIExvZ2ljLnN0YXRlLm9mZjtcbiAgICAgICAgfSBlbHNlIGlmIChhID09PSBMb2dpYy5zdGF0ZS5vZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBMb2dpYy5zdGF0ZS5vbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9naWMgT1JcbiAgICAgKiBAcGFyYW0gIHtMb2dpYy5zdGF0ZX0gYSBmaXJzdCBpbnB1dCBzdGF0ZVxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBiIHNlY29uZCBpbnB1dCBzdGF0ZVxuICAgICAqIEByZXR1cm4ge0xvZ2ljLnN0YXRlfSAgIG91dHB1dCBzdGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBvcihhLCBiKSB7XG4gICAgICAgIHJldHVybiBMb2dpYy5ydW5TeW1tZXRyaWNSdWxlcyhhLCBiLCBbXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9uLCBMb2dpYy5zdGF0ZS5vbl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub25dLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9uLCBMb2dpYy5zdGF0ZS51bmtub3duLCBMb2dpYy5zdGF0ZS5vbl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS5vbl0sXG5cbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vZmYsIExvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub2ZmXSxcbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vZmYsIExvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLnVua25vd25dLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub3NjaWxsYXRpbmcsIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nXSxcblxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLnVua25vd25dLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS51bmtub3duXSxcblxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZywgTG9naWMuc3RhdGUub3NjaWxsYXRpbmddXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvZ2ljIFhOT1JcbiAgICAgKiBAcGFyYW0gIHtMb2dpYy5zdGF0ZX0gYSBmaXJzdCBpbnB1dCBzdGF0ZVxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBiIHNlY29uZCBpbnB1dCBzdGF0ZVxuICAgICAqIEByZXR1cm4ge0xvZ2ljLnN0YXRlfSAgIG91dHB1dCBzdGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyB4bm9yKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIExvZ2ljLm5vdChMb2dpYy54b3IoYSwgYikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvZ2ljIFhPUlxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBhIGZpcnN0IGlucHV0IHN0YXRlXG4gICAgICogQHBhcmFtICB7TG9naWMuc3RhdGV9IGIgc2Vjb25kIGlucHV0IHN0YXRlXG4gICAgICogQHJldHVybiB7TG9naWMuc3RhdGV9ICAgb3V0cHV0IHN0YXRlXG4gICAgICovXG4gICAgc3RhdGljIHhvcihhLCBiKSB7XG4gICAgICAgIHJldHVybiBMb2dpYy5ydW5TeW1tZXRyaWNSdWxlcyhhLCBiLCBbXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9uLCBMb2dpYy5zdGF0ZS5vZmZdLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9uLCBMb2dpYy5zdGF0ZS5vZmYsIExvZ2ljLnN0YXRlLm9uXSxcbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vbiwgTG9naWMuc3RhdGUudW5rbm93biwgTG9naWMuc3RhdGUudW5rbm93bl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZ10sXG5cbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vZmYsIExvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub2ZmXSxcbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vZmYsIExvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLnVua25vd25dLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub3NjaWxsYXRpbmcsIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nXSxcblxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLnVua25vd25dLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS51bmtub3duXSxcblxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZywgTG9naWMuc3RhdGUub3NjaWxsYXRpbmddXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBjb3JyZWN0IHJ1bGUgaW4gdGhlIGFycmF5IG9mIHJ1bGVzIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJldHVybiB2YWx1ZS5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGV4cGVjdHMgcnVsZXMgdG8gYmUgc3ltbWV0cmljIChzbyBgYSBSVUxFIGJgIHNob3VsZCByZXR1cm5zIHRoZSBzYW1lIHZhbHVlIGFzIGBiIFJVTEUgYWApLFxuICAgICAqIHdoaWNoIGFsbG93cyB0byBjdXQgZG93biBvbiB0aGUgYHJ1bGVzYCBhcnJheSBxdWl0ZSBhIGJpdFxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBhICAgICBmaXJzdCBpbnB1dCBzdGF0ZVxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBiICAgICBzZWNvbmQgaW5wdXQgc3RhdGVcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcnVsZXMgICAgICAgQXJyYXkgb2YgYXJyYXlzLiBFYWNoIGlubmVyIGFycmF5IHJlcHJlc2VudHMgYSBydWxlIGluIHRoZSBmb3JtYXQgW2lucHV0MSwgaW5wdXQyLCBvdXRwdXRdLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZnVuY3Rpb24gZmluZHMgYW4gYXJyYXksIHdoZXJlIGBhID09PSBpbnB1dDFgIGFuZCBgYiA9PT0gaW5wdXQxYCAob3IgYGEgPT09IGlucHV0MmAgYW5kIGBiID09PSBpbnB1dDFgKVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgcmV0dXJucyBgb3V0cHV0YCBmcm9tIHRoaXMgYXJyYXkuXG4gICAgICogQHJldHVybiB7TG9naWMuc3RhdGV9ICAgICAgIG91dHB1dCBzdGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBydW5TeW1tZXRyaWNSdWxlcyhhLCBiLCBydWxlcykge1xuICAgICAgICAvLyBpdGVyYXRlIHRocm91Z2ggYWxsIHRoZSBydWxlc1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgcnVsZXMpIHtcbiAgICAgICAgICAgIGlmICgocnVsZVswXSA9PT0gYSAmJiBydWxlWzFdID09PSBiKSB8fCAocnVsZVswXSA9PT0gYiAmJiBydWxlWzFdID09PSBhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBydWxlWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm8gcnVsZSBtYXRjaGVzLCB0aGUgb3V0cHV0IHN0YXRlIGlzIHVua25vd25cbiAgICAgICAgcmV0dXJuIExvZ2ljLnN0YXRlLnVua25vd247XG4gICAgfVxufVxuIiwiaW1wb3J0IENhbnZhcyBmcm9tICcuL2NhbnZhcyc7XG5cbi8qKlxuICogV2hlbiB0aGUgZG9jdW1lbnQgaXMgcmVhZHksIGluaXRpYWxpemUgdGhlIGFwcGxpY2F0aW9uXG4gKi9cbiQoKCkgPT4ge1xuICAgIG5ldyBDYW52YXMoXCIjY2FudmFzXCIsIDEwKTtcbn0pO1xuIiwiLyoqIEBtb2R1bGUgTWFwV2l0aERlZmF1bHRWYWx1ZSAqL1xuLyoqXG4gKiBNYXAgdGhhdCBoYXMgYSBkZWZhdWx0IHZhbHVlIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IuXG4gKlxuICogRm9yIHRoZSBjb21wbGV0ZSBkb2N1bWVudGF0aW9uIG9mIHRoZSBNYXAgc2VlIFtNYXAgaW4gdGhlIE1ETiB3ZWIgZG9jc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwKVxuICpcbiAqIFVzYWdlOlxuICogYGBgSmF2YVNjcmlwdFxuIGxldCBteU1hcCA9IG5ldyBNYXBXaXRoRGVmYXVsdFZhbHVlKEluZmluaXR5KTtcbiBjb25zdCB2YWx1ZSA9IG15TWFwLmdldFdpdGhEZWZhdWx0KGtleSlcbiBgYGBcbiAqXG4gKiBfTm90ZTogVGhpcyB2ZXJzaW9uIGlzIHdyaXR0ZW4gc3BlY2lhbGx5IGZvciBFUzYgY29tcGlsZWQgaW50byBFUzUuIEluIG5vbi1jb21waWxlZCBFUzYgaXMgdGhlIGltcGxlbWVudGF0aW9uIGZhciBtb3JlIGVsZWdhbnQ6X1xuICpcbiAqIGBgYEphdmFTY3JpcHRcbiBleHBvcnQgY2xhc3MgTWFwV2l0aERlZmF1bHRWYWx1ZSBleHRlbmRzIE1hcCB7XG4gICAgIGNvbnN0cnVjdG9yKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAgdGhpcy5kZWZhdWx0ID0gZGVmYXVsdFZhbHVlO1xuICAgICB9XG5cbiAgICAgZ2V0KGtleSkge1xuICAgICAgICAgaWYodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5KTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdDtcbiAgICAgICAgIH1cbiAgICAgfVxuIH1gYGBcbiAqIEBjbGFzcyBNYXBXaXRoRGVmYXVsdFZhbHVlXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIHthbnl9IGRlZmF1bHQgdmFsdWUgdGhhdCB3aWxsIGJlIHJldHVybmVkIHdoZW4gdGhlIHJlcXVlc3RlZCBrZXkgaXMgbm90IGZvdW5kIGluIHRoZSBtYXBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZGVmYXVsdFZhbHVlKSB7XG4gICAgbGV0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHthbnl9IGtleSBrZXkgb2YgYSByZXF1ZXN0ZWQgaXRlbVxuICAgICAqIEByZXR1cm4ge2FueX0gdmFsdWUgb2YgdGhlIGl0ZW0gd2l0aCB0aGUgY29ycmVzcG9uZGluZyBrZXksIG9yIGRlZmF1bHRWYWx1ZSBpZiB0aGUga2V5IGlzIG5vdCBmb3VuZCBpbiB0aGUgbWFwXG4gICAgICovXG4gICAgbWFwLmdldFdpdGhEZWZhdWx0ID0gKGtleSkgPT4ge1xuICAgICAgICByZXR1cm4gbWFwLmhhcyhrZXkpXG4gICAgICAgICAgICA/IG1hcC5nZXQoa2V5KVxuICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59XG4iLCJcbmNsYXNzIE1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIG9uSGlkZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLiRlbCA9ICQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhcIm1lc3NhZ2VcIikudGV4dCh0ZXh0KTtcblxuICAgICAgICB0aGlzLm9uSGlkZSA9IG9uSGlkZTtcbiAgICB9XG5cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmUoKTtcblxuICAgICAgICBpZih0aGlzLm9uSGlkZSkge1xuICAgICAgICAgICAgdGhpcy5vbkhpZGUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgTG9hZGluZ01lc3NhZ2UgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBvbkhpZGUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3VwZXIodGV4dCwgb25IaWRlKTtcblxuICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcyhcImxvYWRpbmdcIik7XG4gICAgfVxufVxuXG5jbGFzcyBDbG9zYWJsZU1lc3NhZ2UgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBvbkhpZGUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3VwZXIodGV4dCwgb25IaWRlKTtcblxuICAgICAgICB0aGlzLiRlbC5hcHBlbmQoXG4gICAgICAgICAgICAkKFwiPHNwYW4+XCIpLmFkZENsYXNzKFwiY2xvc2VcIikuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgIH1cbn1cblxuY2xhc3MgRXJyb3JNZXNzYWdlIGV4dGVuZHMgQ2xvc2FibGVNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBvbkhpZGUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3VwZXIodGV4dCwgb25IaWRlKTtcblxuICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcyhcImVycm9yXCIpO1xuICAgIH1cbn1cblxuY2xhc3MgV2FybmluZ01lc3NhZ2UgZXh0ZW5kcyBDbG9zYWJsZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIG9uSGlkZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBzdXBlcih0ZXh0LCBvbkhpZGUpO1xuXG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKFwid2FybmluZ1wiKTtcbiAgICB9XG59XG5cbi8qKlxuICogZGlzcGxheSBtZXNzYWdlcyB0byB0aGUgdXNlciBpbiBhIG5pY2UgVUlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVzc2FnZXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLiRlbCA9ICQoXCI8ZGl2PlwiKS5hZGRDbGFzcygnbWVzc2FnZXMnKTtcblxuICAgICAgICB0aGlzLmNvdW50ID0gMDtcblxuICAgICAgICAvLyBwbGFjZSB0aGUgcHJvZ3Jlc3MgaW5mbyBlbGVtZW50XG4gICAgICAgICQoJ2JvZHknKS5hcHBlbmQodGhpcy4kZWwpO1xuICAgIH1cblxuICAgIGdldCBjb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUNvdW50O1xuICAgIH1cblxuICAgIHNldCBjb3VudCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2VDb3VudCA9IHZhbHVlO1xuXG4gICAgICAgIGlmKHRoaXMubWVzc2FnZUNvdW50IDwgMSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhpZGUoKSB7XG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKCdoaWRkZW4nKTtcbiAgICB9XG5cbiAgICBkaXNwbGF5KCkge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgfVxuXG4gICAgbmV3TWVzc2FnZSh0ZXh0LCBjb25zdHIgPSBNZXNzYWdlKSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gbmV3IGNvbnN0cih0ZXh0LCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvdW50LS07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZChtZXNzYWdlLiRlbCk7XG4gICAgICAgIHRoaXMuY291bnQrKztcblxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG5cbiAgICBuZXdMb2FkaW5nTWVzc2FnZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld01lc3NhZ2UodGV4dCwgTG9hZGluZ01lc3NhZ2UpO1xuICAgIH1cblxuICAgIG5ld0Vycm9yTWVzc2FnZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld01lc3NhZ2UodGV4dCwgRXJyb3JNZXNzYWdlKTtcbiAgICB9XG5cbiAgICBuZXdXYXJuaW5nTWVzc2FnZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld01lc3NhZ2UodGV4dCwgV2FybmluZ01lc3NhZ2UpO1xuICAgIH1cbn1cbiIsIi8qKlxuICogQG1vZHVsZSBMaWJyYXJ5XG4gKi9cblxuY29uc3QgbGlicmFyeURpciA9ICcuL2xpYnJhcnkvJ1xuXG4vKipcbiAqIGdldCBsaXN0IG9mIG5ldHdvcmtzIGZyb20gdGhlIGxpYnJhcnlcbiAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UsIHRoZSByZXNvbHV0aW9uIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGEgbGlzdCBvZiBsaWJyYXJpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExpYnJhcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgbGlicmFyeUZpbGUgPSBsaWJyYXJ5RGlyICsgJ25ldHdvcmtMaXN0Lmpzb24nO1xuXG4gICAgICAgIGxldCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKHRoaXMucmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UubmV0d29ya3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoW1wiZXJyb3JcIiwgXCJhYm9ydFwiXSwgKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KFwiRmFpbGVkIGxvYWRpbmcgbGlicmFyaWVzLlwiKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIGxpYnJhcnlGaWxlLCB0cnVlKTtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIGdldCBhIG5ldHdvcmsgZnJvbSB0aGUgbGlicmFyeSwgc3BlY2lmaWVkIGJ5IGZpbGVuYW1lXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG5ldHdvcmtOYW1lIGxpYnJhcnkgZmlsZSBuYW1lIHdpdGhvdXQgdGhlIGV4dGVuc2lvblxuICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSwgdGhlIHJlc29sdXRpb24gaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGxpYnJhcnkgaW1wb3J0IGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5ldHdvcmtGcm9tTGlicmFyeShuZXR3b3JrTmFtZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKHRoaXMucmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoW1wiZXJyb3JcIiwgXCJhYm9ydFwiXSwgKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGBGYWlsZWQgbG9hZGluZyBsaWJyYXJ5ICR7bmV0d29ya05hbWV9LmApXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgbGlicmFyeURpciArIG5ldHdvcmtOYW1lICsgJy5qc29uJywgdHJ1ZSk7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICB9KTtcbn1cbiIsImltcG9ydCBMb2dpYyBmcm9tICcuL2xvZ2ljJ1xuXG4vKipcbiAqIEBtb2R1bGUgU2ltdWxhdGlvblxuICovXG5cblxuY2xhc3Mgc3RhdGVDaGFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3RvcklkLCBzdGF0ZSwgd2hvQ2F1c2VkSXQpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0b3JJZCA9IGNvbm5lY3RvcklkXG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZVxuICAgICAgICB0aGlzLndob0NhdXNlZEl0ID0gd2hvQ2F1c2VkSXRcbiAgICB9XG59XG5cbi8qKlxuICogVGhpcyBjbGFzcyBydW5zIHRoZSBuZXR3b3JrIHNpbXVsYXRpb24uXG4gKlxuICogX25vdGU6IGFsbCBjb25uZWN0b3JzIHRoYXQgYXJlIHVzZWQgaW4gdGhpcyBjbGFzcyBhcmUgKipvdXRwdXQgY29ubmVjdG9ycyoqX1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaW11bGF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gcGFyZW50U1ZHIGluc3RhbmNlIG9mIFtDYW52YXNdKC4vbW9kdWxlLUNhbnZhcy5odG1sKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFNWRykge1xuICAgICAgICAvKipcbiAgICAgICAgICogaW5zdGFuY2Ugb2YgQ2FudmFzIHRoaXMgU2ltdWxhdGlvbiBiZWxvbmdzIHRvXG4gICAgICAgICAqIEB0eXBlIHtDYW52YXN9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcmVudFNWRyA9IHBhcmVudFNWR1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXBzIGVhY2ggYWZmZWN0ZWQgb3V0cHV0IGNvbm5lY3RvciB0byBpdCdzIGRpcmVjdGx5IHByZWNlZWRpbmcgb3V0cHV0IGNvbm5lY3RvcnNcbiAgICAgICAgICogQHR5cGUge01hcH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJlZGVjZXNzb3JzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXBzIHdhdmVJZCB0byBhbiBhcnJheSBvZiBhZmZlY3RlZCBvdXRwdXRDb25uZWN0b3JzXG4gICAgICAgICAqIEB0eXBlIHtNYXB9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndhdmVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLndhdmUgPSAwXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1hcHMgY3ljbGVkIGNvbm5lY3RvciBpZCB0byBzZXQgb2Ygc3RhdGVzIHRoaXMgY29ubmVjdG9yIHdhcyBpblxuICAgICAgICAgKiBAdHlwZSB7TWFwfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jeWNsZWRDb25uZWN0b3JzID0gbmV3IE1hcCgpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBvZiBjeWNsZWQgY29ubmVjdG9ycyB0aGF0IGhhdmUgYmVlbiBhbHJlYWR5IHJlc29sdmVkXG4gICAgICAgICAqIEB0eXBlIHtTZXR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc29sdmVkQ3ljbGVkQ29ubmVjdG9ycyA9IG5ldyBTZXQoKVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcnVuIHRoZSBzaW11bGF0aW9uXG4gICAgICovXG4gICAgcnVuKCkge1xuICAgICAgICB0aGlzLndhdmUrKztcbiAgICAgICAgd2hpbGUodGhpcy53YXZlcy5oYXModGhpcy53YXZlKSkge1xuICAgICAgICAgICAgdGhpcy5zdGVwKClcbiAgICAgICAgICAgIHRoaXMud2F2ZXMuZGVsZXRlKHRoaXMud2F2ZSkgLy8gY2xlYW4gb2xkIHdhdmVzIG9uIHRoZSBnb1xuICAgICAgICAgICAgdGhpcy53YXZlKytcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG9uZSBzdGVwL3dhdmUgb2YgdGhlIHNpbXVsYXRpb25cbiAgICAgKlxuICAgICAqIGRldGVybWluZXMgc3RhdGVzIG9mIHRoZSBjb25uZWN0b3JzIGluIHRoZSBjdXJyZW50IHdhdmUsIGRldGVjdHMgY3ljbGVzXG4gICAgICovXG4gICAgc3RlcCgpIHtcbiAgICAgICAgZm9yIChsZXQge2Nvbm5lY3RvcklkLCBzdGF0ZSwgd2hvQ2F1c2VkSXR9IG9mIHRoaXMud2F2ZXMuZ2V0KHRoaXMud2F2ZSkpIHtcbiAgICAgICAgICAgIC8vIHNraXAgcmVzb2x2ZWQgY3ljbGVzXG4gICAgICAgICAgICBpZih0aGlzLnJlc29sdmVkQ3ljbGVkQ29ubmVjdG9ycy5oYXMoY29ubmVjdG9ySWQpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2tpcCBjb25uZWN0b3IgdGhhdCBhcmUgY3ljbGVzXG4gICAgICAgICAgICBpZiAodGhpcy5jeWNsZWRDb25uZWN0b3JzLmhhcyhjb25uZWN0b3JJZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHNldCBvZiBzdGF0ZXMgdGhhdCB0aGlzIGNvbm5lY3RvciBhcHBlYXJlZCBmcm9tIHRoZSBtb21lbnQgdGhlIHNpZ25hbCBmaXJzdCBjeWNsZWRcbiAgICAgICAgICAgICAgICBsZXQgc3RhdGVzID0gdGhpcy5jeWNsZWRDb25uZWN0b3JzLmdldChjb25uZWN0b3JJZClcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjb25uZWN0b3IgYWxyZWFkeSBoYWQgdGhpcyBzdGF0ZSBpbiB0aGlzIGN5Y2xlLCByZXNvbHZlIHRoZSBjeWNsZVxuICAgICAgICAgICAgICAgIGlmKHN0YXRlcy5oYXMoc3RhdGUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG1vcmUgc3RhdGVzIGluIHRoZSBzZXQsIHRoZSBjb25uZWN0b3IgaXMgb3NjaWxsYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gKGVsc2UgaXQga2VlcHMgaXRzIHN0YXRlIGFuZCB3ZSBqdXN0IGJyZWFrIHRoZSBjeWNsZSlcbiAgICAgICAgICAgICAgICAgICAgaWYoc3RhdGVzLnNpemUgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBtYXJrIHRoaXMgY29ubmVjdG9yIGFzIHJlc29sdmVkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRDeWNsZWRDb25uZWN0b3JzLmFkZChjb25uZWN0b3JJZClcblxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBuZXcsIHVuc2VlbiBzdGF0ZSwgYWRkIGl0IHRvIHRoZSBzZXQgYW5kIGNvbnRpbnVlIHNpbXVsYXRpbmcgdGhlIGN5Y2xlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVzLmFkZChzdGF0ZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBtYXAgdGhlIG1vZGlmaWVkIHNldCBvZiBzdGF0ZXMgdG8gdGhlIGNvbm5lY3RvclxuICAgICAgICAgICAgICAgIHRoaXMuY3ljbGVkQ29ubmVjdG9ycy5zZXQoY29ubmVjdG9ySWQsIHN0YXRlcylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy53aG9DYXVzZWRJdCA9IGNvbm5lY3RvcklkXG4gICAgICAgICAgICAvKiAgcHJvY2VzcyBhbGwgb3V0cHV0Q29ubmVjdG9ycyBieSBzZXR0aW5nIHRoZWlyIHN0YXRlXG4gICAgICAgICAgICAgICAgdGhpcyB3aWxsIHRyaWdnZXIgYSBmb2xsb3dpbmcgZXZlbnQgY2hhaW46XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dENvbm5lY3RvciBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgICAgIC0+IGFsbCBjb25uZWN0ZWQgd2lyZXMgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIC0+IGFsbCBpbnB1dENvbm5lY3RvcnMgY29ubmVjdGVkIHRvIHRoZXNlIHdpcmVzIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAtPiBhbGwgZWxlbWVudHMgdGhhdCBjb250YWluIHRoZXNlIGlucHV0Q29ubmVjdG9ycyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgLT4gdGhlc2UgZWxlbWVudHMgY29tcHV0ZSB0aGUgbmV3IHN0YXRlIG9mIHRoZWlyIG91dHB1dCBjb25uZWN0b3JzIGFuZCBjYWxsIG5vdGlmeUNoYW5nZSgpXG4gICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICAgIGlmKHdob0NhdXNlZEl0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQcmVkZWNlc3Nvcihjb25uZWN0b3JJZCwgd2hvQ2F1c2VkSXQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5jeWNsZWRDb25uZWN0b3JzLmhhcyhjb25uZWN0b3JJZCkgJiYgdGhpcy5nZXRBbGxQcmVkZWNlc3NvcnMoY29ubmVjdG9ySWQpLmhhcyhjb25uZWN0b3JJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN5Y2xlZENvbm5lY3RvcnMuc2V0KGNvbm5lY3RvcklkLCBuZXcgU2V0KFtzdGF0ZV0pKVxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIHJlZmxlY3QgdGhlIGNoYW5nZXMgaW4gU1ZHXG4gICAgICAgICAgICBsZXQgY29ubmVjdG9yID0gdGhpcy5wYXJlbnRTVkcuZ2V0Q29ubmVjdG9yQnlJZChjb25uZWN0b3JJZClcbiAgICAgICAgICAgIGlmKGNvbm5lY3Rvcikge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5zZXRTdGF0ZShzdGF0ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLndob0NhdXNlZEl0ID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWFyayBhIHByZWRlY2Vzc29yQ29ubmVjdG9ySWQgYXMgYSBwcmVkZWNlc3NvciBvZiBjb25uZWN0b3JJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb25uZWN0b3JJZCBJRCBvZiBhIGNvbm5lY3RvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVkZWNlc3NvckNvbm5lY3RvcklkIHByZWRlY2Vzc29yIG9mIGBjb25uZWN0b3JJZGBcbiAgICAgKi9cbiAgICBhZGRQcmVkZWNlc3Nvcihjb25uZWN0b3JJZCwgcHJlZGVjZXNzb3JDb25uZWN0b3JJZCkge1xuICAgICAgICBpZighdGhpcy5wcmVkZWNlc3NvcnMuaGFzKGNvbm5lY3RvcklkKSkge1xuICAgICAgICAgICAgdGhpcy5wcmVkZWNlc3NvcnMuc2V0KGNvbm5lY3RvcklkLCBuZXcgU2V0KCkpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZWRlY2Vzc29ycy5nZXQoY29ubmVjdG9ySWQpLmFkZChwcmVkZWNlc3NvckNvbm5lY3RvcklkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBzZXQgb2YgYWxsIG91dHB1dCBjb25uZWN0b3JzIHRoYXQgYXJlIGJlZm9yZSB0aGlzIG91dHB1dCBjb25uZWN0b3JcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbm5lY3RvcklkIElEIG9mIGEgY29ubmVjdG9yXG4gICAgICogQHJldHVybiB7U2V0fSAgICAgICAgICAgICAgICBzZXQgb2YgY29ubmVjdG9yIGlkcyB0aGF0IGFyZSBiZWZvcmUgdGhpcyBvdXRwdXQgY29ubmVjdG9yXG4gICAgICovXG4gICAgZ2V0QWxsUHJlZGVjZXNzb3JzKGNvbm5lY3RvcklkKSB7XG4gICAgICAgIGlmKCF0aGlzLnByZWRlY2Vzc29ycy5oYXMoY29ubmVjdG9ySWQpKSB7XG4gICAgICAgICAgICB0aGlzLnByZWRlY2Vzc29ycy5zZXQoY29ubmVjdG9ySWQsIG5ldyBTZXQoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhbGwgPSBuZXcgU2V0KClcblxuICAgICAgICB0aGlzLnByZWRlY2Vzc29ycy5nZXQoY29ubmVjdG9ySWQpLmZvckVhY2goYWxsLmFkZCwgYWxsKTtcblxuICAgICAgICBsZXQgcHJldlNpemUgPSAwXG4gICAgICAgIGxldCBzaXplID0gYWxsLnNpemVcbiAgICAgICAgd2hpbGUocHJldlNpemUgPCBzaXplKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb25uZWN0b3Igb2YgYWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJlZGVjZXNzb3JzLmhhcyhjb25uZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJlZGVjZXNzb3JzLmdldChjb25uZWN0b3IpLmZvckVhY2goYWxsLmFkZCwgYWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2U2l6ZSA9IHNpemVcbiAgICAgICAgICAgIHNpemUgPSBhbGwuc2l6ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdGlmeSBhIGNoYW5nZSBpbiB0aGUgbmV0d29yay4gVGhpcyBmdW5jdGlvbiBhZGRzIHRoZSBjaGFuZ2VkIGNvbm5lY3RvciB0byB0aGUgbmV4dCB3YXZlXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBjb25uZWN0b3JJZCBJRCBvZiB0aGUgY2hhbmdlZCBjb25uZWN0b3JcbiAgICAgKiBAcGFyYW0gIHtMb2dpYy5zdGF0ZX0gc3RhdGUgIG5ldyBbTG9naWMuc3RhdGVdKC4vbW9kdWxlLUxvZ2ljLmh0bWwjLnN0YXRlKSBvZiB0aGUgY29ubmVjdG9yXG4gICAgICovXG4gICAgbm90aWZ5Q2hhbmdlKGNvbm5lY3RvcklkLCBzdGF0ZSkge1xuICAgICAgICBsZXQgd2F2ZUlkID0gdGhpcy53YXZlICsgMVxuXG4gICAgICAgIGlmKCF0aGlzLndhdmVzLmhhcyh3YXZlSWQpKSB7XG4gICAgICAgICAgICB0aGlzLndhdmVzLnNldCh3YXZlSWQsIFtdKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy53YXZlcy5nZXQod2F2ZUlkKS5wdXNoKG5ldyBzdGF0ZUNoYW5nZShjb25uZWN0b3JJZCwgc3RhdGUsIHRoaXMud2hvQ2F1c2VkSXQpKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgSWQgZnJvbSAnLi9pZCdcblxuLyoqXG4gKiBQYXJlbnQgY2xhc3MgZm9yIGFsbCBzdmdPYmplY3RzXG4gKi9cbmNsYXNzIFRhZyB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgU1ZHIHRhZyBpZGVudGlmaWVyIChgcmVjdGAsIGBpbWFnZWAsIGBwb2x5bGluZWApXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFnTmFtZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU1ZHIHRhZyBpZGVudGlmaWVyIChgcmVjdGAsIGBpbWFnZWAsIGBwb2x5bGluZWApXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhZ05hbWUgPSB0YWdOYW1lO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBqUXVlcnkgZWxlbWVudCBmb3IgdGhpcyB0YWdcbiAgICAgICAgICogQHR5cGUge2pRdWVyeS5lbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kZWwgPSAkKFwiPFwiK3RoaXMudGFnTmFtZStcIj5cIik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVuaXF1ZSBJRCBvZiB0aGlzIFNWRyBvYmplY3RcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBuZXcgSWQoKS51bmlxdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgY2xhc3MgdG8gdGhpcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgY2xhc3MgbmFtZSB0byBiZSBhZGRlZFxuICAgICAqL1xuICAgIGFkZENsYXNzKG5hbWUpIHtcbiAgICAgICAgdGhpcy4kZWwuYWRkQ2xhc3MobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGNsYXNzIG5hbWVzIGZyb20gdGhpcyBlbGVtZW50XG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBjbGFzc2VzIGNsYXNzIG5hbWVzIHRvIGJlIHJlbW92ZWRcbiAgICAgKi9cbiAgICByZW1vdmVDbGFzc2VzKC4uLmNsYXNzZXMpIHtcbiAgICAgICAgZm9yKGxldCBpdGVtIG9mIGNsYXNzZXMpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IGF0dHJpYnV0ZXMgb2YgdGhpcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFzc29jIGphdmFzY3JpcHQgb2JqZWN0IHRoYXQgd2lsbCBiZSBtYXBwZWQgaW50byBhdHRyaWJ1dGVzIChge2tleTogdmFsdWV9YCAtPiBga2V5PVwidmFsdWVcImApXG4gICAgICovXG4gICAgYWRkQXR0cihhc3NvYykge1xuICAgICAgICB0aGlzLmNoZWNrSWZFbGVtZW50RXhpc3RzSW5ET00oKTtcblxuICAgICAgICAvLyBhZGQgYXR0cmlidXRlcyB0byB0aGUgZWxlbWVudFxuICAgICAgICB0aGlzLiRlbC5hdHRyKGFzc29jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgYXR0cmlidXRlIHZhbHVlIGJ5IG5hbWVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICogQHJldHVybiB7c3RyaW5nfSAgICAgIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBnZXRBdHRyKG5hbWUpIHtcbiAgICAgICAgdGhpcy5jaGVja0lmRWxlbWVudEV4aXN0c0luRE9NKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLmF0dHIobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGF0dHJpYnV0ZSBieSB2YWx1ZVxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gYmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIHJlbW92ZUF0dHIobmFtZSkge1xuICAgICAgICB0aGlzLmNoZWNrSWZFbGVtZW50RXhpc3RzSW5ET00oKTtcblxuICAgICAgICB0aGlzLiRlbC5yZW1vdmVBdHRyKG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCBpZCBvZiB0aGlzIFNWRyBvYmplY3RcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIG5ldyBpZCBmb3IgdGhpcyBvYmplY3RcbiAgICAgKi9cbiAgICBzZXQgaWQoaWQpIHtcbiAgICAgICAgdGhpcy5hZGRBdHRyKHtcImlkXCI6IGlkfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGlkIG9mIHRoaXMgU1ZHIG9iamVjdFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEF0dHIoXCJpZFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgalF1ZXJ5IGVsZW1lbnQgZm9yIHRoaXMgU1ZHIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2pRdWVyeS5lbGVtZW50fVxuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgICAgdGhpcy5jaGVja0lmRWxlbWVudEV4aXN0c0luRE9NKCk7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjaGVjayBpZiB0aGUgZWxlbWVudCBleGlzdHMgaW4gZG9tLCBpZiBzbywgcmVmZXRjaCBpdCBmcm9tIERPTSB1c2luZyBqUXVlcnlcbiAgICAgKi9cbiAgICBjaGVja0lmRWxlbWVudEV4aXN0c0luRE9NKCkge1xuICAgICAgICBsZXQgJGpxRWxlbWVudCA9ICQoXCIjXCIrdGhpcy4kZWwuYXR0cignaWQnKSk7XG4gICAgICAgIGlmKCRqcUVsZW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLiRlbCA9ICRqcUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogcmVwcmVzZW50cyB2aXNpYmxlIGVsZW1lbnQgaW4gU1ZHIHRoYXQgaGFzIHBvc2l0aW9uIGFuZCBkaW1lbnNpb25zIChmb3IgZXhhbXBsZSBgcmVjdGFuZ2xlYCBpcyBhIFN2Z0VsZW1lbnQsIGJ1dCBgcGF0dGVybmAgaXMgbm90LCBldmVuIHRob3VnaCBib3RoIGFyZSB0YWdzKVxuICogQGV4dGVuZHMgVGFnXG4gKi9cbmNsYXNzIFN2Z0VsZW1lbnQgZXh0ZW5kcyBUYWcge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4ICAgICAgIGhvcml6b250YWwgcG9zaXRpb24gaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAgICAgIHZlcnRpY2FsIHBvc2l0aW9uIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdyAgICAgICB3aWR0aCBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGggICAgICAgaGVpZ2h0IGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSB0YWcgbmFtZSBvZiB0aGUgZWxlbWVudFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHcsIGgsIHRhZ05hbWUpIHtcbiAgICAgICAgc3VwZXIodGFnTmFtZSk7XG5cbiAgICAgICAgdGhpcy5hZGRBdHRyKHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIGEgcmVjdGFuZ2xlIGluIFNWR1xuICogQGV4dGVuZHMgU3ZnRWxlbWVudFxuICovXG5leHBvcnQgY2xhc3MgUmVjdGFuZ2xlIGV4dGVuZHMgU3ZnRWxlbWVudCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggICAgICAgaG9yaXpvbnRhbCBwb3NpdGlvbiBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgICAgICAgdmVydGljYWwgcG9zaXRpb24gaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3ICAgICAgIHdpZHRoIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaCAgICAgICBoZWlnaHQgaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxsICAgIGZpbGxpbmcgY29sb3Igb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJva2UgIHN0cm9rZSBjb2xvciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeCwgeSwgdywgaCwgZmlsbCwgc3Ryb2tlKSB7XG4gICAgICAgIHN1cGVyKHgsIHksIHcsIGgsIFwicmVjdFwiKTtcbiAgICAgICAgdGhpcy5hZGRBdHRyKHtcbiAgICAgICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAwLjUsXG4gICAgICAgICAgICAncG9pbnRlci1ldmVudHMnOiAnYWxsJyAvLyB0byB0cmlnZ2VyIGhvdmVyIGV2ZW4gd2l0aCB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBhbiBpbWFnZSBpbiBTVkdcbiAqIEBleHRlbmRzIFN2Z0VsZW1lbnRcbiAqL1xuZXhwb3J0IGNsYXNzIFN2Z0ltYWdlIGV4dGVuZHMgU3ZnRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoeCwgeSwgdywgaCwgdXJsKSB7XG4gICAgICAgIHN1cGVyKHgsIHksIHcsIGgsIFwiaW1hZ2VcIik7XG4gICAgICAgIHRoaXMuYWRkQXR0cih7XG4gICAgICAgICAgICBcInhsaW5rOmhyZWZcIjogdXJsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNoYW5nZSB1cmwgb2YgdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCB0aGUgbmV3IHVybCBvZiB0aGUgaW1hZ2VcbiAgICAgKi9cbiAgICBjaGFuZ2VVcmwodXJsKSB7XG4gICAgICAgIHRoaXMuYWRkQXR0cih7XG4gICAgICAgICAgICBcInhsaW5rOmhyZWZcIjogdXJsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTVkcgZ3JvdXAsIHVzZWQgZm9yIGdyb3VwaW5nIGVsZW1lbnRzLCBmb3IgZXhhbXBsZSBhIGdhdGUgaXMgcmVwcmVzZW50ZWQgYnkgbWFueSBlbGVtZW50cyAocmVjdGFuZ2xlLCBpbWFnZSwgaW5pdmlzaWJsZSBoaXRib3ggcmVjdGFuZ2xlLi4uKSxcbiAqIGJ1dCBhbGwgb2YgdGhlIGVsZW1lbnRzIG5lZWQgdG8gYmUgdHJhbnNmb3JtZWQgdG9nZXRoZXIuIFVzaW5nIGdyb3VwcyB0aGUgdHJhbnNmb3JtIHByb3BlcnR5IGNhbiBiZSBzZXQgb24gdGhlIGdyb3VwIHdoaWNoIGNvbnRhaW5zIGFsbCB0aGUgZWxlbWVudHMuXG4gKiBAZXh0ZW5kcyBUYWdcbiAqL1xuZXhwb3J0IGNsYXNzIEdyb3VwIGV4dGVuZHMgVGFnIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJnXCIpO1xuXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYW4gZWxlbWVudCB0byB0aGUgZ3JvdXBcbiAgICAgKiBAcGFyYW0ge1N2Z0VsZW1lbnR9IGVsIGFuIGluc3RhbmNlIG9mIHtAbGluayBTdmdFbGVtZW50fVxuICAgICAqL1xuICAgIGFkZENoaWxkKGVsKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChlbCk7XG5cbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKGVsLiRlbCk7XG4gICAgICAgIHJldHVybiBlbDsgLy8gcHJvIGplZG5vZHVzc2kgXCJsZXQgcmVjdCA9IGcuYWRkQ2hpbGQobmV3IFJlY3RhbmdsZSguLi5cIlxuICAgIH1cbn1cblxuLyoqXG4gKiBvbmUgcG9pbnQgb2Yge0BsaW5rIFBvbHlsaW5lUG9pbnRzfSwgdXNlZCBpbiB0aGUge0BsaW5rIFBvbHlMaW5lfSBvYmplY3RcbiAqL1xuZXhwb3J0IGNsYXNzIFBvbHlsaW5lUG9pbnQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IGhvcml6b250YWwgY29vcmRpbmF0ZSBvZiB0aGUgcG9seWxpbmUgcG9pbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSB2ZXJ0aWNhbCBjb29yZGluYXRlIG9mIHRoZSBwb2x5bGluZSBwb2ludFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgaWYoeCAhPT0gdW5kZWZpbmVkICYmIHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjaGFuZ2UgdGhlIGNvb3JkaW5hdGVzIG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBob3Jpem9udGFsIGNvb3JkaW5hdGUgb2YgdGhlIHBvbHlsaW5lIHBvaW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgdmVydGljYWwgY29vcmRpbmF0ZSBvZiB0aGUgcG9seWxpbmUgcG9pbnRcbiAgICAgKi9cbiAgICBzZXQoeCwgeSkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBwb2x5bGluZSBmcm9tIGEgY29tbWEgc2VwYXJhdGVkIHN0cmluZyAoZS5nLiBmcm9tIGEgc3RyaW5nIGZvcm1hdHRlZCBsaWtlIHRoaXM6IFwieCx5XCIsIGZvciBleGFtcGxlIFwiMTUsOFwiKVxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nIHN0cmluZyBpbiB0aGUgZm9ybWF0IFwieCx5XCIgcmVwcmVzZW50aW5nIGEgcG9pbnQgaW4gdGhlIFNWRyBwb2x5bGluZVxuICAgICAqIEByZXR1cm4ge1BvbHlsaW5lUG9pbnR9IG5ld2x5IGNyZWF0ZWQgaW5zdGFuY2Ugb2Yge0BsaW5rIFBvbHlsaW5lUG9pbnR9XG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlRnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgICAgICAgbGV0IGFyciA9IHN0cmluZy5zcGxpdChcIixcIik7XG4gICAgICAgIHJldHVybiBuZXcgUG9seWxpbmVQb2ludChhcnJbMF0sIGFyclsxXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcG9seWxpbmUgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyBpbiB0aGUgZm9ybWF0IFwieCx5XCJcbiAgICAgKi9cbiAgICBnZXQgc3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ICsgXCIsXCIgKyB0aGlzLnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29tcGFyZSBwb2x5bGluZSBwb2ludHMsIHJldHVybiBgdHJ1ZWAgaWYgdGhleSBhcmUgZXF1YWwsIGVsc2UgcmV0dXJuIGBmYWxzZWBcbiAgICAgKiBAcGFyYW0gIHtQb2x5bGluZVBvaW50fSBhXG4gICAgICogQHBhcmFtICB7UG9seWxpbmVQb2ludH0gYlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueTtcbiAgICB9XG59XG5cbi8qKlxuICogYXJyYXktbGlrZSBzdHJ1Y3R1cmUgdXNlZCBpbiB7QGxpbmsgUG9seWxpbmVQb2ludHN9XG4gKi9cbmNsYXNzIFNtYXJ0QXJyYXkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJdIGlmIHNldCwgaW5pdGlhbGl6ZWQgU21hcnRBcnJheSB3aWxsIGNvbnRhaW4gdGhlc2UgdmFsdWVzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXJyKSB7XG4gICAgICAgIGlmKGFyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFyciA9IGFycjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXJyID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgYSBkZWVwIGNvcHkgb2YgdGhpcyBhcnJheVxuICAgICAqIEByZXR1cm4ge1NtYXJ0QXJyYXl9XG4gICAgICovXG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIFNtYXJ0QXJyYXkoJC5leHRlbmQodHJ1ZSwgW10sIHRoaXMuYXJyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYXBwZW5kIGFuIGl0ZW0gdG8gdGhlIGFycmF5XG4gICAgICogQHBhcmFtIGl0ZW0gbmV3IGl0ZW0gdGhhdCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBhcnJheVxuICAgICAqL1xuICAgIGFwcGVuZChpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFdpdGhJbmRleChpdGVtLCB0aGlzLmFyci5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByZXBlbmQgYW4gaXRlbSB0byB0aGUgYXJyYXlcbiAgICAgKiBAcGFyYW0gaXRlbSBuZXcgaXRlbSB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIHRvIHRoZSBhcnJheVxuICAgICAqL1xuICAgIHByZXBlbmQoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRXaXRoSW5kZXgoaXRlbSwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgbmV3IGl0ZW0gYXQgdGhlIHNwZWNpZmllZCBpbmRleCwgbW92ZSBhbGwgZm9sbG93aW5nIGl0ZW1zXG4gICAgICogQHBhcmFtIGl0ZW0gbmV3IGl0ZW0gdGhhdCB3aWxsIGJlIGFkZGVkIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXggb2YgdGhpcyBpdGVtXG4gICAgICovXG4gICAgYWRkV2l0aEluZGV4KGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGZvcihsZXQgaSA9IHRoaXMuYXJyLmxlbmd0aCA7IGkgPiBpbmRleCA7IC0taSkge1xuICAgICAgICAgICAgdGhpcy5hcnJbaV0gPSB0aGlzLmFycltpLTFdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXJyW2luZGV4XSA9IGl0ZW07XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyB0byBlbmFibGUgY2hhaW5pbmcgb2YgYXBwZW5kIC8gcHJlcHBlbmQgLyBhZGRXaXRoSW5kZXggY29tbWFuZHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgbGVuZ3RoIG9mIHRoZSBhcnJheVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnIubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBpdGVtIGJ5IGluZGV4XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBpbmRleCBpbmRleCBvZiB0aGUgaXRlbVxuICAgICAqIEByZXR1cm4gY29udGVudHMgb2YgdGhlIGFycmF5IG9uIHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKi9cbiAgICBnZXRJdGVtKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycltpbmRleF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBsYXN0IGVsZW1lbnQgb2YgdGhlIGFycmF5XG4gICAgICovXG4gICAgZ2V0IGxhc3QoKSB7XG4gICAgICAgIGlmKHRoaXMubGVuZ3RoIT09MCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJyW3RoaXMubGVuZ3RoIC0gMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGFycmF5XG4gICAgICovXG4gICAgZ2V0IGZpcnN0KCkge1xuICAgICAgICBpZih0aGlzLmxlbmd0aCE9PTApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFyclswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIGFycmF5IGJ5IGluZGV4XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBpbmRleCBpbmRleCBvZiB0aGUgaXRlbSB0aGF0IHdpbGwgYmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIHJlbW92ZShpbmRleCkge1xuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yKGxldCBpID0gaW5kZXggOyBpIDwgbGVuZ3RoIDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmFycltpXSA9IHRoaXMuYXJyW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFyci5wb3AoKTtcbiAgICB9XG59XG5cbi8qKlxuICogcG9pbnRzIG9mIHRoZSB7QGxpbmsgUG9seUxpbmV9XG4gKiBAZXh0ZW5kcyBTbWFydEFycmF5XG4gKi9cbmV4cG9ydCBjbGFzcyBQb2x5bGluZVBvaW50cyBleHRlbmRzIFNtYXJ0QXJyYXkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJdIGFycmF5IGNvbnRhaW5pbmcgaW5zdGFuY2VzIG9mIHtAbGluayBQb2x5bGluZVBvaW50fVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFycikge1xuICAgICAgICBzdXBlcihhcnIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBhIGRlZXAgY29weSBvZiB0aGlzIG9iamVjdFxuICAgICAqIEByZXR1cm4ge1BvbHlsaW5lUG9pbnRzfVxuICAgICAqL1xuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9seWxpbmVQb2ludHMoJC5leHRlbmQodHJ1ZSwgW10sIHRoaXMuYXJyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYXBwZW5kIGEgcG9pbnRcbiAgICAgKiBAcGFyYW0gIHtQb2x5bGluZVBvaW50fSBwb2ludCBhIG5ldyBwb2ludFxuICAgICAqL1xuICAgIGFwcGVuZChwb2ludCkge1xuICAgICAgICAvLyBjYWxsIGluaGVyaXRlZCBmdW5jdGlvbiB0byBoYW5kbGUgdGhlIGFwcGVuZGluZ1xuICAgICAgICBzdXBlci5hcHBlbmQocG9pbnQpO1xuXG4gICAgICAgIC8vIGlmIHRoZSBzZWNvbmQgdG8gbGFzdCBwb2ludCBpcyB1bm5lY2Vzc2FyeSwgcmVtb3ZlIGl0XG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKCBsZW5ndGggPj0gM1xuICAgICAgICAgICAgICAgICYmICggICAgKCB0aGlzLmdldEl0ZW0obGVuZ3RoIC0gMykueCA9PT0gdGhpcy5nZXRJdGVtKGxlbmd0aCAtIDIpLnggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRJdGVtKGxlbmd0aCAtIDIpLnggPT09IHRoaXMuZ2V0SXRlbShsZW5ndGggLSAxKS54IClcbiAgICAgICAgICAgICAgICAgICAgIHx8ICggdGhpcy5nZXRJdGVtKGxlbmd0aCAtIDMpLnkgPT09IHRoaXMuZ2V0SXRlbShsZW5ndGggLSAyKS55ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0SXRlbShsZW5ndGggLSAyKS55ID09PSB0aGlzLmdldEl0ZW0obGVuZ3RoIC0gMSkueSApXG4gICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGxlbmd0aCAtIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIHRoaXMgZWxlbWVudCAodG8gYWxsb3cgY2hhaW5pbmcpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHBhcnNlIHBvbHlsaW5lIGZyb20gc3RyaW5nXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmcgc3RyaW5nIGluIHRoZSBwb2x5bGluZSBmb3JtYXQgKGB4MSx5MSB4Mix5MiwgeDMseTNgKVxuICAgICAqIEByZXR1cm4ge1BvbHlsaW5lUG9pbnRzfSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgUG9seWxpbmVQb2ludHN9IGNyZWF0ZWQgYnkgcGFyc2luZyB0aGUgc3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlRnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgICAgICAgbGV0IHBvaW50U3RyaW5ncyA9IHN0cmluZy5zcGxpdChcIiBcIik7XG4gICAgICAgIGxldCBwb2ludHMgPSBuZXcgUG9seWxpbmVQb2ludHMoKTtcblxuICAgICAgICBmb3IobGV0IGkgPSAwIDsgaSA8IHBvaW50U3RyaW5ncy5sZW5ndGggOyArK2kpIHtcbiAgICAgICAgICAgIHBvaW50cy5hcHBlbmQoUG9seWxpbmVQb2ludC5wYXJzZUZyb21TdHJpbmcocG9pbnRTdHJpbmdzW2ldKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBvbHlsaW5lXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBzdHJpbmcgaW4gdGhlIHBvbHlsaW5lIGZvcm1hdCAoYHgxLHkxIHgyLHkyLCB4Myx5M2ApXG4gICAgICovXG4gICAgZ2V0IHN0cmluZygpIHtcbiAgICAgICAgbGV0IHN0cmluZyA9IFwiXCI7XG4gICAgICAgIGZvcihsZXQgaSA9IDAgOyBpIDwgdGhpcy5sZW5ndGggOyArK2kpIHtcbiAgICAgICAgICAgIGlmKGkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpbmcgKz0gdGhpcy5hcnJbaV0uc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogd3JhcHBlciBmb3IgZm9yZWFjaCBvbiB0aGUgcG9seWxpbmUgcG9pbnRzXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGZ1bmMgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIGVsZW1lbnRcbiAgICAgKi9cbiAgICBmb3JFYWNoKGZ1bmMpIHtcbiAgICAgICAgZm9yKGxldCBpID0gMCA7IGkgPCB0aGlzLmFyci5sZW5ndGggOyArK2kpIHtcbiAgICAgICAgICAgIGZ1bmModGhpcy5hcnJbaV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFNWRyBwb2x5bGluZSAoYSBwYXRoIGRlZmluZWQgYnkgc2VxdWVuY2Ugb2YgcG9pbnRzIG9uIHBsYW5lKVxuICogQGV4dGVuZHMgVGFnXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2x5TGluZSBleHRlbmRzIFRhZyB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQb2x5bGluZVBvaW50c30gcG9pbnRzIHBvaW50cyBkZXNjcmliaW5nIHRoaXMgcG9seWxpbmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0cm9rZVdpZHRoXSB3aWR0aCBvZiB0aGUgc3Ryb2tlIGZvciB0aGlzIHBvbHlsaW5lIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbG9yXSBDU1MgY29sb3Igb2YgdGhpcyBwb2x5bGluZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBvaW50cywgc3Ryb2tlV2lkdGgsIGNvbG9yKSB7XG4gICAgICAgIHN1cGVyKFwicG9seWxpbmVcIik7XG5cbiAgICAgICAgbGV0IGF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICBwb2ludHM6IHBvaW50cy5zdHJpbmcsXG4gICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHN0cm9rZVdpZHRoXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoY29sb3IhPT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuc3Ryb2tlID0gY29sb3JcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkQXR0cihhdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgcG9pbnRzIG9mIHRoaXMgcG9seWxpbmVcbiAgICAgKiBAcGFyYW0ge1BvbHlsaW5lUG9pbnRzfSBwb2ludHMgbmV3IHNldCBvZiBwb2ludHMgZGVzY3JpYmluZyB0aGlzIHBvbHlsaW5lXG4gICAgICovXG4gICAgdXBkYXRlUG9pbnRzKHBvaW50cykge1xuICAgICAgICB0aGlzLmFkZEF0dHIoe1xuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMuc3RyaW5nXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUZXh0IGVsZW1lbnQgaW4gU1ZHXG4gKiBAZXh0ZW5kcyBUYWdcbiAqL1xuZXhwb3J0IGNsYXNzIFRleHQgZXh0ZW5kcyBUYWcge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4ICAgICAgIGhvcml6b250YWwgcG9zaXRpb24gaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAgICAgIHZlcnRpY2FsIHBvc2l0aW9uIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdyAgICAgICB3aWR0aCBvZiB0aGUgdGV4dCBib3ggaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoICAgICAgIGhlaWdodCBvZiB0aGUgdGV4dCBib3ggaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0ZXh0ICAgIHRleHQgY29udGVudCBvZiB0aGUgdGV4dCBib3hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2l6ZSAgICBDU1MgZm9udCBzaXplIG9mIHRoZSB0ZXh0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb2xvcj1cImJsYWNrXCJdIGNvbG9yIG9mIHRoZSB0ZXh0XG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCB3LCBoLCB0ZXh0LCBzaXplLCBjb2xvciA9IFwiYmxhY2tcIikge1xuICAgICAgICBzdXBlcihcInRleHRcIik7XG4gICAgICAgIHRoaXMuYWRkQXR0cih7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgZmlsbDogY29sb3JcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYoc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRBdHRyKHtcbiAgICAgICAgICAgICAgICAnZm9udC1zaXplJzogc2l6ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZCh0ZXh0KTtcbiAgICB9XG59XG5cbi8qKlxuICogTXVsdGkgbGluZSB0ZXh0IGVsZW1lbnQgaW4gU1ZHXG4gKlxuICogTXVsdGkgbGluZSB0ZXh0IGlzIG5vdCBuYXRpdmVseSBzdXBwb3J0ZW5kIGluIFNWRyAxLjEsXG4gKiB0aGUgd29ya2Fyb3VuZCBpcyB0byB1c2UgdGhlIDxmb3JlaWduT2JqZWN0PiBlbGVtZW50IGFuZCBkaXNwbGF5XG4gKiBhIEhUTUwgcGFyYWdyYXBoIGluc2lkZSBvZiB0aGUgU1ZHIGRvY3VtZW50LlxuICpcbiAqIEJlY2F1c2UgdGhpcyB0ZWNobmlxdWUgaXMgbm90IHN1cHBvcnRlZCBieSBhbGwgb2YgdGhlIGJyb3dzZXJzLFxuICogdGhlIGZvcmVpZ25PYmplY3QgZWxlbWVudCBpcyB3cmFwcGVkIGluIDxzd2l0Y2g+LCB3aGljaFxuICogcHJvdmlkZXMgZmFsbGJhY2sgZm9yIHRob3NlIGNhc2VzLlxuICpcbiAqIHJlYWQgbW9yZTogW2ZvcmVpZ25PYmplY3Qgb24gTUROIHdlYiBkb2NzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvRWxlbWVudC9mb3JlaWduT2JqZWN0KVxuICpcbiAqIEBleHRlbmRzIFRhZ1xuICovXG5leHBvcnQgY2xhc3MgTXVsdGlMaW5lVGV4dCBleHRlbmRzIFRhZyB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggICAgICAgaG9yaXpvbnRhbCBwb3NpdGlvbiBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgICAgICAgdmVydGljYWwgcG9zaXRpb24gaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3ICAgICAgIHdpZHRoIG9mIHRoZSB0ZXh0IGJveCBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGggICAgICAgaGVpZ2h0IG9mIHRoZSB0ZXh0IGJveCBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRleHQgICAgdGV4dCBjb250ZW50IG9mIHRoZSB0ZXh0IGJveFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaXplICAgIENTUyBmb250IHNpemUgb2YgdGhlIHRleHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbG9yPVwiYmxhY2tcIl0gY29sb3Igb2YgdGhlIHRleHRcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHcsIGgsIHRleHQsIHNpemUsIGNvbG9yID0gXCJibGFja1wiKSB7XG4gICAgICAgIHN1cGVyKFwic3dpdGNoXCIpO1xuXG4gICAgICAgIGxldCBmb3JlaWduT2JqZWN0ID0gbmV3IFRhZyhcImZvcmVpZ25PYmplY3RcIik7XG4gICAgICAgIGxldCBhbHRlcm5hdGl2ZVRleHQgPSBuZXcgVGV4dCh4LCB5LCB3LCBoLCB0ZXh0LCBzaXplLCBjb2xvcik7XG5cbiAgICAgICAgZm9yZWlnbk9iamVjdC5hZGRBdHRyKHtcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0ICR3cmFwcGVyID0gJChcIjxkaXY+XCIpXG4gICAgICAgICAgICAuYXR0cihcInhtbG5zXCIsIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiKVxuICAgICAgICAgICAgLmFkZENsYXNzKFwibXVsdGlsaW5ldGV4dFwiKVxuICAgICAgICAgICAgLmNzcyhcImhlaWdodFwiLCBoKTtcblxuICAgICAgICBsZXQgJHBhcmFncmFwaCA9ICQoXCI8cD5cIilcbiAgICAgICAgICAgIC5hdHRyKFwieG1sbnNcIiwgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIpXG4gICAgICAgICAgICAuY3NzKFwiZm9udC1zaXplXCIsIHNpemUpXG4gICAgICAgICAgICAuYXBwZW5kKHRleHQpO1xuXG4gICAgICAgICR3cmFwcGVyLmFwcGVuZCgkcGFyYWdyYXBoKTtcbiAgICAgICAgZm9yZWlnbk9iamVjdC4kZWwuYXBwZW5kKCR3cmFwcGVyKVxuXG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZChcbiAgICAgICAgICAgIGZvcmVpZ25PYmplY3QuJGVsXG4gICAgICAgICkuYXBwZW5kKFxuICAgICAgICAgICAgYWx0ZXJuYXRpdmVUZXh0LiRlbFxuICAgICAgICApXG4gICAgfVxuXG59XG5cbi8qKlxuICogcGF0dGVybiBvYmplY3QgaW4gU1ZHXG4gKiBAZXh0ZW5kcyBUYWdcbiAqL1xuZXhwb3J0IGNsYXNzIFBhdHRlcm4gZXh0ZW5kcyBUYWcge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAgICAgdW5pcXVlIGlkIG9mIHRoaXMgcGF0dGVyblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAgd2lkdGggb2Ygb25lIHBhdHRlcm4gdGlsZSBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBoZWlnaHQgb2Ygb25lIHBhdHRlcm4gdGlsZSBpbiBTVkcgcGl4ZWxzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaWQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoXCJwYXR0ZXJuXCIpO1xuXG4gICAgICAgIHRoaXMuYWRkQXR0cih7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgcGF0dGVyblVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIsXG4gICAgICAgICAgICB2aWV3Qm94OiBcIjAgMCBcIit3aWR0aCtcIiBcIitoZWlnaHRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgY2hpbGQgdG8gdGhpcyBwYXR0ZXJuXG4gICAgICpcbiAgICAgKiBwYXR0ZXJuIGJlaGF2ZXMgYSBsaXR0bGUgbGlrZSB7QGxpbmsgR3JvdXB9IC0gaXQgY29udGFpbnMgY2hpbGQgZWxlbWVudHMsIHdoaWNoIHJlcHJlc2VudCB0aGUgY29udGVudCBvZiBvbmUgdGlsZSBvZiB0aGUgcGF0dGVyblxuICAgICAqIGFuZCB0aGUgd2hvbGUgcGFja2FnZSBvZiB0aGUgY2hpbGQgZWxlbWVudHMgaXMgcmVwZWF0ZWQgb24gZWFjaCB0aWxlIG9mIHRoZSBwYXR0ZXJuXG4gICAgICogQHBhcmFtIHtTdmdFbGVtZW50fSBlbCBlbGVtZW50IHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgcGF0dGVyblxuICAgICAqL1xuICAgIGFkZENoaWxkKGVsKSB7XG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZChlbC4kZWwpO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfVxufVxuIiwiLyoqIEBtb2R1bGUgVHV0b3JpYWwgKi9cbi8qKlxuICogRGlzcGxheSBhbmQgbWFuYWdlIHRoZSB0dXRvcmlhbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUdXRvcmlhbCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDYW52YXN9IHBhcmVudFNWRyBpbnN0YW5jZSBvZiBbQ2FudmFzXSguL21vZHVsZS1DYW52YXMuaHRtbCkgZm9yIHRoaXMgdHV0b3JpYWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25UdXRvcmlhbENsb3NlZF0gY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB1c2VyIGNsb3NlcyBvciBmaW5pc2hlcyB0aGUgdHV0b3JpYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRTVkcsIG9uVHV0b3JpYWxDbG9zZWQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluc3RhbmNlIG9mIFtDYW52YXNdKC4vbW9kdWxlLUNhbnZhcy5odG1sKSBmb3IgdGhpcyB0dXRvcmlhbFxuICAgICAgICAgKiBAdHlwZSB7Q2FudmFzfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXJlbnRTVkcgPSBwYXJlbnRTVkc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhlbHBlciB2YXJpYWJsZSBmb3IgdGhlIGBzdGVwYCBwcm9wZXJ0eSwgc3RvcmVzIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHR1dG9yaWFsIChzdGVwIGAwYCBtZWFucyB0aGF0IHR1dG9yaWFsIGlzIGNsb3NlZClcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBqUXVlcnkgZWxlbWVudCBjb250YWluaW5nIHRoZSB0dXRvcmlhbCBwb3B1cFxuICAgICAgICAgKiBAdHlwZSB7alF1ZXJ5LmVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiR0dXRvcmlhbFdpbmRvdztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGpRdWVyeSBlbGVtZW50IGZvciB0aGUgZHluYW1pYyBwYXJ0IG9mIHRoZSB0dXRvcmlhbCBwb3B1cFxuICAgICAgICAgKiAodGV4dCBhbmQgYnV0dG9ucyB0aGF0IGFyZSBkZXBlbmRlbnQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHR1dG9yaWFsKVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiR0dXRvcmlhbENvbnRlbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IHJlcHJlc2VudCBpbnRpdmlkdWFsIHN0ZXBzIGluIHRoZSB0dXRvcmlhbFxuICAgICAgICAgKiBieSBkZWZhdWx0IHBvcHVsYXRlZCB3aXRoIHN0ZXAgYDBgIHRoYXQgY2xvc2VzIHRoZSB0dXRvcmlhbFxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0ZXBzID0gWygpID0+IHsgdGhpcy5jbG9zZVdpbmRvdyhvblR1dG9yaWFsQ2xvc2VkKSB9XTtcblxuICAgICAgICAvLyBzZXQgdXAgdGhlIHR1dG9yaWFsXG4gICAgICAgIHRoaXMuc2V0VXBUdXRvcmlhbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgY3VycmVudCBzdGVwIG9mIHRoZSB0dXRvcmlhbCwgdGhpcyBudW1iZXIgY29ycmVzcG9uZHMgdG8gdGhlIGluZGV4IGluIHRoZSBgdGhpcy5zdGVwc2AgYXJyYXlcbiAgICAgKiB0aGF0IGNvbnRhaW5zIHRoZSBmdW5jdGlvbiBmb3IgdGhlIGxhc3QgZGlzcGxheWVkIHN0ZXBcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHN0ZXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTdGVwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNoYW5nZSB0aGUgY3VycmVudCBzdGVwIG9mIHRoZSB0dXRvcmlhbCwgYDBgIG1lYW5zIFwic3RvcCB0aGUgdHV0b3JpYWxcIlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdmFsdWUgdGhlIHN0ZXAgb2YgdGhlIHR1dG9yaWFsIHRvIGJlIGRpc3BsYXllZFxuICAgICAqL1xuICAgIHNldCBzdGVwKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSB2YWx1ZTtcblxuICAgICAgICBpZih0aGlzLnN0ZXAgPCB0aGlzLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zdGVwc1t0aGlzLnN0ZXBdKCk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuc3RlcCA9PT0gMSlcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlXaW5kb3coKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXNldCBhbGwgdHV0b3JpYWwgaG9va3NcbiAgICAgKi9cbiAgICByZXNldEhvb2tzKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogX3R1dG9yaWFsIGhvb2tfLCBjYWxsZWQgd2hlbiB0aGUgY29udGV4dCBtZW51IGlzIG9wZW5lZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNvbnRleHRNZW51T3BlbmVkID0gKCkgPT4ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIF90dXRvcmlhbCBob29rXywgY2FsbGVkIHdoZW4gYSBuZXcgZWxlbWVudCBpcyBhZGRlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkVsZW1lbnRBZGRlZCA9ICgpID0+IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBfdHV0b3JpYWwgaG9va18sIGNhbGxlZCB3aGVuIGEgYm94IGlzIG1vdmVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQm94TW92ZWQgPSAoKSA9PiB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogX3R1dG9yaWFsIGhvb2tfLCBjYWxsZWQgd2hlbiBhIGJveCBpcyByb3RhdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQm94Um90YXRlZCA9ICgpID0+IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBfdHV0b3JpYWwgaG9va18sIGNhbGxlZCB3aGVuIGFuIG91dHB1dCBib3ggdmFsdWUgaXMgc2V0IHRvIGBvbmBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25PdXRwdXRCb3hUcnVlID0gKCkgPT4ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIF90dXRvcmlhbCBob29rXywgY2FsbGVkIHdoZW4gdGhlIGNhbnZhcyBpcyBtb3ZlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNhbnZhc01vdmVkID0gKCkgPT4ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIF90dXRvcmlhbCBob29rXywgY2FsbGVkIHdoZW4gdGhlIGNhbnZhcyBpcyB6b29tZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25DYW52YXNab29tZWQgPSAoKSA9PiB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogX3R1dG9yaWFsIGhvb2tfLCBjYWxsZWQgd2hlbiBhIGJveCBpcyByZW1vdmVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRWxlbWVudFJlbW92ZWQgPSAoKSA9PiB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogX3R1dG9yaWFsIGhvb2tfLCBjYWxsZWQgd2hlbiB1c2VyIGNoYW5nZXMgdGhlIHN0YXRlIG9mIGFuIGlucHV0IGJveFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNoYW5nZUlucHV0Qm94U3RhdGUgPSAoKSA9PiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdXAgdGhlIHR1dG9yaWFsOiByZXNldCBhbGwgdHV0b3JpYWwgaG9va3MgYW5kIGRlZmluZSB0aGUgb3JkZXIgb2YgdHV0b3JpYWwgc3RlcHNcbiAgICAgKi9cbiAgICBzZXRVcFR1dG9yaWFsKCkge1xuICAgICAgICB0aGlzLnJlc2V0SG9va3MoKTtcblxuICAgICAgICB0aGlzLnN0ZXBzLnB1c2goXG4gICAgICAgICAgICAoKSA9PiB7IHRoaXMuc3RlcFdlbGNvbWUoKSB9LFxuICAgICAgICAgICAgKCkgPT4geyB0aGlzLnN0ZXBBZGRCb3hlcygpIH0sXG4gICAgICAgICAgICAoKSA9PiB7IHRoaXMuc3RlcE1vdmVDYW52YXMoKSB9LFxuICAgICAgICAgICAgKCkgPT4geyB0aGlzLnN0ZXBab29tQ2FudmFzKCkgfSxcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5zdGVwTW92ZUJveGVzKCkgfSxcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5zdGVwV2lyaW5nKCkgfSxcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5zd2l0Y2hJbnB1dEJveCgpIH0sXG4gICAgICAgICAgICAoKSA9PiB7IHRoaXMuc3RlcFJlbW92ZUJveCgpIH0sXG4gICAgICAgICAgICAoKSA9PiB7IHRoaXMuc3RlcEZpbmlzaCgpIH1cbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIF90dXRvcmlhbCBzdGVwXzogZGlzcGxheSBjb250ZXh0IG1lbnVcbiAgICAgKi9cbiAgICBzdGVwV2VsY29tZSgpIHtcbiAgICAgICAgdGhpcy53aW5kb3dDb250ZW50KFxuICAgICAgICAgICAgYFdlbGNvbWUgdG8gSHJhZGxhISBUbyBnZXQgc3RhcnRlZCwgY2xpY2sgYW55d2hlcmUgb24gdGhlIGVkaXRpbmcgYXJlYSB3aXRoIHlvdXIgcmlnaHQgbW91c2UgYnV0dG9uLmBcbiAgICAgICAgKVxuXG4gICAgICAgIHRoaXMub25Db250ZXh0TWVudU9wZW5lZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIHJ1bnMgb25seSBvbmNlXG4gICAgICAgICAgICB0aGlzLm9uQ29udGV4dE1lbnVPcGVuZWQgPSAoKSA9PiB7fVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogX3R1dG9yaWFsIHN0ZXBfOiBhZGQgaW5wdXQgYm94LCBvdXRwdXQgYm94IGFuZCBhIE5PVCBnYXRlXG4gICAgICovXG4gICAgc3RlcEFkZEJveGVzKCkge1xuICAgICAgICB0aGlzLndpbmRvd0NvbnRlbnQoXG4gICAgICAgICAgICBgR3JlYXQgam9iISBOb3cgeW91IGtub3csIGhvdyB0byBvcGVuIHRoZSBlZGl0b3IgbWVudS5cbiAgICAgICAgICAgIE5vdyB0cnkgdG8gYWRkIGFuIDxlbT5JbnB1dCBib3g8L2VtPiwgPGVtPk91dHB1dCBib3g8L2VtPiBhbmQgYSA8ZW0+Tk9UIGdhdGU8L2VtPlxuICAgICAgICAgICAgdG8gdGhlIGVkaXRpbmcgYXJlYS5gKVxuXG4gICAgICAgIGxldCBlbGVtZW50c0FkZGVkID0ge1xuICAgICAgICAgICAgaW5wdXRCb3g6IGZhbHNlLFxuICAgICAgICAgICAgb3V0cHV0Qm94OiBmYWxzZSxcbiAgICAgICAgICAgIG5vdEdhdGU6IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uRWxlbWVudEFkZGVkID0gKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c0FkZGVkLmlucHV0Qm94ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm91dHB1dFwiOlxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c0FkZGVkLm91dHB1dEJveCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJub3RcIjpcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNBZGRlZC5ub3RHYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gYWN0aW9uIG9uIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGVsZW1lbnRzQWRkZWQuaW5wdXRCb3ggJiYgZWxlbWVudHNBZGRlZC5vdXRwdXRCb3ggJiYgZWxlbWVudHNBZGRlZC5ub3RHYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBhY3Rpb25cbiAgICAgICAgICAgICAgICB0aGlzLm9uRWxlbWVudEFkZGVkID0gKCkgPT4ge31cblxuICAgICAgICAgICAgICAgIC8vIHByb2NlZWQgdG8gdGhlIG5leHQgc3RlcCBvZiB0aGUgdHV0b3JpYWxcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBfdHV0b3JpYWwgc3RlcF86IG1vdmUgdGhlIGNhbnZhc1xuICAgICAqL1xuICAgIHN0ZXBNb3ZlQ2FudmFzKCkge1xuICAgICAgICB0aGlzLndpbmRvd0NvbnRlbnQoXG4gICAgICAgICAgICBgWW91IGNhbiBtb3ZlIHRoZSBlZGl0aW5nIGFyZWEgKHNvbWV0aW1lcyBjYWxsZWQgY2FudmFzKSBieSBkcmFnZ2luZ1xuICAgICAgICAgICAgd2l0aCB0aGUgbWlkZGxlIG1vdXNlIGJ1dHRvbiBvciBieSBob2xkaW5nIHRoZSA8Y29kZT5DdHJsPC9jb2RlPiBrZXlcbiAgICAgICAgICAgIGFuZCBkcmFnZ2luZyB3aXRoIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbi4gQ2hlY2sgaXQgb3V0LmApXG5cbiAgICAgICAgdGhpcy5vbkNhbnZhc01vdmVkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB0aGlzLm9uQ2FudmFzTW92ZWQgPSAoKSA9PiB7fVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogX3R1dG9yaWFsIHN0ZXBfOiB6b29tIHRoZSBjYW52YXNcbiAgICAgKi9cbiAgICBzdGVwWm9vbUNhbnZhcygpIHtcbiAgICAgICAgdGhpcy53aW5kb3dDb250ZW50KFxuICAgICAgICAgICAgYFlvdSBjYW4gYWxzbyB6b29tIGluIGFuZCBvdXQgdXNpbmcgPGNvZGU+Q3RybDwvY29kZT4gYW5kIHRoZSBtb3VzZSB3aGVlbC5gXG4gICAgICAgIClcblxuICAgICAgICB0aGlzLm9uQ2FudmFzWm9vbWVkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB0aGlzLm9uQ2FudmFzWm9vbWVkID0gKCkgPT4ge307XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBfdHV0b3JpYWwgc3RlcF86IG1vdmUgdGhlIGJveGVzXG4gICAgICovXG4gICAgc3RlcE1vdmVCb3hlcygpIHtcbiAgICAgICAgdGhpcy53aW5kb3dDb250ZW50KGBZb3UgY2FuIG1vdmUgdGhlIGVsZW1lbnRzIG9uIHRoZSBlZGl0aW5nIGNhbnZhcyBieSBkcmFnZ2luZyB0aGVtXG4gICAgICAgICAgICB1c2luZyB0aGUgbGVmdCBtb3VzZSBidXR0b24uIFlvdSBjYW4gYWxzbyByb3RhdGUgdGhlbSB1c2luZyBtaWRkbGUgY2xpY2suIFRyeSBpdCBvdXQuYClcblxuICAgICAgICBsZXQgYm94TW92ZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGJveFJvdGF0ZWQgPSBmYWxzZTtcblxuICAgICAgICBsZXQgbW92ZVJvdGF0ZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYoYm94TW92ZWQgJiYgYm94Um90YXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbkJveE1vdmVkID0gKCkgPT4ge1xuICAgICAgICAgICAgYm94TW92ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLm9uQm94TW92ZWQgPSAoKSA9PiB7fVxuXG4gICAgICAgICAgICBtb3ZlUm90YXRlQ2FsbGJhY2soKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbkJveFJvdGF0ZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBib3hSb3RhdGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5vbkJveFJvdGF0ZWQgPSAoKSA9PiB7fVxuXG4gICAgICAgICAgICBtb3ZlUm90YXRlQ2FsbGJhY2soKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogX3R1dG9yaWFsIHN0ZXBfOiBjcmVhdGUgYW4gaW52ZXJ0b3JcbiAgICAgKi9cbiAgICBzdGVwV2lyaW5nKCkge1xuICAgICAgICB0aGlzLndpbmRvd0NvbnRlbnQoYEVzc2VudGlhbCBwYXJ0IG9mIGxvZ2ljIG5ldHdvcmtzIGlzIHRoZSB3aXJpbmcuIENyZWF0ZSBhIHZlcnkgc2ltcGxlXG4gICAgICAgICAgICBpbnZlcnRlciBieSBjb25uZWN0aW5nIHRoZSA8ZW0+SW5wdXQgYm94PC9lbT4gdG8gdGhlIGlucHV0IG9mIHRoZSA8ZW0+Tk9UIGdhdGU8L2VtPlxuICAgICAgICAgICAgYW5kIHRoZSBvdXRwdXQgb2YgdGhlIDxlbT5OT1QgZ2F0ZTwvZW0+IHRvIHRoZSBpbnB1dCBvZiB0aGUgPGVtPk91dHB1dCBib3g8L2VtPi5gLFxuICAgICAgICAgICAgYFRvIGNvbm5lY3QgdHdvIGVsZW1udHMsIHNpbXBseSBjbGljayBvbiBhIGNvbm5lY3RvciBvZiB0aGUgZmlyc3QgZWxlbWVudCxcbiAgICAgICAgICAgIHRoYW4gY2xpY2sgb24gYSBjb25lY3RvciBvZiB0aGUgc2Vjb25kIGVsZW1lbnQuYClcblxuICAgICAgICB0aGlzLm9uT3V0cHV0Qm94VHJ1ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICAgICAgICB0aGlzLm9uT3V0cHV0Qm94VHJ1ZSA9ICgpID0+IHt9O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIF90dXRvcmlhbCBzdGVwXzogY2hhbmdlIHRoZSBzdGF0ZSBvZiBhbiBpbnB1dCBib3hcbiAgICAgKi9cbiAgICBzd2l0Y2hJbnB1dEJveCgpIHtcbiAgICAgICAgdGhpcy53aW5kb3dDb250ZW50KGBcbiAgICAgICAgICAgIFRoZSBpbnB1dCBib3hlcyBjYW4gYmUgaW4gdHdvIHN0YXRlczogPGVtPk9OPC9lbT4gYW5kIDxlbT5PRkY8L2VtPiwgc2lnbmFsbGVkXG4gICAgICAgICAgICBieSB0aGUgZ3JlZW4gYW5kIHJlZCBjb2xvcnMgcmVzcGVjdGl2ZWx5LiBZb3UgY2FuIGxlZnQgY2xpY2sgb24gYW4gSW5wdXQgYm94IHRvXG4gICAgICAgICAgICBzd2l0Y2ggaXRzIHN0YXRlLiBUcnkgaXQgb3V0IVxuICAgICAgICBgKVxuXG4gICAgICAgIHRoaXMub25DaGFuZ2VJbnB1dEJveFN0YXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VJbnB1dEJveFN0YXRlID0gKCkgPT4ge307XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogX3R1dG9yaWFsIHN0ZXBfOiByZW1vdmUgYSBib3hcbiAgICAgKi9cbiAgICBzdGVwUmVtb3ZlQm94KCkge1xuICAgICAgICB0aGlzLndpbmRvd0NvbnRlbnQoXG4gICAgICAgICAgICBgV2hlbiB5b3UgcmlnaHQgY2xpY2sgb24gYW4gZWxlbWVudCwgeW91IGNhbiBmaW5kIGEgbmV3IGl0ZW0gaW4gdGhlIG1lbnUsXG4gICAgICAgICAgICB0aGF0IGFsbG93cyB5b3UgdG8gcmVtb3ZlIHRoZSBlbGVtZW50LiBUaGlzIHdvcmtzIGZvciB3aXJlcyBhcyB3ZWxsIGFzIGZvciBnYXRlcyBhbmQgb3RoZXIgdHlwZXMgb2YgYm94ZXMuXG4gICAgICAgICAgICBUcnkgdG8gcmVtb3ZlIGFuIGVsZW1lbnQhYFxuICAgICAgICApXG5cbiAgICAgICAgdGhpcy5vbkVsZW1lbnRSZW1vdmVkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgICAgICAgIHRoaXMub25FbGVtZW50UmVtb3ZlZCA9ICgpID0+IHt9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogX3R1dG9yaWFsIHN0ZXBfOiBhc2sgdGhlIHVzZXIgaWYgdGhleSB3YW50IHRvIGNsZWFuIHRoZSBjYW52YXMgYmVmb3JlIGNsb3NpbmcgdGhlIHR1dG9yaWFsXG4gICAgICovXG4gICAgc3RlcEZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy53aW5kb3dDb250ZW50KGBZb3UncmUgYWxsIHNldCwgZW5qb3kgeW91ciBzdGF5IWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBgRG8geW91IHdpc2ggdG8gc3RhcnQgd2l0aCBlbXB0eSBjYW52YXM/YClcbiAgICAgICAgdGhpcy53aW5kb3dDaG9pY2UoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGV4dDogJ3llcywgY2xlYW4gdGhlIGNhbnZhcycsXG4gICAgICAgICAgICAgICAgZnVuYzogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNWRy5jbGVhbkNhbnZhcygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRleHQ6ICdubywga2VlcCB0aGUgY2FudmFzIGFzIGl0IGlzJyxcbiAgICAgICAgICAgICAgICBmdW5jOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRpc3BsYXkgdGhlIHR1dG9yaWFsIHdpbmRvd1xuICAgICAqL1xuICAgIGRpc3BsYXlXaW5kb3coKSB7XG4gICAgICAgIHRoaXMucGFyZW50U1ZHLiRzdmcuYWZ0ZXIodGhpcy4kdHV0b3JpYWxXaW5kb3cpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2xvc2UgdGhlIHR1dG9yaWFsIHdpbmRvd1xuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbb25UdXRvcmlhbENsb3NlZF0gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgdHV0b3JpYWwgaXMgY2xvc2VkXG4gICAgICovXG4gICAgY2xvc2VXaW5kb3cob25UdXRvcmlhbENsb3NlZCkge1xuICAgICAgICB0aGlzLiR0dXRvcmlhbFdpbmRvdy5yZW1vdmUoKTtcblxuICAgICAgICBpZihvblR1dG9yaWFsQ2xvc2VkIT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvblR1dG9yaWFsQ2xvc2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIHR1dG9yaWFsIHdpbmRvdyB0ZXh0IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gIHsuLi5zdHJpbmd9IHRleHQgZWFjaCBzdHJpbmcgaXMgYSBzZXBhcmF0ZSBwYXJhZ3JhcGhcbiAgICAgKi9cbiAgICB3aW5kb3dDb250ZW50KC4uLnRleHQpIHtcbiAgICAgICAgaWYoIXRoaXMuJHR1dG9yaWFsV2luZG93KSB7XG4gICAgICAgICAgICB0aGlzLiR0dXRvcmlhbFdpbmRvdyA9ICQoXCI8ZGl2PlwiKS5hdHRyKFwiaWRcIiwgXCJ0dXRvcmlhbFwiKTtcbiAgICAgICAgICAgIHRoaXMuJHR1dG9yaWFsV2luZG93LmFwcGVuZChcbiAgICAgICAgICAgICAgICAkKFwiPGRpdj5cIikuYWRkQ2xhc3MoXCJ0b3BCdXR0b25zXCIpLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgJChcIjxhPlwiKS5hdHRyKFwiaHJlZlwiLCBcIiNcIikuYWRkQ2xhc3MoXCJidXR0b24gY2xvc2VcIilcbiAgICAgICAgICAgICAgICAgICAgLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgdGhpcy4kdHV0b3JpYWxDb250ZW50ID0gJChcIjxkaXY+XCIpLmFkZENsYXNzKFwiY29udGVudFwiKTtcbiAgICAgICAgICAgIHRoaXMuJHR1dG9yaWFsV2luZG93LmFwcGVuZCh0aGlzLiR0dXRvcmlhbENvbnRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kdHV0b3JpYWxDb250ZW50Lmh0bWwoXCJcIik7XG4gICAgICAgIGZvciAoY29uc3QgcGFyYWdyYXBoIG9mIHRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuJHR1dG9yaWFsQ29udGVudC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgJChcIjxwPlwiKS5odG1sKHBhcmFncmFwaClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYnV0dG9ucyB3aXRoIGNob2ljZXMgdG8gdGhlIHR1dG9yaWFsIHdpbmRvd1xuICAgICAqIEBwYXJhbSAgey4uLm9iamVjdH0gY2hvaWNlcyBlYWNoIGNob2ljZSBpcyBhbiBvYmplY3QgaW4gd2l0aCBhIGBzdHJpbmdgIHByb3BlcnR5IF90ZXh0XyBhbmQgYSBgZnVuY3Rpb25gIHByb3BlcnR5IF9mdW5jX1xuICAgICAqL1xuICAgIHdpbmRvd0Nob2ljZSguLi5jaG9pY2VzKSB7XG4gICAgICAgIGxldCAkY2hvaWNlcyA9ICQoXCI8b2w+XCIpLmFkZENsYXNzKFwiY2hvaWNlc1wiKTtcbiAgICAgICAgZm9yIChjb25zdCBjaG9pY2Ugb2YgY2hvaWNlcykge1xuICAgICAgICAgICAgJGNob2ljZXMuYXBwZW5kKFxuICAgICAgICAgICAgICAgICQoXCI8bGk+XCIpLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgJChcIjxhPlwiKS5hdHRyKFwiaHJlZlwiLCBcIiNcIikuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hvaWNlLmZ1bmMoKVxuICAgICAgICAgICAgICAgICAgICB9KS5odG1sKGNob2ljZS50ZXh0KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiR0dXRvcmlhbENvbnRlbnQuYXBwZW5kKCRjaG9pY2VzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdGFydCB0aGUgdHV0b3JpYWxcbiAgICAgKi9cbiAgICBzdGFydCgpIHsgdGhpcy5zdGVwID0gMTsgfVxuXG4gICAgLyoqXG4gICAgICogZ28gdG8gdGhlIG5leHQgc3RlcCBvZiB0aGUgdHV0b3JpYWxcbiAgICAgKi9cbiAgICBuZXh0KCkgeyB0aGlzLnN0ZXArKzsgfVxuXG4gICAgLyoqXG4gICAgICogc3RvcCB0aGUgdHV0b3JpYWxcbiAgICAgKi9cbiAgICBzdG9wKCkgeyB0aGlzLnN0ZXAgPSAwIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFZpZXdCb3ggKi9cbi8qKlxuICogVmlld0JveCBwcm92aWRlcyBhbiBhcGkgZm9yIG9wcmVyYXRpbmcgd2l0aCB0aGUgdmlld0JveCBhcmd1bWVudCBvZiB0aGUgPHN2Zz4gRE9NIGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXdCb3gge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdmlld0JveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0ICAgZGlzdGFuY2Ugb2YgdGhlIGxlZnQgZWRnZSBvZiB0aGUgdmlld2JveCBmcm9tIGRvY3VtZW50J3MgeSBheGlzIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wICAgIGRpc3RhbmNlIG9mIHRoZSB0b3AgZWRnZSBvZiB0aGUgdmlld2JveCBmcm9tIHRoZSBkb2N1bWVudCdzIHggYXhpcyBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoICB3aWR0aCBvZiB0aGUgdmlld2JveCBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBoZWlnaHQgb2YgdGhlIHZpZXdib3ggaW4gU1ZHIHBpeGVsc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVmlld0JveCBhdHRyaWJ1dGVzIGJlZm9yZSBhcHBseWluZyB6b29tIGFuZCBzaGlmdFxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFsID0geyBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBhbW91bnQgb2Ygem9vbSBvbiB0aGUgdmlld2JveFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXhab29tID0gODtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIGFtb3VudCBvZiB6b29tIG9uIHRoZSB2aWV3Ym94XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pblpvb20gPSAwLjE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFtb3VudCBvZiB6b29tIG9uIHRoZSB2aWV3Ym94LCBhbHdheXMgYmV0d2VlbiB0aGlzLm1pblpvb20gYW5kIHRoaXMubWF4Wm9vbVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFsWm9vbSA9IDFcblxuICAgICAgICAvKipcbiAgICAgICAgICogYW1vdW50IG9mIGhvcml6b250YWwgc2hpZnQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxlZnRTaGlmdCA9IDBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFtb3VudCBvZiB2ZXJ0aWNhbCBzaGlmdCBvZiB0aGUgZG9jdW1lbnRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG9wU2hpZnQgPSAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBkaW1lbnNpb25zIG9mIHRoZSB2aWV3Ym94ICh1c2VkIG9uIHdpbmRvdyByZXNpemUpXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB3aWR0aCAgbmV3IHdpZHRoIG9mIHRoZSB2aWV3Ym94IGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGhlaWdodCBuZXcgaGVpZ2h0IG9mIHRoZSB2aWV3Ym94IGluIFNWRyBwaXhlbHNcbiAgICAgKi9cbiAgICBuZXdEaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgLy8ga2VlcCB0aGUgdmlld2JveCBjZW50ZXJlZFxuICAgICAgICB0aGlzLnJlYWwubGVmdCArPSAodGhpcy5yZWFsLndpZHRoIC0gd2lkdGgpLzJcbiAgICAgICAgdGhpcy5yZWFsLnRvcCArPSAodGhpcy5yZWFsLmhlaWdodCAtIGhlaWdodCkvMlxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgZGltZW5zaW9uc1xuICAgICAgICB0aGlzLnJlYWwud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5yZWFsLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGFtb3VudCBvZiB6b29tIG9uIHRoZSB2aWV3Ym94XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB6b29tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFsWm9vbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIGFtb3VudCBvZiB6b29tIG9uIHRoZSB2aWV3Ym94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHRoZSBuZXcgYW1vdW50IG9mIHpvb21cbiAgICAgKi9cbiAgICBzZXQgem9vbSh2YWx1ZSkge1xuICAgICAgICAvLyBmaXQgdGhpcy5yZWFsWm9vbSB0byBmaXQgYmV0d2VlbiB0aGlzLm1pblpvb20gYW5kIHRoaXMubWF4Wm9vbVxuICAgICAgICB0aGlzLnJlYWxab29tID0gTWF0aC5tYXgoTWF0aC5taW4odmFsdWUsIHRoaXMubWF4Wm9vbSksIHRoaXMubWluWm9vbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB3aWR0aCBvZiB0aGUgdmlld2JveCB3aXRoIHRoZSBjdXJyZW50IHpvb20gYXBwbGllZFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGZpbmFsIHdpZHRoIG9mIHRoZSB2aWV3Ym94XG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFsLndpZHRoIC8gdGhpcy56b29tXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBoZWlnaHQgb2YgdGhlIHZpZXdib3ggd2l0aCB0aGUgY3VycmVudCB6b29tIGFwcGxpZWRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBmaW5hbCBoZWlnaHQgb2YgdGhlIHZpZXdib3hcbiAgICAgKi9cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFsLmhlaWdodCAvIHRoaXMuem9vbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgaG9yaXpvbnRhbCBkaXN0YW5jZSBmcm9tIHRoZSB5IGF4aXMgb2YgdGhlIGRvY3VtZW50IHdpdGggem9vbSBhbmQgc2hpZnQgdmFsdWUgYXBwbGllZFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbC5sZWZ0IC0gKHRoaXMubGVmdFNoaWZ0IC8gdGhpcy56b29tKSArICgodGhpcy5yZWFsLndpZHRoIC0gdGhpcy53aWR0aCkgLyAyKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdmVydGljYWwgZGlzdGFuY2UgZnJvbSB0aGUgeCBheGlzIG9mIHRoZSBkb2N1bWVudCB3aXRoIHpvb20gYW5kIHNoaWZ0IHZhbHVlIGFwcGxpZWRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbC50b3AgLSAodGhpcy50b3BTaGlmdCAvIHRoaXMuem9vbSkgKyAoKHRoaXMucmVhbC5oZWlnaHQgLSB0aGlzLmhlaWdodCkgLyAyKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgY29tcHV0ZWQgdmlld2JveCB2YWx1ZXMgYXMgYSBzdHJpbmcgaW4gdGhlIGNvcnJlY3QgZm9ybWF0IHRoYXQgY2FuIGJlIHVzZWQgaW4gdGhlIHZpZXdCb3ggYXR0cmlidXRlIG9mIHRoZSBTVkcgZWxlbWVudFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIGluIGZvcm1hdCBcImxlZnQgdG9wIHdpZHRoIGhlaWdodFwiXG4gICAgICovXG4gICAgZ2V0IHN0cigpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGVmdH0gJHt0aGlzLnRvcH0gJHt0aGlzLndpZHRofSAke3RoaXMuaGVpZ2h0fWBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0cmFuc2Zvcm0gaG9yaXpvbnRhbCB1bml0cyB0byB0aGUgc2NhbGUgYW5kIHNoaWZ0IG9mIHRoZSBlZGl0b3JcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggb3JpZ2luYWwgaG9yaXpvbnRhbCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gICB0cmFuc2Zvcm1lZCBob3Jpem9udGFsIHZhbHVlXG4gICAgICovXG4gICAgdHJhbnNmb3JtWCh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQgKyAoeCAvIHRoaXMuem9vbSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0cmFuc2Zvcm0gdmVydGljYWwgdW5pdHMgdG8gdGhlIHNjYWxlIGFuZCBzaGlmdCBvZiB0aGUgZWRpdG9yXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB5IG9yaWdpbmFsIHZlcnRpY2FsIHZhbHVlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAgIHRyYW5zZm9ybWVkIHZlcnRpY2FsIHZhbHVlXG4gICAgICovXG4gICAgdHJhbnNmb3JtWSh5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvcCArICh5IC8gdGhpcy56b29tKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRyYW5zZm9ybSBwYWdlWCBhbmQgcGFnZVkgcGFyYW1ldGVycyBvZiB0aGUganF1ZXJ5IGV2ZW50IHRvIG1hdGNoIHRoZSB6b29tIGFuZCBzaGlmdCBvZiB0aGUgdmlld2JveFxuICAgICAqIEBwYXJhbSAge2pxdWVyeS5Nb3VzZUV2ZW50fSBldmVudCBvcmlnaW5hbCBldmVudFxuICAgICAqIEByZXR1cm4ge2pxdWVyeS5Nb3VzZUV2ZW50fSAgICAgICB0aGUgc2FtZSBldmVudCBidXQgd2l0aCB0cmFuc2Zvcm1lZCBwYWdlWCBhbmQgcGFnZVkgbWVtYmVyc1xuICAgICAqL1xuICAgIHRyYW5zZm9ybUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnBhZ2VYID0gdGhpcy50cmFuc2Zvcm1YKGV2ZW50LnBhZ2VYKVxuICAgICAgICBldmVudC5wYWdlWSA9IHRoaXMudHJhbnNmb3JtWShldmVudC5wYWdlWSlcblxuICAgICAgICByZXR1cm4gZXZlbnRcbiAgICB9XG59XG4iXX0="}